<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2019/09/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2019/09/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(node*root)</span>    <span class="comment">//递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">pre(root-&gt;left);</span><br><span class="line">pre(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mypre</span><span class="params">(node*root)</span>   <span class="comment">//非递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;node*&gt;sta;</span><br><span class="line">node*p=root;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)   <span class="comment">//当前不为空一直往左走</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;data;    <span class="comment">//注意和中序区别开</span></span><br><span class="line">sta.push(p);</span><br><span class="line">p=p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">p=sta.top();  <span class="comment">//把中节点取出来</span></span><br><span class="line">sta.pop();</span><br><span class="line">p=p-&gt;right;  <span class="comment">//将p变成中节点的右节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">order(root-&gt;left);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">order(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myorder</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;node*&gt;sta;</span><br><span class="line">node*p=root;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(p);   </span><br><span class="line">p=p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">p=sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;data;      <span class="comment">//注意和前序遍历区别开 </span></span><br><span class="line">p=p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">post(root-&gt;left);</span><br><span class="line">post(root-&gt;right);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mypost</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;node*&gt;sta;</span><br><span class="line"><span class="built_in">stack</span>&lt;node*&gt;sta1;</span><br><span class="line">node*p=root;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(p);</span><br><span class="line"><span class="comment">//cout&lt;&lt;p-&gt;data;</span></span><br><span class="line">sta1.push(p);</span><br><span class="line">p=p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">p=sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">p=p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sta1.top()-&gt;data;</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/09/18/Leetcode-%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/18/Leetcode-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-24"><a href="#Leetcode-24" class="headerlink" title="Leetcode 24"></a>Leetcode 24</h1><p>两两交换链表中的节点(<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a></p><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>注意要设置前置空节点。</p><p>并且要获得前置节点的后两个节点（隔着一个）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode*pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next=head;</span><br><span class="line">        <span class="comment">//ListNode*temp=head-&gt;next;</span></span><br><span class="line">        ListNode*ans=pre;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;next-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temp=pre-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next=temp-&gt;next;</span><br><span class="line">            temp-&gt;next=pre-&gt;next;</span><br><span class="line">            pre-&gt;next=temp;</span><br><span class="line">            pre=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/09/18/%E5%AE%9E%E9%AA%8C/"/>
      <url>/2019/09/18/%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Neural-Voice-Cloning-With-Few-Samples"><a href="#Neural-Voice-Cloning-With-Few-Samples" class="headerlink" title="Neural-Voice-Cloning-With-Few-Samples"></a><strong>Neural-Voice-Cloning-With-Few-Samples</strong></h1><p>Github链接：<a href="https://github.com/SforAiDl/Neural-Voice-Cloning-With-Few-Samples" target="_blank" rel="noopener">https://github.com/SforAiDl/Neural-Voice-Cloning-With-Few-Samples</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python speaker_adaptation.py --data-root=<span class="string">"J:\clone\Neural-Voice-Cloning-With-Few-Samples\VCTK-Corpus"</span> --checkpoint-dir=<span class="string">"J:\clone\Neural-Voice-Cloning-With-Few-Samples\checkpoints"</span> --checkpoint-interval=<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/09/10/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/09/10/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/07/23/Amino/"/>
      <url>/2019/07/23/Amino/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/07/23/Amino/J:/hexo\source\_posts\Amino\1.png" alt="1"></p><p>微服务：也称为<strong>KernelObject</strong></p><p>•DM：提供额外功能的插件</p><p>•DK：部署微服务的基础平台</p><p>•OMS：管理微服务和地址的对应关系</p><p>•GraalVM：多语言虚拟机</p><h1 id="OMS模块分析"><a href="#OMS模块分析" class="headerlink" title="OMS模块分析"></a>OMS模块分析</h1><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>Gradle 配置</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>在example文件夹下的build.gradle文件中，有一个Task类，表示了等待命令行调用就绪的任务。这些任务并不会并行执行，而是等待它所依赖的任务执行完之后才会执行。</p><p>1.初始化参数，默认的kernel server个数是2，有效值是1-4之间的数字.</p><p>2.使用task类启动OMS server</p><p>3.再用task类依次启动Kernel Server</p><p>4.如果要runapp的话，要保证OMS server和Kernel Server全部启动，所以之前的步骤必须重新再来一次。</p><p>OMSServerImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OMSServerImpl</span><span class="params">()</span> <span class="keyword">throws</span> JSONException </span>&#123;   <span class="comment">//OMS构造函数</span></span><br><span class="line">    kernelObjectManager = <span class="keyword">new</span> GlobalKernelObjectManager();  <span class="comment">//初始化全局DK管理器</span></span><br><span class="line">    serverManager = <span class="keyword">new</span> KernelServerManager();  <span class="comment">//初始化服务端DK管理器</span></span><br><span class="line">    objectManager = <span class="keyword">new</span> MicroServiceManager();  <span class="comment">//初始化微服务管理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册新的kernelObject对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> KernelOID <span class="title">registerKernelObject</span><span class="params">(InetSocketAddress host)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    KernelOID oid = kernelObjectManager.register(host);</span><br><span class="line">    logger.info(<span class="string">"[OMS] Registering "</span> + oid.toString() + <span class="string">" on host "</span> + host.toString());</span><br><span class="line">    <span class="keyword">return</span> oid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为kernelobject注册一个新主机。(用于移动内核对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKernelObject</span><span class="params">(KernelOID oid, InetSocketAddress host)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> KernelObjectNotFoundException </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"[OMS] Registering new host for "</span> + oid.toString() + <span class="string">" on "</span> + host.toString());</span><br><span class="line">    kernelObjectManager.register(oid, host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据主机名hostname找到kernel object对象，返回对象的IP地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupKernelObject</span><span class="params">(KernelOID oid)</span></span></span><br><span class="line"><span class="function">    throws KernelObjectNotFoundException </span>&#123;</span><br><span class="line">    InetSocketAddress ko = kernelObjectManager.lookup(oid);</span><br><span class="line">    logger.info(<span class="string">"[OMS] Found host for "</span> + oid.toString() + <span class="string">" host: "</span> + ko);</span><br><span class="line">    <span class="keyword">return</span> ko;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册kernel服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKernelServer</span><span class="params">(ServerInfo info)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">    serverManager.registerKernelServer(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>心跳检测</p><p>serverManager负责收到心跳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveHeartBeat</span><span class="params">(ServerInfo srvinfo)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException, KernelServerNotFoundException </span>&#123;</span><br><span class="line">        serverManager.receiveHeartBeat(srvinfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ServerInfo 实现了Serializable接口（可序列化接口）</strong></p><p>获取系统的区域,返回一个一个string的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getRegions</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> serverManager.getRegions();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取与指定节点选择器匹配的所有服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets all servers matching the specified node selector</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spec</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemoteException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;InetSocketAddress&gt; <span class="title">getServers</span><span class="params">(NodeSelectorSpec spec)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverManager.getServers(spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MicroServiceSpec实现了Serializable接口（可序列化接口）</strong></p><p>create函数（MicroServiceSpec，object…列表）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> MicroServiceID <span class="title">create</span><span class="params">(String microServiceSpec, Object... args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> MicroServiceCreationException </span>&#123;</span><br><span class="line"><span class="comment">//spec调用fromYaml（Yaml类似于配置文件）</span></span><br><span class="line">       MicroServiceSpec spec = MicroServiceSpec.fromYaml(microServiceSpec);</span><br><span class="line">       <span class="comment">// validate Micro service spec</span></span><br><span class="line">       <span class="comment">//验证微服务的spec（句柄???）</span></span><br><span class="line">       spec.validate();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Get a best server from the given spec */</span></span><br><span class="line">       <span class="comment">/*从所给的spec中选出最好的服务器的host-IP*/</span></span><br><span class="line">       InetSocketAddress host = serverManager.getBestSuitableServer(spec);</span><br><span class="line">       <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;<span class="comment">//如果选不出则抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MicroServiceCreationException(</span><br><span class="line">               <span class="string">"[OMS] Failed to create microservice. Kernel server with the given requirements is not available"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Get the kernel server stub */</span></span><br><span class="line">       <span class="comment">//根据host-IP获取kernel server的存根</span></span><br><span class="line">       KernelServer server = serverManager.getServer(host);</span><br><span class="line">       <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MicroServiceCreationException(</span><br><span class="line">               <span class="string">"[OMS] Failed to create microservice. Kernel server not found."</span>);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//存储存根和对象ID一起在objectManager中</span></span><br><span class="line">       <span class="comment">// TODO(multi-lang): Store spec together with object ID in objectManager</span></span><br><span class="line">       <span class="comment">// MicroServiceSpec spec = MicroServiceSpec.fromYaml(microserviceSpec);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Invoke create microservice on the kernel server */</span></span><br><span class="line">       <span class="comment">//调用创建微服务在kernel server中</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           AppObjectStub appObjStub = server.createMicroService(spec, args);</span><br><span class="line">           <span class="keyword">assert</span> appObjStub != <span class="keyword">null</span>;</span><br><span class="line">           objectManager.setInstanceObjectStub(appObjStub.$__getMicroServiceId(), appObjStub);  <span class="comment">//objectManager会添加微服务的存根（appObjStub）</span></span><br><span class="line">           <span class="keyword">return</span> appObjStub.$__getMicroServiceId();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MicroServiceCreationException(</span><br><span class="line">               <span class="string">"[OMS] Failed to create microservice. Exception occurred at kernel server."</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>请求获取存根,（根据微服务的ID查找）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppObjectStub <span class="title">acquireStub</span><span class="params">(MicroServiceID id)</span> <span class="keyword">throws</span> MicroServiceNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AppObjectStub appObjStub = objectManager.getInstanceObjectStub(id);</span><br><span class="line">        appObjStub.$__initialize(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> appObjStub;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MicroServiceNotFoundException(</span><br><span class="line">            <span class="string">"[OMS] Failed to acquire stub for microservice "</span> + id, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置微服务的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(MicroServiceID id, String name)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MicroServiceNotFoundException, MicroServiceNameModificationException </span>&#123;</span><br><span class="line">        objectManager.setInstanceName(id, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detachFrom</span><span class="params">(String name)</span> <span class="keyword">throws</span> MicroServiceNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delete(objectManager.getMicroServiceByName(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(MicroServiceID microServiceId)</span> <span class="keyword">throws</span> MicroServiceNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objectManager.decrRefCountAndGet(microServiceId) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> successfullyRemoved = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* Get the kernel object Id of root group policy and delete the group policy object. This leads to</span></span><br><span class="line"><span class="comment">            successive deletion of complete multiDM tree. Deletion includes all the server policy objects of all group</span></span><br><span class="line"><span class="comment">            policy objects in the DM chain and finally those group policy objects too. */</span></span><br><span class="line">        KernelOID groupOid = objectManager.getRootGroupId(microServiceId);</span><br><span class="line">        deleteGroupPolicy(microServiceId, groupOid);</span><br><span class="line">        objectManager.removeInstance(microServiceId);</span><br><span class="line">        logger.log(</span><br><span class="line">            Level.FINE, String.format(<span class="string">"Removed microservice with oid %s"</span>, microServiceId));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.log(</span><br><span class="line">            Level.SEVERE,</span><br><span class="line">            String.format(<span class="string">"Failed to remove microservice with oid %s"</span>, microServiceId),</span><br><span class="line">            e);</span><br><span class="line">        successfullyRemoved = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> successfullyRemoved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组策略的处理"><a href="#组策略的处理" class="headerlink" title="组策略的处理"></a>组策略的处理</h2><h3 id="Policy类"><a href="#Policy类" class="headerlink" title="Policy类"></a>Policy类</h3><p>类描述了微服务策略。每个策略都应该扩展这个类。</p><p>每个微服务策略包含一个服务器策略、一个客户端策略和一个组策略</p><p>策略包含一组内部函数(由Amino使用)。运行运行时系统，当事件发生时调用的一组upcall函数和实现Amino的一组函数。为策略运行API。</p><h2 id="与DK的心跳连接"><a href="#与DK的心跳连接" class="headerlink" title="与DK的心跳连接"></a>与DK的心跳连接</h2><p>也就是和Kernel Server的心跳链接。</p><p>Kernel Server中有一个这样的函数.会发送Kernel Server的心跳给OMS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Send HeartBeats to OMS. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendHeartBeat</span><span class="params">(ServerInfo srvinfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oms.receiveHeartBeat(srvinfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.severe(<span class="string">"HeartBeat failed with exception: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    ksHeartbeatSendTimer.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在OMSServerImpl中有一个这样的函数receiveHeartBeat。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveHeartBeat</span><span class="params">(ServerInfo srvinfo)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException, KernelServerNotFoundException </span>&#123;</span><br><span class="line">        serverManager.receiveHeartBeat(srvinfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在KernelServerManager中有一个接收KernelServer心跳的函数，用来判断KernelServer是否在线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveHeartBeat</span><span class="params">(ServerInfo srvinfo)</span> <span class="keyword">throws</span> KernelServerNotFoundException </span>&#123;</span><br><span class="line">        InetSocketAddress host = srvinfo.getHost();</span><br><span class="line">        String region = srvinfo.getRegion();</span><br><span class="line">        logger.fine(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">"Received HeartBeat from kernel server: %s in region %s"</span>, host, region));</span><br><span class="line"></span><br><span class="line">        KernelServerInfo kernelServerInfo = servers.get(host);</span><br><span class="line">        <span class="keyword">if</span> (kernelServerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            kernelServerInfo.heartBeatTimer.reset();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String message = String.format(<span class="string">"Kernel server: %s do not exist in region %s"</span>, host, region);</span><br><span class="line">        logger.severe(message);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KernelServerNotFoundException(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DK上下线处理"><a href="#DK上下线处理" class="headerlink" title="DK上下线处理"></a>DK上下线处理</h2><p>上线处理：</p><p>OMSServer中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKernelServer</span><span class="params">(ServerInfo info)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">    serverManager.registerKernelServer(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KernelServerManager中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKernelServer</span><span class="params">(ServerInfo info)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">    InetSocketAddress host = info.getHost();</span><br><span class="line">    String region = info.getRegion();</span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(host.getHostName(), host.getPort());</span><br><span class="line">    KernelServer server = (KernelServer) registry.lookup(<span class="string">"io.amino.run.kernelserver"</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;InetSocketAddress&gt; serversInRegion = regions.get(region);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == serversInRegion) &#123;</span><br><span class="line">        serversInRegion = <span class="keyword">new</span> ArrayList&lt;InetSocketAddress&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    serversInRegion.add(host);</span><br><span class="line">    regions.put(info.getRegion(), serversInRegion);</span><br><span class="line">    <span class="keyword">final</span> ServerInfo srvInfo = info;</span><br><span class="line">    ResettableTimer heartBeatTimer =</span><br><span class="line">        <span class="keyword">new</span> ResettableTimer(</span><br><span class="line">        <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">/* If we don't receive a heartbeat from this kernel server, remove it from the map */</span></span><br><span class="line">                stopHeartBeat(srvInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        OMSServer.KS_HEARTBEAT_TIMEOUT);</span><br><span class="line">    heartBeatTimer.start();</span><br><span class="line">    KernelServerInfo oldServer =</span><br><span class="line">        servers.put(host, <span class="keyword">new</span> KernelServerInfo(info, server, heartBeatTimer));</span><br><span class="line">    <span class="keyword">if</span> (oldServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldServer.heartBeatTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(String.format(<span class="string">"Registered new kernel server: %s in region %s"</span>, host, region));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组策略的处理-1"><a href="#组策略的处理-1" class="headerlink" title="组策略的处理"></a>组策略的处理</h2><p>每一个微服务都包含了服务端策略，客户端策略和组策略。策略包含了一系列内部函数。一些事件发生时会被调用的upcall functions和一系列为策略实现的Amino.run的API，upcall函数会被调用使用了一个DefaultPolicy类来实现。</p><h2 id="服务注册流程（服务端）"><a href="#服务注册流程（服务端）" class="headerlink" title="服务注册流程（服务端）"></a>服务注册流程（服务端）</h2><p><img src="/2019/07/23/Amino/J:/hexo\source\_posts\Amino\4.png" alt="4"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Registry(注册表)是放置所有服务器对象的命名空间。</span><br><span class="line">每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。</span><br><span class="line">这些是使用称为绑定名称的唯一名称注册的。</span><br><span class="line"></span><br><span class="line">要调用远程对象，客户端需要该对象的引用,如(HelloRegistryFacade)。</span><br><span class="line">即通过服务端绑定的名称(HelloRegistry)从注册表中获取对象(lookup()方法)。</span><br></pre></td></tr></table></figure><p>Amino.Run使用RMI注册来发现远程对象。 以下代码段显示了如何注册远程对象io.amino.run.oms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OMSServerImpl oms = <span class="keyword">new</span> OMSServerImpl(args[<span class="number">2</span>]);   <span class="comment">//定义一个oms服务器</span></span><br><span class="line"><span class="comment">// 创建一个远程对象存根</span></span><br><span class="line">sapphire.oms.OMSServer omsStub = (sapphire.oms.OMSServer)UnicastRemoteObject.exportObject(oms, <span class="number">0</span>);  <span class="comment">//定义存根</span></span><br><span class="line"><span class="comment">// 本地主机上的远程对象注册表Registry的实例</span></span><br><span class="line">Registry registry = LocateRegistry.createRegistry(port);  </span><br><span class="line"><span class="comment">// 把远程对象omsStub-OMS服务器存根注册到RMI注册服务器上，并命名为io.amino.run.oms</span></span><br><span class="line">registry.rebind(<span class="string">"io.amino.run.oms"</span>, omsStub);</span><br></pre></td></tr></table></figure><h2 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h2><p>Client side 按名称查找remote object <code>OMSServer</code>，即io.amino.run.oms，RMI注册返回OMSServer的存根。  Client 然后使用OMS服务器查找Amino Run。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找 io.amino.run.oms</span></span><br><span class="line">registry = LocateRegistry.getRegistry(args[<span class="number">0</span>],Integer.parseInt(args[<span class="number">1</span>]));</span><br><span class="line">OMSServer server = (OMSServer) registry.lookup(<span class="string">"io.amino.run.oms"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从OMS Server中寻找Microservice</span></span><br><span class="line">TwitterManager tm = (TwitterManager) server.getAppEntryPoint();</span><br><span class="line">System.out.println(<span class="string">"Received Twitter Manager Stub: "</span> + tm);</span><br></pre></td></tr></table></figure><h1 id="DK模块分析"><a href="#DK模块分析" class="headerlink" title="DK模块分析"></a>DK模块分析</h1><h1 id="关于几个组件"><a href="#关于几个组件" class="headerlink" title="关于几个组件"></a>关于几个组件</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p><img src="/2019/07/23/Amino/J:/hexo\source\_posts\Amino\2.png" alt="2"><img src="/2019/07/23/Amino/J:/hexo\source\_posts\Amino\3.png" alt="3"></p><p>微服务是Amino的基础管理单元。 在上图中，每个圆圈代表一个微服务。 圆内（即微服务）的点表示普通编程语言（例如Java）对象。 一个微服务可能包含一组这样的对象。 点之间的实线箭头线是对象之间的本地方法调用。 圆圈之间的虚线箭头线是微服务之间的远程方法调用。 普通Java对象上的方法只能由驻留在同一主机上的对象在本地调用。 但是，微服务可以具有远程方法，这些方法可以由驻留在不同主机上的对象调用。</p><h2 id="DK"><a href="#DK" class="headerlink" title="DK"></a>DK</h2><p>Deployment Kernel（DK）具有将微服务从一台主机移动到另一台主机的能力。在后台，Deployment Kernel（DK）将<strong>序列化整个微服务</strong>，包括属于微服务的所有编程语言对象，一端将数据发送到目标主机，然后在那里<strong>进行反序列化。</strong></p><p>微服务由应用程序使用静态方法Microservice.new_（）创建。 要在微服务上调用方法，应用程序必须首先从OMS服务器获取对微服务的引用。</p><p><strong>多个Kernel Server组成了DK？？？</strong></p><h2 id="OMS"><a href="#OMS" class="headerlink" title="OMS"></a>OMS</h2><p>跟踪所有微服务的位置。 与可以使用Java new关键字创建的普通（例如Java）对象不同，必须使用特殊的Amino.Run辅助方法’Microservice.new_（）’创建微服务。 在创建微服务时，<strong>MicroService.new_（）</strong>方法将为微服务生成全局唯一ID，并在OMS中注册该对象。 OMS提供搜索Amino Run的API。 给定微服务ID，OMS可以告知微服务运行的主机的IP。 每当移动或删除微服务时，OMS将相应地更新。</p><h2 id="Kernel-Server"><a href="#Kernel-Server" class="headerlink" title="Kernel Server"></a>Kernel Server</h2><p>Kernel Server为Amino Run提供运行时环境。 每个主机都运行一个Kernel Server实例。 Kernel Server公开了一组可以远程调用的远程API。 Amino.Run假设任何Kernel Server都可以在任何其他Kernel Server上调用远程API，无论Kernel Server在哪里。</p><p>Kernel Server是DK的实例化对象？？？</p><h2 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h2><p>有三个组件：代理proxy，实例管理器 a instance manager和协调器coordinator。 当用户创建微服务时，用户可以选择将DM与微服务相关联。 并非所有微服务都有DM。 但是如果为微服务指定了DM，那么在创建微服务期间，辅助方法MicroService.new_（）会将代码注入到微服务的存根中，在这种情况下，微服务上的任何方法调用都将首先由 在到达实际的微服务之前，代理，实例管理器和DM的协调器。 每个DM提供一种特定功能。 Sapphire 论文中列出了26个DM。</p><h2 id="Kernel-Object"><a href="#Kernel-Object" class="headerlink" title="Kernel Object"></a>Kernel Object</h2><p>Kernel Object是实际（例如Java）对象object的包装器 - 它包含对实际对象的引用，并公开一个invoke方法，该方法允许使用反射调用在实际对象上定义的任何公共方法。</p><p>使用KernelServerImpl.newKernelObject方法创建Kernel Object。 每个Kernel Object都有一个唯一的oid，并在OMS服务器中注册。 KernelServer接口还公开了一些API来复制和移动内核对象。</p><h2 id="Kernel-Server和OMS-server的关系"><a href="#Kernel-Server和OMS-server的关系" class="headerlink" title="Kernel Server和OMS server的关系"></a>Kernel Server和OMS server的关系</h2><p>KernelServer和OMSServer是Amino.Run中的两个重要对象。 两者都暴露远程接口。 OMSServer包含一个KernelObjectManager，它跟踪Kernel ObjectID与运行该对象的Kernel Server的IP地址之间的映射。 给定Kernel Object的ID，Client可以调用OMSServer来获取运行对象的主机的IP。</p><p><img src="/2019/07/23/Amino/J:/hexo\source\_posts\Amino\5.png" alt="5"></p><p>KernelServer包含一个ObjectManager，它跟踪Kernel Object的ID与Kernel Object引用之间的映射。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/07/22/Docker/"/>
      <url>/2019/07/22/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>容器意味着环境隔离和可重复性。开发人员只需为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。另外，容器环境与所在的 Host 环境是隔离的，就像虚拟机一样，但更快更简单</p><p>只需要配置好标准的 runtime 环境，服务器就可以运行任何容器。这使得运维人员的工作变得更高效，一致和可重复。<strong>容器消除了开发、测试、生产环境的不一致性</strong></p><p><strong>说到容器，我们一般都会提及虚拟机，两者都同样都提供了封装和隔离，二者的区别在于</strong></p><p><strong>- 容器仅仅包含应用程序本身以及相关的依赖</strong></p><p><strong>- 虚拟机还需要包含操作系统</strong></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><strong>docker包含了三大部分，它是一个C/S架构的软件</strong></p><p><strong>包含了docker的命令行工具（客户端）</strong></p><p><strong>docker daemon（服务端）</strong></p><p><strong>和docker的仓库</strong></p><p><strong>我们通过docker build命令来构建一个镜像</strong></p><p><strong>通过pull命令来从仓库中拉取一个镜像</strong></p><p><strong>通过run命令来从镜像运行一个容器</strong></p><p>镜像=类</p><p>容器=对象</p><p>通过一个new方法来从类（模板）创建出对象（运行态）</p><p>通过一个run命令来从镜像创建一个容器</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p><a href="https://unix.stackexchange.com/questions/363048/unable-to-locate-package-docker-ce-on-a-64bit-ubuntu/406952" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/363048/unable-to-locate-package-docker-ce-on-a-64bit-ubuntu/406952</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Leetcode-HOT100题解</title>
      <link href="/2019/07/10/Leetcode-HOT100%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/07/10/Leetcode-HOT100%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R=height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=min(height[L],height[R])*(R-L);</span><br><span class="line">            ans=max(ans,temp);</span><br><span class="line">            <span class="keyword">if</span>(height[L]&lt;height[R])</span><br><span class="line">                L++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++面向对象</title>
      <link href="/2019/07/09/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/07/09/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="类中的访问属性"><a href="#类中的访问属性" class="headerlink" title="类中的访问属性"></a>类中的访问属性</h2><p>如果是声明为public，类内，派生类内，类外都可以访问。</p><p>如果声明为private，类内可以访问，派生类内和类外不可以访问。</p><p>如果声明为protected，类内和派生类内可以访问，类外不可以访问。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或者引用来访问基类和派生类中的同名函数。</p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数返回值类型 函数名（参数列表）=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>凡是包含了纯虚函数的类都是抽象类，因为纯虚函数是不能够被调用的，包含纯虚函数的类无法建立对象。抽象类的作用是作为一个类族的共同基类，或者是说为每一个类族提供一个公共的接口。</p><h2 id="C-的接口类"><a href="#C-的接口类" class="headerlink" title="C++的接口类"></a>C++的接口类</h2><p>C++的接口类应该使用抽象类，使用纯虚函数。变量使用静态变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ISHAPE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISHAPE_H</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IShape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MIN_AREA;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ISHAPE_H</span></span></span><br></pre></td></tr></table></figure><h2 id="char-和string的转换"><a href="#char-和string的转换" class="headerlink" title="char[]和string的转换"></a>char[]和string的转换</h2><h1 id="函数参数记得写引用！！！"><a href="#函数参数记得写引用！！！" class="headerlink" title="函数参数记得写引用！！！"></a>函数参数记得写引用！！！</h1><p>函数参数写引用，函数内部将&amp;引用推入vector。</p><p>并且vector里面应该存指针！！！</p><h2 id="类的函数声明之后记得要写实现！！！"><a href="#类的函数声明之后记得要写实现！！！" class="headerlink" title="类的函数声明之后记得要写实现！！！"></a>类的函数声明之后记得要写实现！！！</h2><p>不然会报错的！！！</p><h2 id="字符和数字的互相转换"><a href="#字符和数字的互相转换" class="headerlink" title="字符和数字的互相转换"></a>字符和数字的互相转换</h2><p>如果不支持to_string().</p><p>那我们就用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>]=<span class="string">"123"</span>;<span class="comment">//string a="123"</span></span><br><span class="line"><span class="keyword">int</span> num_a;</span><br><span class="line"><span class="built_in">sscanf</span>(a,<span class="string">"%d"</span>,&amp;num_a);   <span class="comment">//字符转数字</span></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> num_b=<span class="number">100</span>; </span><br><span class="line"><span class="built_in">sprintf</span>(b,<span class="string">"%d"</span>,num_b);   <span class="comment">//数字写字符数组</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(num_b)</span></span>;  <span class="comment">//字符数组转string</span></span><br><span class="line"><span class="built_in">string</span> str=num_b;   <span class="comment">//字符数组转string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/06/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/06/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h3><p>一个分布式系统是由多个通过网络互联的<strong>独立自治的计算节点</strong>组成，这些计算节点为了完成共同目标基于消息传递机制进行相互协作。</p><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p><strong>多个计算节点：节点可以是进程、线程、抽象对象、组件、服务、单个计算机或一组计算机（图灵机）</strong><br>网络互联：逻辑拓扑上一般认为是全连接网络<br>独立自治：独立CPU、独立时钟、并发、独立错误<br>完成共同目标<br>相互协作<br>消息传递：消息传递模型，并非内存共享模型</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>分布式系统架构（5种）<br>客户端-服务器(Client-Server)模式，主-从(Master-Slave)模式，总线模式，对等(Peer-to-Peer)模式，混合模式</p><p>客户端-服务器(Client-Server)模式:</p><p>客户端发出服务请求，服务器端根据客户端请求参数完成实际运算，并将运算结果返回给客户端。<br>客户端运算任务清，服务器端运算任务重。<br>客户端生命周期短，服务器端生命周期长。<br>服务器端一般要应对并发问题。<br>客户端一般负责和用户进行交互。</p><p>瘦客户端/胖客户端(是否有大量的业务逻辑需要放在客户端)</p><p>主-从(Master-Slave)模式:</p><p>主节点（Master）负责将总计算任务分解为多个子任务分发给各个从节点（Slave，也叫Worker节点）完成主节点监视各个从节点的任务执行情况，将执行失败的任务调度给其它的从节点完成主节点在分配任务是会参考各个从节点的当前负载情况。</p><p>总线结构：</p><p>不同节点之间通过虚拟总线相连 消息发送者不必知道接收者是谁，接收者也不知道发送者是谁</p><p>发送者和接收者之间用异步方式通信  一种松耦合架构 不同节点完成不同功能，分工协作</p><p>对等(Peer-to-Peer)模式:</p><p>系统中每个计算节点在任务分工上是完全对等的。</p><p>完全相同的软件在不同的计算机上运行，只是初始化参数不同</p><p>结构化P2P：不同节点之间的交互模式遵循固定规律</p><p>非结构化P2P：不同节点之间的交互模式没有固定规律</p><p>1.3 服务器为集群时，划分为几层？为什么划分？各层功能是什么？好处有哪些？</p><p>随着企业信息的不断扩大，企业级应用不再满足于简单的两层系统，而是向着三层和多层体系结构发展。分层主要是为重用和便于管理 ，能够很好的适应需求的变化。</p><p>划分为三层：表示层 应用层 数据层</p><p>功能：</p><p>表现层：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。<br>应用层：又叫逻辑层，针对具体问题的操作，把复杂的业务关系细分为多项功能单一的服务，每项服务都执行一项特殊任务，这些服务可以用相对独立的服务组件来实现其功能。通过分布这些组件，可以平衡数据处理负载，协调逻辑关系，调整业务规模和业务规则。<br>数据层：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。</p><p>好处：</p><p>专注：开发人员可以只关注整个结构中的其中某一层；<br>可以很容易的用新的实现来替换原有层次的实现；<br>可以降低层与层之间的依赖；<br>有利于标准化；<br>利于各层逻辑的复用。<br>扩展性强。不同层负责不同的层面，接口定义好之后各个层不会相互影响。<br>安全性高。用户端只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。<br>项目结构更清楚，分工更明确，有利于后期的维护和升级</p><p>服务器为集群时，使用了什么关键技术？实现该技术有哪些策略？</p><p>负载均衡技术：负载均衡服务器，就是用来把经过它的流量，按照某种方法，分配到集群中的各台服务器上。这样一来不仅可以承担更大的流量、降低服务的延迟，还可以避免单点故障造成服务不可用。</p><p>策略（7种）：</p><p><strong>随机</strong>：随机选择后端服务器<br><strong>轮询</strong>：根据分布式系统配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器。<br><strong>固定权重值</strong>：把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。<br><strong>IP哈希</strong>（基于一致性随机散列函数）：使用基于IP地址哈希的负载均衡方案，同一客户端连续的Web请求都会被分发到同一服务器进行处理。<br><strong>最少TCP连接数</strong>：Web请求会被转发到连接数最少的服务器上。<br><strong>最小响应时间</strong>：连接到到那些通过响应最快之服务器<br><strong>基于各服务器实际负载的动态负载均衡算法</strong></p><p>IP哈希（基于一致性随机散列函数）<br>一致性哈希算法的目标是对于K个请求,节点的上下线只会引起K/nodeTotal的key重新映射,而在节点稳定的时候,同一个key的每次请求映射都是一样的</p><p>一致性哈希算法实现原理：</p><p>把数据通过一定的hash算法处理后映射到环上；将机器通过hash算法映射到环上，以顺时针的方向计算，将所有对象存储到离自己最近的机器中。</p><p>（参考 <a href="https://blog.csdn.net/tingting256/article/details/52497749）" target="_blank" rel="noopener">https://blog.csdn.net/tingting256/article/details/52497749）</a></p><p>一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><p>中间件（考点偏理解）<br>定义：</p><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。位于操作系统，计算机网络硬件等平台和应用层之间，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p><p>常用中间件有哪些：</p><p>远程过程调用中间件<br>分布式对象中间件<br>分布式组件中间件<br>消息队列中间件<br>Web服务中间件<br>P2P中间件</p><p>中间件的作用:</p><p>为开发者提供高层的编程抽象，屏蔽分布式系统底层的异构性和复杂性<br>提高交互操作性和可移植性<br>提供分布式系统的基础设施服务</p><p>第二讲 分布式节点之间的通信技术</p><p>2.1 Socket</p><p>定义：</p><p>传输层和网络层提供给应用层的标准化编程接口（或称为编程接口）</p><p>类型：</p><p>流式套接字(面向连接)  数据报套接字(面向无连接)  原始套接字</p><p>2.2 并发服务技术  适用场景</p><p>单机</p><p>基于多进程的并发服务技术（适合小数据量传送、弱相关的处理 ）<br>优点：每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；可以尽量减少线程加锁/解锁的影响，极大提高性能</p><p>缺点：逻辑控制复杂，需要和主程序交互；多进程调度开销比较大；</p><p>基于多线程的并发服务技术（需要频繁创建销毁 需要进行大量计算 强相关的处理）<br>优点：无需跨进程边界；程序逻辑和控制方式简单；所有线程可以直接共享内存和变量等；线程方式消耗的总资源比进程方式好。<br>缺点：线程之间的同步和加锁控制比较麻烦；一个线程的崩溃可能影响到整个程序的稳定性；进程切换和创建清楚耗时</p><p>基于线程池的并发服务技术：解决了线程创建销毁的问题 适用高并发、任务执行时间短的业务<br>事件驱动技术（多路复用技术）：解决了线程切换的问题 适合大量短事务</p><p>多机</p><p>负载均衡技术<br>适用：负载均衡适用于高访问量的业务，提高应用程序的可用性和可靠性。</p><p>2.3 远程过程调用(Remote Method Invocation, RMI)</p><p>定义：</p><p>使应用程序可以像调用本地节点上的过程(子程序) 那样去调用一个远程节点上的子程序。</p><p>实现：</p><p>RPC/RMI中间件在调用者进程中植入stub模块，stub模块作为远程过程的本地代理，并且暴露与远程过程相同的接口。<br>RPC/RMI中间件在被调用者进程中植入skeleton模块， skeleton作为调用者在远程主机中的代理。<br>stub模块与skeleton模块利用Socket进行通信。<br>skeleton模块相当于Client-Server通信模式中的服务器端，要先于客户端运行，并且在某个Socket端口进行监听。<br>具体见PPT 22页-31页 及其底下备注解释</p><p>四个核心组件：</p><p>分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。</p><p>客户端(Client)，服务的调用方。</p><p>客户端存根(Client Stub proxy)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过OS网络远程发送给服务方。(TCP/UDP)</p><p>服务端(Server)，真正的服务提供者。</p><p>服务端存根(Server Stub skeleton)，接收客户端发送过来的消息，将消息解包，并分发rpc请求调用本地的方法。</p><p>RPC 调用过程：</p><p>（参考 <a href="https://www.cnblogs.com/swordfall/p/8683905.html）" target="_blank" rel="noopener">https://www.cnblogs.com/swordfall/p/8683905.html）</a></p><p>(1) 客户端（client）以本地调用方式（即以接口的方式）调用服务；</p><p>(2) 客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；</p><p>(3) 客户端通过sockets将消息发送到服务端；</p><p>(4) 服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；</p><p>(5) 服务端存根( server stub）根据解码结果调用本地的服务；</p><p>(6) 本地服务执行并将结果返回给服务端存根( server stub）；</p><p>(7) 服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；</p><p>(8) 服务端（server）通过sockets将消息发送到客户端；</p><p>(9) 客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；</p><p>(10) 客户端（client）得到最终结果。</p><p>2.4 面向消息中间件（MOM: Message Oriented Middleware）</p><p>定义：</p><p>提供了一种分布式消息队列服务，使得节点之间可以实现基于消息的形式灵活的异步通信。</p><p>异步的含义：发送方可以在任意时刻发出消息，不必等待接收方上线，更不必等待消息发送成功再做下一步工作；接收方不必以阻塞方式等待消息的到来。</p><p>基于MOM实现通信的优点:</p><p>异步通信，可以减少系统响应时间，提高吞吐量<br>分布式节点之间的解耦<br>保证消息的可靠递交，实现最终一致性<br>实现广播、组播和多对多通信<br>流量削峰和流控<br>支持Push模型和Pull模型</p><p>2.5 Web Service技术（一种特殊的RPC技术）</p><p>定义：</p><p>为方便网络上不同节点之间互操作而定义的一套协议标准， 也可视为实现远程过程调用的一套协议标准。</p><p>Web Service主要包含哪些标准协议？</p><p>消息编码标准(XML)<br>传输协议标准(HTTP、SMTP、TCP、UDP)<br>远程对象访问协议（即远程方法调用协议）：SOAP(Simple Object Access Protocol):<br>Web服务描述语言：WSDL(Web Services Description Language)  （主要描述服务接口定义）<br>服务目录、服务注册、服务发现：UDDI(Universal Discovery Description and Integration)<br>安全相关标准：签名、加密、认证等<br>服务组合、服务编排</p><p>理解WSDL SOA UDDI HTTP XML等作用：</p><p>通过XML 来实现消息描述，然后再通过 HTTP 实现消息传输。<br>SOAP 是远程对象访问协议。SOAP是一种简单的、轻量级的基于XML 的机制，用于在网络应用程序之间进行结构化数据交换。SOAP包括三部分:一个定义描述消息内容的框架的信封，一组表示应用程序定义的数据类型实例的编码规则，以及表示远程过程调用和响应的约定<br>WSDL表示服务描述语言。WSDL文件是一个XML 文档，用于说明一组SOAP消息以及如何交换这些消息。<br>UDDI(统一描述发现和集成) 提供一种发布和查找服务描述的方法。UDDI 数据实体提供对定义业务和服务信息的支持。WSDL 中定义的服务描述信息是UDDI注册中心信息的补充。<br>（参考 <a href="https://blog.csdn.net/zouyousu/article/details/83567545）" target="_blank" rel="noopener">https://blog.csdn.net/zouyousu/article/details/83567545）</a></p><p>看看代码：</p><p>第三讲 分布式文件系统</p><p>3.1 分布式文件系统</p><p>定义：</p><p>分布式文件系统：将分布式系统中多个节点的存储资源整合在一起，向用户/应用程序呈现统一的存储空间和文件系统目录树。用户无需关心数据存储在哪个节点上。大文件被自动分块并分别存储到不同的节点上。</p><p>作用：</p><p>在用户看来就是一个大型的目录树。</p><p>安全机制：对读写文件有权限控制措施</p><p>可扩展性：支持通过增加节点扩充存储容量</p><p>高吞吐率：多副本可以提高数据吞吐率</p><p>解决了大容量存储和负载均衡的问题。</p><p>工作原理：</p><p>客户端向NameNode发出写文件请求。<br>检查是否已存在文件、检查权限。若通过检查，直接先将操作写入EditLog，并返回输出流对象。<br>client端按128MB的块切分文件。<br>client将NameNode返回的分配的可写的DataNode列表和Data数据一同发送给最近的第一个DataNode节点，此后client端和NameNode分配的多个DataNode构成pipeline管道，client端向输出流对象中写数据。client每向第一个DataNode写入一个packet，这个packet便会直接在pipeline里传给第二个、第三个…DataNode。<br>每个DataNode写完一个块后，会返回确认信息。<br>写完数据，关闭输输出流。<br>发送完成信号给NameNode。</p><p>Namenode 节点流程及作用：</p><p>namenode是整个文件系统的管理节点。它维护着1.整个文件系统的文件目录树，2.文件/目录的元信息和每个文件对应的数据块列表。3.接收用户的操作请求。</p><p> namenode包含两个文件：FsImage(元数据镜像文件。存储某一时段NameNode内存元数据信息)和Editlog(操作日志文件）<br>NameNode维护着2张表：</p><p>1文件与数据块（block）列表的对应关系<br>2数据块与被存储的结点的关系。</p><p>DataNode：负责存储client发来的数据块block；执行数据块的读写操作；使用多备份策略。</p><p>第四讲 MapReduce模型和分布式计算框架</p><p>4.1 Mapreduce 设计算法即可，写伪代码，描述清楚</p><p>Map阶段：第一阶段并行，将输入文件划分成多个分区，每个分区都交给一个独立的Map子任务进行处理。强制要求每个Map子任务将输出规整为一系列&lt;key, value&gt;对的形式。<br>聚集混洗阶段：并不同Map子任务输出的&lt;key, value&gt;数组按照key进行聚集，聚集成数组 A = {&lt;k1, [v1, v2, …]&gt;,   &lt;k2, [v3, v4, …]&gt;, &lt;k3, [v5, v6, …]&gt;, …}的形式。（按key排序）<br>Reduce阶段：第二阶段并行，将聚集之后的数组A划分成多个分区，每个分区都交给一个独立的Reduce子任务进行处理。 Reduce子任务也将输出规整为一系列&lt;key, value&gt;对的形式。<br>如果Reduce阶段输出不是最终结果，还可以启动新一轮MapReduce过程。</p><p>4.2 样例设计：</p><p>单词计数统计</p><p>在网页数据库中统计不同网页被引用的频率。<br>map函数处理网页请求的日志文件，并输出&lt;URL, 1&gt;的键值对。reduce函数把相同URL访问次数值相加到一起，输出&lt;URL, 总访问数&gt;的键值对。</p><p>根据网页数据库生成关于每个网页的逆向链接统计。（&lt;target, list(source)&gt;）<br>map函数把source网页中每一个链接到target URL的结果输出为&lt;target, source&gt;。reduce函数把所有和给定target相关的source URLs连接起来，并且输出&lt;target, list(source)&gt;。举个例子，搜索引擎中输入关键字，网络爬虫就会根据关键字(target)查找相关的网页并找到所有的链接，这些就是list(source)。</p><p>生成关于网页数据库的全文检索索引（倒排索引）。<br>(1)这里存在两个问题：第一，&lt;key,value&gt;对只能有两个值，在不使用Hadoop自定义数据类型的情况下，需要根据情况将其中两个值合并成一个值，作为key或value值；第二，通过一个Reduce过程无法同时完成词频统计和生成文档列表，所以必须增加一个Combine过程完成词频统计。</p><p>(2)这里讲单词和URL组成key值（如”MapReduce：file1.txt”），将词频作为value，这样做的好处是可以利用MapReduce框架自带的Map端排序，将同一文档的相同单词的词频组成列表，传递给Combine过程，实现类似于WordCount的功能。</p><p>(3)Combine过程：经过map方法处理后，Combine过程将key值相同的value值累加，得到一个单词在文档在文档中的词频，如果直接输出作为Reduce过程的输入，在Shuffle过程时将面临一个问题：所有具有相同单词的记录（由单词、URL和词频组成）应该交由同一个Reducer处理，但当前的key值无法保证这一点，所以必须修改key值和value值。这次将单词作为key值，URL和词频组成value值（如”file1.txt：1”）。这样做的好处是可以利用MapReduce框架默认的HashPartitioner类完成Shuffle过程，将相同单词的所有记录发送给同一个Reducer进行处理。</p><p>海量数据的全文查找或关键字匹配</p><p>数据过滤<br>数据去重</p><p>数值数组计算总和、平均值、最大最小值、TopN<br>计算数字图像直方图<br>海量数据的随机采样</p><p>给出child-parent数据表，要求输出grandchild-grandparent数据集表</p><p>第五讲 时钟和分布式共识</p><p>5.1 抽象模型（理解）</p><p>交互模式</p><p>定义了在算法运行期间哪些节点之间有消息传递动作；<br>定义了通信模式：同步模式、异步模式<br>信道故障模式</p><p>消息是否会丢失<br>消息是否会乱序<br>消息传输延迟的上限<br>节点故障模式</p><p>失效停止模式<br>失效停止重启模式<br>拜占庭(Byzantine)模式</p><p>5.2 同步交互与异步交互比较</p><p>同步交互模式</p><p>节点间的交互按周期进行，每个周期包含一次消息发送、和消息接收过程<br>隐含地对节点物理时钟的同步、消息传输最大延迟、消息最大处理时间做了假设。<br>异步交互模式</p><p>节点可以在任意时刻发送消息，也可以在任意时刻接收消息。<br>对消息传输延迟和消息处理时间没有任何假设</p><p>5.3 失效停止模式和拜占庭模式区别</p><p>失效停止模式(Fail-Stop Failure or Crash Failure)</p><p>节点一旦发生故障就停止工作，故障期间不发送任何消息<br>有的分布式协议也允许节点崩溃后可以重新启动，再次上线。此时节点崩溃之前内存中的状态全部消失，但持久化到非易失存储器中的状态还可以恢复。<br>拜占庭模式(Byzantine Failure)</p><p>节点一旦发生故障就有可能做出任意动作，例如发送非协议规定的错误消息，甚至故意扰乱分布式系统的消息。<br>网络安全系统设计多采用拜占庭模式，此时认为节点完全被黑客控制了。<br>一些安全系数要求极高的分布式系统设计中，也采用拜占庭模式。</p><p>5.4 物理时钟</p><p>实现方法：</p><p>方法一：每个节点都定期地与世界标准时间(UTC: Coordinated Universal Time )同步</p><p>缺点：（1）成本高；（2）大部分计算机都放在室内，接收不到UTC</p><p>方法二：每个节点定期地通过网络与时间服务器同步</p><p>缺点：时间服务器配备了GPS接收器。需要考虑传输延时</p><p>Cristian时间同步算法（重要）</p><p>给出T1-T4计算或者推导公式：</p><p>5.5 逻辑时钟</p><p>思想：</p><p>分布式系统中很多问题的关键在于不同的节点对多个事件的发生顺序达成一致就可以，并且达成的顺序不能破坏因果关系。<br>Lamport提出的逻辑时钟概念就是为了解决分布式系统中事件的时序问题，并且能够保证如果事件a导致事件b（记为：a➔b，表示a是b的潜在原因），则一定有C(a)&lt;C(b)。（C(a)为事件a发生的逻辑时间戳， C(b)为事件b发生的逻辑时间戳）</p><p>系统内任意的两个消息a、b都可以基于时间戳&lt;C(a), ID(a)&gt;、 &lt;C(b), ID(b)&gt;比较先后，<br>规则为：a先于b 当且仅当：C(a) &lt; C(b) or C(a)=C(b) and ID(a)&gt;ID(b)</p><p>有了消息比较先后的规则，分布式系统内所有消息都可以进行统一排序。<br>该排序的性质：保持了潜在因果关系：a导致b，则一定有C(a)&lt;C(b)<br>但反过来不成立！因为可能a,b是不相关的。</p><p>节点维护逻辑时钟的算法</p><p>每个节点维护一个不断增加的整数作为本地逻辑时钟<br>节点内事件的发生（消息产生、消息发送、消息接收都是事件）会触发逻辑时钟的增长<br>节点 i 发出的每个消息都绑定一个二元组：<br>&lt;本地逻辑时钟Ci，节点ID号i&gt;</p><p>每发生一个新事件就让本地逻辑时钟Ci加1<br>假定节点j接收到一个消息m，其时间戳为&lt;Ci, i&gt;, 则节点j将自己的逻辑时间调整为：<br>Cj 1 + max{ Cj,  Ci }</p><p>5.6 分布式共识协议</p><p>介绍：</p><p>分布式系统由n个节点构成，其中最多有f个故障节点。每个节点Pi 都有自己的提案xi。这些节点之间通过运行“分布式共识协议”以达成一致的决策。</p><p>必须满足如下条件：</p><p>终止性：在有限时间内总能达成一致的决策。</p><p>共识性: 不同节点最终决策的结果是相同的。</p><p>合法性：决策的结果必须等于某个进程提出的提案。</p><p>用分布式共识协议解决多数据库镜像一致性问题？</p><p>答：客户端向所有数据库服务器都发送Update消息，然后在服务器之间运行“分布式共识协议”就多个客户端Update消息的消息内容和先后顺序问题达成一致。</p><p>同步模型下的分布式共识协议</p><p>初始化：假定每个节点的提案都是自然数。每个节点Pi 定义提案集合Si={xi}</p><p>协议：每个节点按周期运行如下逻辑，共运行f+1个周期：</p><p>（1）将自己的集合Si中的尚未广播过的值广播给其他所有节点；</p><p>（2）从其他节点接收到的提案值都放入集合Si（去掉重复的值）。</p><p>结束处理：</p><p>f+1个周期后，每个节点都取集合Si中最大（或最小）的值作为最终提案。</p><p>定理：按照以上协议运行结束后，每个节点获得的集合Si是相同的。</p><p>异步模型下的分布式共识协议</p><h2 id="FLP定理：在异步通信模型下，只要有一个节点失效（失效停止模式，或拜占庭模式），就无法达成共识。"><a href="#FLP定理：在异步通信模型下，只要有一个节点失效（失效停止模式，或拜占庭模式），就无法达成共识。" class="headerlink" title="FLP定理：在异步通信模型下，只要有一个节点失效（失效停止模式，或拜占庭模式），就无法达成共识。"></a>FLP定理：在异步通信模型下，只要有一个节点失效（失效停止模式，或拜占庭模式），就无法达成共识。</h2><p>作者：larry6799<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/larry1648637120/article/details/93523269" target="_blank" rel="noopener">https://blog.csdn.net/larry1648637120/article/details/93523269</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>二分写法2</title>
      <link href="/2019/06/18/%E4%BA%8C%E5%88%86%E5%86%99%E6%B3%952/"/>
      <url>/2019/06/18/%E4%BA%8C%E5%88%86%E5%86%99%E6%B3%952/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索是真的牛逼！"><a href="#二分搜索是真的牛逼！" class="headerlink" title="二分搜索是真的牛逼！"></a>二分搜索是真的牛逼！</h1><h2 id="找到某一个数"><a href="#找到某一个数" class="headerlink" title="找到某一个数"></a>找到某一个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/06/17/Untitled/"/>
      <url>/2019/06/17/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/05/16/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/16/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title=".  自我介绍"></a>.  自我介绍</h1><p>xx老师：</p><p>​    你好！我叫黄裕涛，来自重庆大学软件学院，我本科专业是软件工程。我目前的年级排名是在学院的前百分之9。</p><p>​    我在大二的时候参加过微软创新杯的比赛获得了全国三等奖，当时我们做的应用是一个基于微软混合虚拟眼镜的笔记助手应用，主要功能是用户带上这个头戴式设备之后，在上课或者会议期间遇到需要记录的文字，能够用手指轻轻一点就能够记录下自己想要的内容，并且会同步到用户的个人笔记应用上面，例如OneNotes。整个项目使用了Unity作为开发的前端，后台是基于一个微软Graph浏览器的通讯框架，前端接受用户的手势输入，把获取到的信息传入后台处理再返回前端。我主要是负责后台的编写，对前台得到的数据进行序列化封装成json格式，然后再将它用http协议发送到云端处理。</p><p>​       在大二下的时候参加了数学建模竞赛，拿到了重庆省二等奖。第一问是求解偏微分方程，当时我们采用的是差分的方法，差分方法的优点在于比较简单，但是只能够求规则区域的数值解，所以我们当时假设每一层介质都是规则的矩形进行求解。第二问和第三问都是在第一问模型的基础上求解一个方程的最优解。第二问我使用的是二次搜索算法，主要思想是：先使用较大步长进行全局搜索，找到近似最优解，在找到的近似最优解附近使用较小步长进行局部搜索以寻找目标函数最优值。第三问使用了模拟退火算法求解空间中的最优解，这是一种基于贪心的算法，它在搜索的过程中引入了随机的因素，算法会以一定的概率接受一个比当前解还要差的解，所以会有可能跳出局部最优解，找到全局最优解。在搜索的过程有两种情况要考虑，如果循环移动的时候会得到更优的解那么就会总是接受这个移动，但是移动之后得到更差的解，就会以一定的概率接受这个移动，但是这个概率会逐渐降低。这个算法执行后期当接受概率接近于0的时候就会退化成普通的爬山法。</p><p>​       在大三上的时候参加了绿色计算大赛拿到了特等奖，这是一个类似与ACM的程序设计大赛，主要分成两个部分，第一部分是程序设计的算法题，第二部分是一道机器学习的题目。当时我们机器学习的题目用的方法主要是逻辑回归的方法解决的。</p><p>Good morning. I am very glad to be here for this interview. </p><p>let me introduce myself. My name is HuangYutao.I come from Chongqing University, Majoring in software engineering in the College of big data and software.Well, I would like to summarize me from 3 aspects.</p><p>First of all, during three years of study, I have achieved excellent results in many courses, especially in Operating System, Computer Network, Data Structure and Algorithms, which laid a good foundation for my future graduate study.</p><p>Second, I have took part in various competitions, which got good grades.For example , in Microsoft’s Image Cup, I have developed a software called ‘Note assistant’ with my classmates, which is based on an application developed on Microsoft’s “Hololens”. If people use this application by putting on Hololens, they can easily take notes during classes and meetings. I am mainly responsible for the background data processing module. And I also enjoy participating in programming contests , which equips me with ability to solve difficults.</p><p>Finally ,I hope to be engaged in the research direction of distributed systems and computing.I will keep reading English literature every day, try to reproduce papers, train my English reading ability and scientific research ability, and strive to publish papers.I also hope that I can get in touch with teachers about practical projects in enterprises, so as to improve my practical working ability.</p><p>OK, that’s all. Thank you very much.</p><p>​       </p><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>聚类算法</title>
      <link href="/2019/05/06/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/06/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h1><h2 id="基于数据场的聚类"><a href="#基于数据场的聚类" class="headerlink" title="基于数据场的聚类"></a>基于数据场的聚类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DFS专题</title>
      <link href="/2019/05/05/DFS%E4%B8%93%E9%A2%98/"/>
      <url>/2019/05/05/DFS%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="排列和组合"><a href="#排列和组合" class="headerlink" title="排列和组合"></a>排列和组合</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;A;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> count,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count==N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;temp[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[i]=<span class="literal">true</span>;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">dfs(count+<span class="number">1</span>,temp);</span><br><span class="line">vis[i]=<span class="literal">false</span>;</span><br><span class="line">temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">A.push_back(i);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;b;</span><br><span class="line">dfs(<span class="number">0</span>,b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h3 id="组合（不考虑顺序）"><a href="#组合（不考虑顺序）" class="headerlink" title="组合（不考虑顺序）"></a>组合（不考虑顺序）</h3><p>有两种写法。</p><p>写法一要注意对比和全排列的区别，剪枝的时候要注意判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> N,r;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp)</span>   <span class="comment">//写法一 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*if(temp.size()&gt;=2&amp;&amp;temp[temp.size()-1]&lt;temp[temp.size()-2])   //精髓，排列和组合的区别所在 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span>(temp.size()==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,temp[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">1</span>;           </span><br><span class="line"><span class="keyword">if</span>(temp.size()!=<span class="number">0</span>)</span><br><span class="line">start=temp[temp.size()<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=N;i++)     <span class="comment">//下一次开始要接着开始！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[i]=<span class="literal">true</span>;</span><br><span class="line">temp.push_back(i);  </span><br><span class="line">dfs(i+<span class="number">1</span>,temp);   <span class="comment">//选当前的i </span></span><br><span class="line">temp.pop_back();</span><br><span class="line">vis[i]=<span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp)</span>   <span class="comment">//写法二 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(temp.size()==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,temp[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(index&gt;N)   <span class="comment">//注意它不能写在最前面！因为如果是不选的情况下index已经大于N了，但实际上temp.size()才刚刚好满足条件会被跳过会有问题 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">temp.push_back(index);</span><br><span class="line">dfs1(index+<span class="number">1</span>,temp);   <span class="comment">//选当前 </span></span><br><span class="line">temp.pop_back();</span><br><span class="line">dfs1(index+<span class="number">1</span>,temp);   <span class="comment">//不选当前 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">A.push_back(i);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;b;</span><br><span class="line">dfs(<span class="number">1</span>,b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈序列统计"><a href="#出栈序列统计" class="headerlink" title="出栈序列统计"></a>出栈序列统计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 2 1</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line"><span class="comment">//1 3 2</span></span><br><span class="line"><span class="comment">//2 1 3</span></span><br><span class="line"><span class="comment">//2 3 1</span></span><br><span class="line"><span class="comment">//3 1 2</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> in,<span class="keyword">int</span> out)</span>   <span class="comment">//in栈内元素，out栈外元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(out==<span class="number">0</span>)<span class="comment">//栈外元素没了，ans++</span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(in==<span class="number">0</span>)<span class="comment">//刚开始的时候必须要进栈一个 </span></span><br><span class="line">dfs(in+<span class="number">1</span>,out<span class="number">-1</span>);      </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">dfs(in+<span class="number">1</span>,out<span class="number">-1</span>);       <span class="comment">//进栈 ，栈内元素+1 ，外元素-1 </span></span><br><span class="line">dfs(in<span class="number">-1</span>,out);<span class="comment">// 出栈，栈内元素 -1，外元素不变 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">dfs(<span class="number">0</span>,n);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS走迷宫（输出所有路径）"><a href="#DFS走迷宫（输出所有路径）" class="headerlink" title="DFS走迷宫（输出所有路径）"></a>DFS走迷宫（输出所有路径）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> G[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> sx,sy,ex,ey;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt;temp)</span>    <span class="comment">//输出路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d,%d)-&gt;"</span>,temp[i].x,temp[i].y);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>,temp[i].x,temp[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt;temp,<span class="keyword">int</span> ix,<span class="keyword">int</span> iy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//printf("%d-%d\n",ix,iy);</span></span><br><span class="line"><span class="keyword">if</span>(ix==ex&amp;&amp;iy==ey)</span><br><span class="line">&#123;</span><br><span class="line">show(temp);</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">node a;</span><br><span class="line">a.x=ix+X[i];</span><br><span class="line">a.y=iy+Y[i];</span><br><span class="line"><span class="keyword">if</span>(a.x&lt;=<span class="number">0</span>||a.x&gt;n||a.y&lt;=<span class="number">0</span>||a.y&gt;m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[a.x][a.y]==<span class="literal">false</span>&amp;&amp;G[a.x][a.y]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[a.x][a.y]=<span class="literal">true</span>;</span><br><span class="line">temp.push_back(a);</span><br><span class="line">dfs(temp,a.x,a.y);</span><br><span class="line">temp.pop_back();</span><br><span class="line">vis[a.x][a.y]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">for(int j=1;j&lt;=m;j++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("%d ",G[i][j]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("\n");</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;</span><br><span class="line"><span class="keyword">if</span>((G[sx][sy]==<span class="number">0</span>)||(G[ex][ey]==<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node start;</span><br><span class="line">start.x=sx,start.y=sy;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;a;</span><br><span class="line">a.push_back(start);</span><br><span class="line">vis[start.x][start.y]=<span class="literal">true</span>;</span><br><span class="line">dfs(a,start.x,start.y);</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓展欧几里得算法</title>
      <link href="/2019/05/03/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/03/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>pku-ACM补题(二分)</title>
      <link href="/2019/04/03/pku-ACM%E8%A1%A5%E9%A2%98/"/>
      <url>/2019/04/03/pku-ACM%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="01-派"><a href="#01-派" class="headerlink" title="01 派"></a>01 派</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="http://poj.org/problem?id=3122" target="_blank" rel="noopener">http://poj.org/problem?id=3122</a> </p><p>left作为左边界，right作为右边界。</p><p>sum为蛋糕总体积，F为总人数。</p><p>从left=0到right=sum/F不停的二分求值。</p><p>因为二分枚举的是浮点数，所以不能够单纯的用平时的left&lt;right去跳出循环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJ 3122</span></span><br><span class="line"><span class="comment">//http://poj.org/problem?id=3122 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">4</span>*<span class="built_in">atan</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="comment">//const int maxn=1005;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,F,T;</span><br><span class="line"><span class="keyword">double</span> cake[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;F;</span><br><span class="line">F++;</span><br><span class="line"><span class="keyword">double</span> maxn=-INF;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">cake[i]=a*a*PI;</span><br><span class="line">sum+=cake[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> right=sum/F;</span><br><span class="line"><span class="keyword">double</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fabs</span>(left-right)&gt;<span class="number">10e-8</span>)</span><br><span class="line">&#123;</span><br><span class="line">mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">res+=(<span class="keyword">int</span>)(cake[i]/mid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(res&gt;=F)</span><br><span class="line">&#123;</span><br><span class="line">left=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-River-Hopscotch"><a href="#02-River-Hopscotch" class="headerlink" title="02 River Hopscotch"></a>02 <strong>River Hopscotch</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p> <a href="http://poj.org/problem?id=3258" target="_blank" rel="noopener">http://poj.org/problem?id=3258</a></p><p>L河岸的距离。</p><p>left=0,right=L.</p><p>二分枚举最长最短距离。</p><p>如果最短距离过大，可以撤掉的石头就会过多。</p><p>如果最小距离过小，可以撤掉的石头就会过小。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://poj.org/problem?id=3258 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L,N,M;</span><br><span class="line">ll s[<span class="number">50005</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;L&gt;&gt;N&gt;&gt;M;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">&#125;</span><br><span class="line">s[N+<span class="number">1</span>]=L;</span><br><span class="line">sort(s,s+N+<span class="number">1</span>);</span><br><span class="line">ll left=<span class="number">0</span>;</span><br><span class="line">ll right=L;</span><br><span class="line">ll mid;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line">mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"mid="&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[start]+mid&gt;=s[i])   <span class="comment">//注意！！！恰好等于的时候也可以拿走 </span></span><br><span class="line">&#123;</span><br><span class="line">res++;  <span class="comment">//可以移走的石头++</span></span><br><span class="line">i++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">start=i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//cout&lt;&lt;"res:"&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(res&gt;M)    <span class="comment">//可以移走的石头太多了，所以证明步伐太大 </span></span><br><span class="line">&#123;</span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//res&lt;=M  可以移走的石头太少了，步伐太小 </span></span><br><span class="line">&#123;</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;left&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="13-切割回文"><a href="#13-切割回文" class="headerlink" title="13:切割回文"></a>13:切割回文</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>区间DP。至于为什么是叫做区间DP，我也不懂。。。</p><p>用一个一维dp数组。dp[i]表示如果前i个字符串要把它全部切割成回文子串最少需要多少刀。</p><p>可以用二重循环枚举以第i结尾，第j个开头是不是回文串。</p><p>（1）如果不是回文串，那么dp[i]=dp[i-1]+1. (表示在上一个的基础上多切一刀)。</p><p>（2）如果是回文串，那么要比较dp[j-1]+1和dp[i]的最小值。（因为是以j开头的回文串，所以要比较第j-1个最小需要切多少刀）。注意！如果j=1的话，表示从第一个字符到第i个字符结尾整个都是回文串，所以就可以直接令dp[i]=0表示不用切就是一个回文串！</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>初始化的时候：注意初始化dp[i]为正无穷 ，这样枚举到单一字符的时候才相当于dp1[i]=dp1[i-1]+1 。</p><p>这里判断是不是回文串可以用dp的方式，也可以直接头尾直接判断。具体看代码。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp1[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">fill(dp[<span class="number">0</span>],dp[<span class="number">0</span>]+<span class="number">1005</span>*<span class="number">1005</span>,<span class="number">0</span>);</span><br><span class="line">fill(dp1,dp1+<span class="number">1005</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>&lt;=len&amp;&amp;str[i]==str[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i+<span class="number">1</span>]=dp[i+<span class="number">1</span>][i]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">3</span>;L&lt;=len;L++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len-L+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(str[i]==str[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=L;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp1[i]=INF;               <span class="comment">//注意初始化为正无穷 ，这样枚举到单一字符的时候才相当于dp1[i]=dp1[i-1]+1 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[j][i]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">1</span>)</span><br><span class="line">dp1[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp1[i]=min(dp1[j<span class="number">-1</span>]+<span class="number">1</span>,dp1[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp1[len]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pku暑假课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>背包九讲</title>
      <link href="/2019/03/29/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
      <url>/2019/03/29/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 动态规划</title>
      <link href="/2019/03/26/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/03/26/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划（leetcode）"><a href="#动态规划（leetcode）" class="headerlink" title="动态规划（leetcode）"></a>动态规划（leetcode）</h1><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><h3 id="最长回文子串问题（算法笔记上有）"><a href="#最长回文子串问题（算法笔记上有）" class="headerlink" title="最长回文子串问题（算法笔记上有）"></a>最长回文子串问题（算法笔记上有）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]&amp;&amp;i&lt;s.length()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   start=i;</span><br><span class="line">                    end=i+<span class="number">1</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                ans=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=s.length();len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()-len+<span class="number">1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+len<span class="number">-1</span>;    <span class="comment">//尾串位置</span></span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ans&lt;len)</span><br><span class="line">                    &#123;</span><br><span class="line">                        start=i;</span><br><span class="line">                        end=j;</span><br><span class="line">                        ans=len;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> strans=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)</span><br><span class="line">                strans+=s[i];</span><br><span class="line">        <span class="keyword">return</span> strans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数组dp[i][j]表示源串s的前i个字符串和匹配串p的前j个字符串是否匹配</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=s.length();</span><br><span class="line">        <span class="keyword">int</span> len2=p.length();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][j<span class="number">-1</span>]==<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j]==<span class="string">'.'</span>)   <span class="comment">//如果p[j]是.都可以匹配</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j]==s[i]) </span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j]==<span class="string">'*'</span>)  <span class="comment">//考虑三种情况，p串只匹配一个，匹配0个，匹配多个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]!=p[j<span class="number">-1</span>]&amp;&amp;p[j<span class="number">-1</span>]!=<span class="string">'.'</span>)    <span class="comment">//匹配0个</span></span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]||dp[i+<span class="number">1</span>][j]||dp[i][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="[32] Longest Valid Parentheses"></a>[32] Longest Valid Parentheses</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>设<strong>dp[i]等于</strong> s 中长度为 i 的字符串的**最长的有效括号数量。一开始全部初始化dp数组为0。扫描s，如果s[i]==’(‘，继续。s[i]==’)’判断。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=32 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [32] Longest Valid Parentheses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/longest-valid-parentheses/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Hard (25.09%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    178.2K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 710.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '"(()"'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a string containing just the characters '(' and ')', find the length</span></span><br><span class="line"><span class="comment"> * of the longest valid (well-formed) parentheses substring.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: "(()"</span></span><br><span class="line"><span class="comment"> * Output: 2</span></span><br><span class="line"><span class="comment"> * Explanation: The longest valid parentheses substring is "()"</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: ")()())"</span></span><br><span class="line"><span class="comment"> * Output: 4</span></span><br><span class="line"><span class="comment"> * Explanation: The longest valid parentheses substring is "()()"</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">')'</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>]==<span class="string">'('</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=<span class="number">2</span>+(i<span class="number">-2</span>&gt;=<span class="number">0</span>?dp[i<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>]==<span class="string">')'</span>&amp;&amp;i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>) <span class="comment">//i-dp[i-1]肯定是个(再判断它前面一个是不是( </span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>+(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span> ? dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] : <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                maxn=max(maxn,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>用dp[10005][2]每一次来存两个状态。dp[i][0]表示从i向前看去的最小值（如果 下一个为负数，这个最小值就会变成下一次的最大值）。dp[i][1]表示从i向前看去的最大值(如果下一个继续为正数，这个最大值就会接上)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=min(dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i],min(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i],nums[i]))<span class="comment">//会有三种情况</span></span><br><span class="line"><span class="comment">//dp[i-1][1]*nums[i]上一个正数*当前nums[i]（负数），dp[i-1][0]*nums[i]上一个负数×当前nums[i]（正数），当前nums[i]（负数）</span></span><br><span class="line">dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i],max(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i],nums[i])); </span><br><span class="line"><span class="comment">//dp[i-1][1]*nums[i](负数)，dp[i-1][0]*nums[i]（正数），nums[i]（正数）</span></span><br></pre></td></tr></table></figure><p>具体dp公式看代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100005</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxn=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i],max(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i],nums[i]));  <span class="comment">//当前的最大值</span></span><br><span class="line">    dp[i][<span class="number">0</span>]=min(dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i],min(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i],nums[i]));  <span class="comment">//当前的最小值</span></span><br><span class="line">    </span><br><span class="line">        maxn=max(dp[i][<span class="number">1</span>],maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>根据dp递推公式找规律，dp[i]=dp[i&amp;(i-1)]+1;   其中i&amp;(i-1)的含义是把i的二进制形式的最后一个1改成0，再+1加回去。这样的话dp[i&amp;(i-1)]就是已经求出来的值了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//ans.push_back(0);</span></span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           ans[i]=ans[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;   <span class="comment">//i&amp;(i-1)是将i的二进制形式最后一位变成0</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二（自己想的）"><a href="#思路二（自己想的）" class="headerlink" title="思路二（自己想的）"></a>思路二（自己想的）</h3><p>先求出1，2，4，8，16…(2的次方数)到num的dp值。然后其他的dp[i]=dp[i-x]+dp[x];x表示的是比i小的2的次方数。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i*=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastX=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lastX=i;                <span class="comment">//记录比当前i小的2的次方数</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[i-lastX]+dp[lastX];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="312-Burst-Balloons（X）"><a href="#312-Burst-Balloons（X）" class="headerlink" title="312. Burst Balloons（X）"></a>312. Burst Balloons（X）</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>具体参考了这个博客<a href="https://blog.csdn.net/qq_21602549/article/details/80493089" target="_blank" rel="noopener">https://blog.csdn.net/qq_21602549/article/details/80493089</a></p><p>我想破头也想不出来这么做啊！！！dp[i][j]表示打破[i,j]中的气球可以获取的最大分数。</p><p>初始化的时候要注意dp[i][i]就是nums[i]。</p><p>k表示从left到right枚举如果最后一个打破的是第k个气球所得到的最大分数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[left][right] = max(dp[left][right],</span><br><span class="line">                      nums[left<span class="number">-1</span>]*nums[k]*nums[right+<span class="number">1</span>]</span><br><span class="line">                      + dp[left][k<span class="number">-1</span>] + </span><br><span class="line">                      dp[k+<span class="number">1</span>][right]);</span><br></pre></td></tr></table></figure><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line">ll dp[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;;          <span class="comment">//dp[i][j]表示的 打破i-j气球所得的最大得分 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=nums.size();</span><br><span class="line">nums.insert(nums.begin(),<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len++)  <span class="comment">//滑动窗口的长度 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">1</span>;left&lt;=n-len+<span class="number">1</span>;left++)   <span class="comment">//窗口的左端开始位置 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> right=left+len<span class="number">-1</span>;   <span class="comment">//窗口右端</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=left;k&lt;=right;k++)    <span class="comment">//枚举left到right中的气球假设是最后一个打破的 </span></span><br><span class="line">&#123;</span><br><span class="line">dp[left][right]=max(dp[left][right],</span><br><span class="line">nums[left<span class="number">-1</span>]*nums[k]*nums[right+<span class="number">1</span>]+ <span class="comment">//假设k是最后一个打破的气球，那么所得的分数就是nums[left-1]*nums[k]*nums[right+1] </span></span><br><span class="line">dp[left][k<span class="number">-1</span>]+           <span class="comment">//表示的是打破left到k-1气球所得的最大得分 </span></span><br><span class="line">dp[k+<span class="number">1</span>][right]);                       <span class="comment">//表示的是打破k+1气球所得的最大得分 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%5d "</span>,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;A;</span><br><span class="line">A.push_back(<span class="number">3</span>);</span><br><span class="line">A.push_back(<span class="number">1</span>);</span><br><span class="line">A.push_back(<span class="number">5</span>);</span><br><span class="line">A.push_back(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxCoins(A);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大矩形问题"><a href="#最大矩形问题" class="headerlink" title="最大矩形问题"></a>最大矩形问题</h1><h2 id="84-Largest-Rectangle-in-Histogram（！！！）"><a href="#84-Largest-Rectangle-in-Histogram（！！！）" class="headerlink" title="84. Largest Rectangle in Histogram（！！！）"></a>84. Largest Rectangle in Histogram（！！！）</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>这题不是动态规划，但是可以转化成动态规划的做法。这里运用的是单调栈的知识。维护了一个不递减的单调栈。需要关注的特殊情况是一个矩形小于前面一个矩形高度的时候。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>（1）当一个矩形高度<strong>大于等于</strong>栈顶矩形高度的时候，将当前矩形压入栈中。继续下一个矩形。</p><p>（2）当一个矩形高度<strong>小于</strong>栈顶矩形高度的时候，一直将栈中矩形弹出计算并更新最大面积，直到栈中矩形高度小于当前矩形高度的时候再把当前矩形压入栈中。</p><p>（3）最大面积只能够在峰值之前（包括峰值）计算</p><h4 id="为什么要这么做"><a href="#为什么要这么做" class="headerlink" title="为什么要这么做"></a>为什么要这么做</h4><p>首先，我们应该找到这个矩形序列的峰值。峰值就是当前矩形的高度大于后一个矩形的高度的时候。因为我们的本质目的可以看成是寻找到一个矩形作为终点。一个矩形之所以能够作为终点，他必须是峰值，如果不是峰值，那他的后一个还要比他大，那就肯定不是最大矩形了！（这就是为什么我们一开始要在heights后面添加一个0，目的是让最后一个元素也是峰值）。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;    <span class="comment">//每一次计算的是峰值之前的矩形大小</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;      <span class="comment">//存的是高度的序号，并不是高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()&amp;&amp;heights[st.top()]&gt;heights[i]) <span class="comment">//找到峰值</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> cur=st.top();       <span class="comment">//当前峰值之前的最低谷</span></span><br><span class="line">    st.pop();</span><br><span class="line">    <span class="keyword">if</span>(st.empty())         <span class="comment">//如果当前弹出是最后一个元素了，就是说明前面0-(i-1)之间最小的就是heights[cur] 了，有i个所以需要*i </span></span><br><span class="line">    ans=max(ans,heights[cur]*i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    ans=max(ans,</span><br><span class="line">heights[cur]*((i<span class="number">-1</span>)-st.top())); <span class="comment">//i-1表示当前的极值位置，因为i是小于i-1的地方了,st.top()一定是比当前峰值的最低谷小的</span></span><br><span class="line">&#125;</span><br><span class="line">st.push(i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="85-Maximal-Rectangle"><a href="#85-Maximal-Rectangle" class="headerlink" title="85. Maximal Rectangle"></a>85. Maximal Rectangle</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>这题有两种做法</p><p>先说不是dp的做法，利用上一题，求最大矩形。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//int dp[1005][1005]=&#123;0&#125;;  //</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()&amp;&amp;heights[st.top()]&gt;heights[i])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> cur=st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    <span class="keyword">if</span>(st.empty())         <span class="comment">//如果当前弹出是最后一个元素了，就是说明前面0-(i-1)之间最小的就是heights[cur] 了，有i个所以需要*i </span></span><br><span class="line">    ans=max(ans,heights[cur]*i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    ans=max(ans,</span><br><span class="line">heights[cur]*(i<span class="number">-1</span>-st.top())); <span class="comment">//i-1表示当前的极值位置，因为i是小于i-1的地方了 </span></span><br><span class="line">&#125;</span><br><span class="line">st.push(i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].size();  <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">int</span> n=matrix.size();  <span class="comment">//行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxS=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(m,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)        <span class="comment">//以这个为底</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=<span class="string">'0'</span>)    </span><br><span class="line">                    dp[j]+=(matrix[i][j]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">//如果matrix[i][j]是'0'，说明这个矩形断了！</span></span><br><span class="line">                    dp[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxS=max(maxS,largestRectangleArea(dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h1><h2 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>dp[i][j]表示的含义就是s1的前i个和s2的前j个变得相同，最少需要操作几次。</p><p>1.初始化边界</p><p>2.dp公式：</p><p>（1）如果对应位置的字符相同，则不需要进行操作。所以dp[i][j]=dp[i-1][j-1]。</p><p>（2）如果对应位置的字符不相同，则需要进行操作。</p><p><strong>可以有三种操作：</strong></p><p>​            <strong>如果 s1[i-1]和s2[j]可以配对，那我就删除s1[i]即可(删除)；</strong> <strong>dp[i-1][j]</strong></p><p>​            <strong>如果 s1[i]和s2[j-1]可以配对，那我就在s2的后面加上s1[i]即可(插入)；</strong> <strong>dp[i][j-1]</strong><br>​            <strong>如果 s1[i-1]和s2[j-1]可以配对，那我就把s1[i]修改成s2[j]即可；</strong>    <strong>dp[i-1][j-1]</strong></p><p>从以上三种情况选出最小值，并+1操作。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];   <span class="comment">//str1的前i个和str2的前j个匹配的最小操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=word1.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;                          <span class="comment">//全插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=word2.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;                          <span class="comment">//全插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word1.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;word2.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i]==word2[j])        <span class="comment">//恰好匹配</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">//word1[i]!=word2[j]的情况下</span></span><br><span class="line">                &#123;      <span class="comment">//dp[i][j]表示word1和word2都能匹配，dp[i+1][j]表示在word2后面插入word1[i],dp[i][j+1]表示删除word1[i]</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(dp[i+<span class="number">1</span>][j],min(dp[i][j+<span class="number">1</span>],dp[i][j]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>dp[i]表示到第i级楼梯有多少种走法，等于dp[i-1]走一步，等于dp[i-2]走两步</p><p>dp[1]=1;dp[2]=2;</p><p>dp[i]=dp[i-1]+dp[i-2];</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>dp[i]的含义是前i天可以获得的最大利益。</p><p>有两种情况。</p><p>（1）如果要选第i天，那么第i-1天就不能选，只能选i-2天。S1=nums[i]+dp[i-2]。</p><p>（2）如果不要选第i天，那么第i天就可以选。S2=dp[i-1]。</p><p>比较S1和S2的最大值。</p><p>dp[i]=max(nums[i]+dp[i-2],dp[i-1])</p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(nums[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]);</span><br><span class="line">            ans=max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h2><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>和上一题类似。只不过要注意的是选头不能选尾，选尾不能选头。</p><p>所以要进行两次上一题的操作。</p><p><strong>第一次数组里面只有源数组第0~n-2个元素</strong></p><p><strong>第二次数组里面只有源数组第1~n-1个元素</strong></p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(nums[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]);</span><br><span class="line">            ans=max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums1=nums;</span><br><span class="line">        nums1.erase(nums1.begin()+nums1.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums2=nums;</span><br><span class="line">        nums2.erase(nums2.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res1=rob1(nums1);   <span class="comment">//nums1只有0-n-2</span></span><br><span class="line">        <span class="keyword">int</span> res2=rob1(nums2);   <span class="comment">//nums2只有1-n</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(res1,res2);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//return 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩阵的总路径数"><a href="#矩阵的总路径数" class="headerlink" title="矩阵的总路径数"></a>矩阵的总路径数</h1><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="[62] Unique Paths"></a>[62] Unique Paths</h2><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>dp[i][j]表示到达点(i,j)的总路径.dp[i][j]=dp[i-1][j]+dp[i][j-1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=62 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [62] Unique Paths</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/unique-paths/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (46.76%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    268.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 573.9K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '3\n2'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A robot is located at the top-left corner of a m x n grid (marked 'Start' in</span></span><br><span class="line"><span class="comment"> * the diagram below).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The robot can only move either down or right at any point in time. The robot</span></span><br><span class="line"><span class="comment"> * is trying to reach the bottom-right corner of the grid (marked 'Finish' in</span></span><br><span class="line"><span class="comment"> * the diagram below).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * How many possible unique paths are there?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Above is a 7 x 3 grid. How many possible unique paths are there?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note: m and n will be at most 100.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: m = 3, n = 2</span></span><br><span class="line"><span class="comment"> * Output: 3</span></span><br><span class="line"><span class="comment"> * Explanation:</span></span><br><span class="line"><span class="comment"> * From the top-left corner, there are a total of 3 ways to reach the</span></span><br><span class="line"><span class="comment"> * bottom-right corner:</span></span><br><span class="line"><span class="comment"> * 1. Right -&gt; Right -&gt; Down</span></span><br><span class="line"><span class="comment"> * 2. Right -&gt; Down -&gt; Right</span></span><br><span class="line"><span class="comment"> * 3. Down -&gt; Right -&gt; Right</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: m = 7, n = 3</span></span><br><span class="line"><span class="comment"> * Output: 28</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h2><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>和上一题类似</p><p>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1]</p><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> n=grid.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i]=dp[<span class="number">1</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h1><h2 id="303-Range-Sum-Query-Immutable"><a href="#303-Range-Sum-Query-Immutable" class="headerlink" title="303. Range Sum Query - Immutable"></a>303. Range Sum Query - Immutable</h2><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>区间求和。</p><p>先求出sum数组。sum[i]表示前i个数的和。求区间的值就用sum[j]-sum[i]即可。</p><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;sum;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        sum.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum.push_back(sum[sum.size()<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sum.insert(sum.begin(),<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sum[j+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum[j+<span class="number">1</span>]-sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="413-Arithmetic-Slices-X"><a href="#413-Arithmetic-Slices-X" class="headerlink" title="413. Arithmetic Slices(X)"></a>413. Arithmetic Slices(X)</h2><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>和上一题思路类似。先是求出sum[i]=A[i]-A[i-1]的差。可以发现如果sum[i]==sum[i-1]就会形成一个满足题意要求的序列。</p><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;   <span class="comment">//dp[i]表示以第i个数结尾的，可以形成的最多的序列</span></span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i]=A[i]-A[i<span class="number">-1</span>];</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//dp[i]=1;</span></span><br><span class="line">            <span class="keyword">if</span>(sum[i]==sum[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h1><p>这一类题目都是线性dp，主要是注意递推公式。</p><h2 id="343-Integer-Break（！！！）"><a href="#343-Integer-Break（！！！）" class="headerlink" title="343. Integer Break（！！！）"></a>343. Integer Break（！！！）</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>dp[i]表示第i个数的最大乘积。</p><p>大概思路就是肯定和之前所推断出来dp[i-j]有关系！</p><p>dp[i]=max(dp[i],dp[i-j]*j,(i-j)*j)   </p><h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max(dp[i],max(dp[i-j]*j,(i-j)*j));   <span class="comment">//(i-j)*j表示直接分成了两个部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>还是完全背包！</p><p>背包牛逼！！！</p><p>dp[i]表示的是当值为i的时候，可以组成的最大乘积！</p><p>注意初始化的时候dp[0]=1，因为递推式都是乘法，不初始化为1，都是0.</p><h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    ll dp[<span class="number">60</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=i;v&lt;=n;v++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[v]=max(dp[v],dp[v-i]*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h2><h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><p>每个数都是可以由x个完全平方数和y个普通数组成的。</p><h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=i;   <span class="comment">//最多由i个1组成</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=min(dp[i],dp[i-j*j]+<span class="number">1</span>);    <span class="comment">//一个数都是由x个完全平方数和y个普通数组成的</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完全背包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        fill(dp,dp+<span class="number">100005</span>,<span class="number">1000000</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=i*i;v&lt;=n;v++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[v]=min(dp[v],dp[v-i*i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h2><h3 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h3><p>和走楼梯类似。</p><p><strong>dp[i]=dp[i-1] || dp[i]=dp[i-1]+dp[i-2]（满足要求）</strong></p><h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;    <span class="comment">//dp[i]=dp[i-1]||dp[i]=dp[i-1]+dp[i-2]（满足要求）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=s[i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;nums[i]==<span class="number">0</span>&amp;&amp;(nums[i<span class="number">-1</span>]&gt;<span class="number">2</span>||nums[i<span class="number">-1</span>]==<span class="number">0</span>))   <span class="comment">//如果当前位置是0，之前一位不是1或者2，解码失败，直接返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>&amp;&amp;(nums[i]&lt;=<span class="number">9</span>&amp;&amp;nums[i<span class="number">-1</span>]==<span class="number">1</span>)||(nums[i]&lt;=<span class="number">6</span>&amp;&amp;nums[i<span class="number">-1</span>]==<span class="number">2</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><h2 id="300-Longest-Increasing-Subsequence-Medium"><a href="#300-Longest-Increasing-Subsequence-Medium" class="headerlink" title="300. Longest Increasing Subsequence (Medium)"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">300. Longest Increasing Subsequence (Medium)</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>];   <span class="comment">//存储以i为结尾的最长子序列长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;    <span class="comment">//初始化dp[i]为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="646-Maximum-Length-of-Pair-Chain-Medium-（！！！）"><a href="#646-Maximum-Length-of-Pair-Chain-Medium-（！！！）" class="headerlink" title="646. Maximum Length of Pair Chain (Medium)（！！！）"></a><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">646. Maximum Length of Pair Chain (Medium)</a>（！！！）</h2><h3 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h3><p>这题区间贪心更加合适。详情请看算法笔记！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(pairs.begin(),pairs.end(),cmp);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pairs[i][<span class="number">0</span>]&gt;pairs[j][<span class="number">1</span>]&amp;&amp;(dp[j]+<span class="number">1</span>&gt;dp[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h2><h3 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h3><p>完全背包问题。需要注意的是初始化数组的时候需要把dp[0]=0,dp[i]=INF（无穷大）。</p><p>需要注意的是这里的w[i]重量数组就是coin的面值，c[i]价值数组全为1.意思是代表了每把一个放进去，相当于价值+1。要求满足dp[target]的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(amount+<span class="number">1</span>,<span class="number">100000</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//dp[i]=i+1;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=coins[i];v&lt;=amount;v++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[v]=min(dp[v],dp[v-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==<span class="number">100000</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="416-Partition-Equal-Subset-Sum（！！！）"><a href="#416-Partition-Equal-Subset-Sum（！！！）" class="headerlink" title="416. Partition Equal Subset Sum（！！！）"></a>416. Partition Equal Subset Sum（！！！）</h2><h3 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h3><p>01背包变种。自己没想出来。。真的是垃圾。。。</p><p>总思路就是要选出一个子序列，使得他们的和等于nums的一半。</p><p>所以在使用01背包的时候需要注意的是背包容量为nums/2。目的就是使得在容量为nums/2的情况下最大的和是否能够等于nums/2。</p><p><em>注意</em>：背包容量不能够设置为nums。如果设置为nums，无论怎么样，最后的结果一定是nums的。</p><h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> V[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=nums[i];</span><br><span class="line">        w[i+<span class="number">1</span>]=V[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ans/=<span class="number">2</span>;     <span class="comment">//这里注意！ </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=ans;v&gt;=w[i];v--)  <span class="comment">//大于ans/2的数都不必考虑了，所以就能够保证</span></span><br><span class="line">&#123;</span><br><span class="line">dp[v]=max(dp[v],dp[v-w[i]]+V[i]);    <span class="comment">//因为ans/=2，所以这里尽量取最大值！ </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[ans]==ans)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="494-Target-Sum（！！！）"><a href="#494-Target-Sum（！！！）" class="headerlink" title="494. Target Sum（！！！）"></a>494. Target Sum（！！！）</h2><h3 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h3><p><strong>A为加法操作的数字，S为减法操作数字</strong></p><p><strong>sum(A)-sum(S)=target</strong></p><p><strong>sum(all)=sum(A)+sum(S)—-&gt;sum(S)=sum(all)-sum(A)</strong></p><p><strong>2sum(A)=target+sum(all)</strong></p><p><strong>sum(A)=(target+sum(all))/2    —-&gt;转化成了416题</strong></p><p><strong>01背包的变种问法！（求方案总数）。</strong></p><p>dp[i][v]=dp[i-1][v]+dp[i][v-w[i]]</p><p>初始条件dp[0][0]=1。</p><p>具体可见背包九讲！</p><h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) sum+=num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum &lt; S || (sum + S) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> target = (sum+S)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=target;y&gt;=nums[i];y--)</span><br><span class="line">            dp[y]+=dp[y-nums[i]];</span><br><span class="line"> <span class="keyword">return</span> dp[target];   </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="343-Integer-Break（！！！）-1"><a href="#343-Integer-Break（！！！）-1" class="headerlink" title="343. Integer Break（！！！）"></a>343. Integer Break（！！！）</h2><h3 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h3><p>dp[i]表示第i个数的最大乘积。</p><p>大概思路就是肯定和之前所推断出来dp[i-j]有关系！</p><p>dp[i]=max(dp[i],dp[i-j]*j,(i-j)*j)   </p><h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max(dp[i],max(dp[i-j]*j,(i-j)*j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h3><p>还是完全背包！</p><p>背包牛逼！！！</p><p>dp[i]表示的是当值为i的时候，可以组成的最大乘积！</p><p>注意初始化的时候dp[0]=1，因为递推式都是乘法，不初始化为1，都是0.</p><h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    ll dp[<span class="number">60</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=i;v&lt;=n;v++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[v]=max(dp[v],dp[v-i]*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        fill(dp,dp+<span class="number">10005</span>,<span class="number">10000005</span>);</span><br><span class="line">        sort(coins.begin(),coins.end());</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v=coins[i];v&lt;=amount;v++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v==coins[i])</span><br><span class="line">                    dp[v]=<span class="number">1</span>;</span><br><span class="line">                dp[v]=min(dp[v],dp[v-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==<span class="number">10000005</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="买股票系列"><a href="#买股票系列" class="headerlink" title="买股票系列"></a>买股票系列</h1><h3 id="121-Best-Time-to-Buy-and-Sell-Stock（DP）"><a href="#121-Best-Time-to-Buy-and-Sell-Stock（DP）" class="headerlink" title="121. Best Time to Buy and Sell Stock（DP）"></a>121. Best Time to Buy and Sell Stock（DP）</h3><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>因为只用计算一次，所以直接寻找到两个差值最大的两天。</p><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//int dp[20005]=&#123;0&#125;;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minx=<span class="number">100000000</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minx=min(minx,prices[i]);</span><br><span class="line">            ans=max(prices[i]-minx,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><h4 id="思路1-2"><a href="#思路1-2" class="headerlink" title="思路1"></a>思路1</h4><p>看上去很难，实际上很坑。只需要判断第i天是否比第i-1天大就行了，因为就算是</p><p>[1,2,100]的情况。标准应该是第1天买进来，第3天卖出去。但是也可以看成是第1天买入，第3天卖出。第2天买入，第3天卖出。</p><p>真的坑！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ans+=(prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路2-2"><a href="#思路2-2" class="headerlink" title="思路2"></a>思路2</h4><p>实际上这题还有动态规划的做法！</p><p>具体递推公式看代码注释。</p><p>f(i)表示在第i天不持有股票所获得的最大收益。</p><p><strong>f(i)=max(f(i-1),g(i-1)+prices(i))</strong></p><p>g(i)表示在第i天持有股票所获得的最大收益。</p><p><strong>g(i)=max(g(i-1),f(i-1)-prices(i))</strong></p><p>还要注意初始化的时候，g(0)要初始化为负无穷！</p><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f=<span class="number">0</span>;<span class="comment">//表示f(i) </span></span><br><span class="line"><span class="keyword">int</span> g=<span class="number">-10000000</span>;<span class="comment">//g(i)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> last_f=f;   <span class="comment">//f(i-1)</span></span><br><span class="line"><span class="keyword">int</span> last_g=g;   <span class="comment">//g(i-1)</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f&lt;&lt;<span class="string">" "</span>&lt;&lt;g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">f=max(last_f,last_g+prices[i]);    <span class="comment">//f(i)=max(f(i-1),g(i-1)+prices(i))</span></span><br><span class="line">g=max(last_g,last_f-prices[i]);<span class="comment">//g(i)=max(g(i-1),f(i-1)-prices(i))</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h3><h4 id="思路1-3"><a href="#思路1-3" class="headerlink" title="思路1"></a>思路1</h4><p>动态规划的思想。</p><p>因为是要最多进行两次交易。所以可以分成两段去处理。</p><p>第一段从前往后按照121题的思路找到前i天的最大收益。</p><p>第二段从后往前按照121题的思路找到后i天的最大收益。</p><p>最大总收益就等于dp1[i]+dp2[i]。</p><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp1[<span class="number">100000</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">//表示进行一次买卖，前i天可以获得的最大利润 </span></span><br><span class="line">    <span class="keyword">int</span> dp2[<span class="number">100000</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">//从后往前进行一次买卖</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prices.size()==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minx=prices[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//int max1=0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">dp1[i]=max(dp1[i<span class="number">-1</span>],prices[i]-minx);</span><br><span class="line">minx=min(prices[i],minx);</span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxn=prices[prices.size()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=prices.size()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)    <span class="comment">//从后往前找到最大的那天价格，减去前面的价格 </span></span><br><span class="line">&#123;</span><br><span class="line">dp2[i]=max(dp2[i+<span class="number">1</span>],maxn-prices[i]);</span><br><span class="line">maxn=max(maxn,prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*for(int i=0;i&lt;prices.size();i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;dp1[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;prices.size();i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;dp2[i]&lt;&lt;" " ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++)        <span class="comment">//相当于在第i天的时候分成了两半，前i天获得的最大价格和后i天获得的最大价格 </span></span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dp1[i]+dp2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路2-3"><a href="#思路2-3" class="headerlink" title="思路2"></a>思路2</h4><p>有点像第122题的动态规划做法！</p><p>只不过这里变成了定义四个变量。</p><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fstBuy = INT_MIN, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy =INT_MIN, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            fstBuy = max(fstBuy, -p);</span><br><span class="line">            fstSell = max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = max(secBuy, fstSell - p);</span><br><span class="line">            secSell = max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h4><p>可以推广到第K次买卖可以获得的最大利润。</p><p><a href="https://blog.csdn.net/laputafallen/article/details/79846424" target="_blank" rel="noopener">https://blog.csdn.net/laputafallen/article/details/79846424</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">3</span>][<span class="number">100005</span>];          <span class="comment">//dp[i][j]表示进行i次买卖，在第j天可以获得的最大利润 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)       <span class="comment">//进行第i次买卖 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> balance=-A[<span class="number">0</span>];      <span class="comment">//表示前一次交易所获得的最大利润</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][j]=max(dp[i][j<span class="number">-1</span>],balance+A[j]);    <span class="comment">//表示是否在第j天进行交易，不进行dp(i,j)=dp(i,i-1)</span></span><br><span class="line">        <span class="comment">//进行交易dp(i,j)=当天价格加上前一次交易所获得的最大利润 </span></span><br><span class="line">        balance=max(balance,dp[i<span class="number">-1</span>][j<span class="number">-1</span>]-A[j]);   <span class="comment">//表示上一次买卖是在第j天的情况下， balance表示前j-1天交易所获得的最大利润 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)   <span class="comment">//打印出来看看</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">2</span>][N<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="石子合并（线性）"><a href="#石子合并（线性）" class="headerlink" title="石子合并（线性）"></a>石子合并（线性）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"><span class="keyword">int</span> MIN[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> MAX[maxn][maxn]; </span><br><span class="line"><span class="keyword">int</span> sum[maxn];   <span class="comment">//前缀和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">MIN[i][i] = <span class="number">0</span>;</span><br><span class="line">MAX[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">sum[<span class="number">1</span>]=A[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i+<span class="number">1</span>]=sum[i]+A[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=N;len++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">MIN[i][j]=INF;</span><br><span class="line">MAX[i][j]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> temp=sum[j]-sum[i<span class="number">-1</span>];   <span class="comment">//i-j的区间和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">&#123;</span><br><span class="line">MIN[i][j]=min(MIN[i][k]+MIN[k+<span class="number">1</span>][j]+temp,MIN[i][j]);</span><br><span class="line">MAX[i][j]=max(MAX[i][k]+MAX[k+<span class="number">1</span>][j]+temp,MAX[i][j]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;MIN[<span class="number">1</span>][N]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;MAX[<span class="number">1</span>][N]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="石子合并（环）"><a href="#石子合并（环）" class="headerlink" title="石子合并（环）"></a>石子合并（环）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> MIN[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> MAX[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> in=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]+=(sum[i<span class="number">-1</span>]+A[in++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> temp=sum[j]-sum[i<span class="number">-1</span>];</span><br><span class="line">MIN[i][j]=INF;</span><br><span class="line">MAX[i][j]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">&#123;</span><br><span class="line">MIN[i][j]=min(MIN[i][k]+MIN[k+<span class="number">1</span>][j]+temp,MIN[i][j]);</span><br><span class="line">MAX[i][j]=max(MAX[i][k]+MAX[k+<span class="number">1</span>][j]+temp,MAX[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minans=INF;</span><br><span class="line"><span class="keyword">int</span> maxans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">maxans=max(maxans,MAX[i][i+n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">minans=min(minans,MIN[i][i+n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><h2 id="1-DP"><a href="#1-DP" class="headerlink" title="1(DP)"></a>1(DP)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//int dp[100005]=&#123;0&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> dp1[<span class="number">100005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        dp1[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j+nums[j]&gt;=i&amp;&amp;dp1[j]==<span class="number">1</span>)  <span class="comment">//dp1[j]可达，且j+nums[j]大于i这个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp1[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp1[nums.size()<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1贪心"><a href="#1贪心" class="headerlink" title="1贪心"></a>1贪心</h2><p>维护一个reach变量，表示最大可达距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;reach||reach&gt;=n<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reach=max(reach,nums[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reach&gt;=n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="百炼OJ"><a href="#百炼OJ" class="headerlink" title="百炼OJ"></a>百炼OJ</h1><h2 id="2192-Zipper"><a href="#2192-Zipper" class="headerlink" title="2192: Zipper"></a>2192: Zipper</h2><p>dp[i][j]表示的含义是str1的前i个和str2的前j个能组成str3的前i+j个吗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];     <span class="comment">//dp[i][j]表示str1前i个和str2前j个能组成吗 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">int</span> tt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(tt&lt;=T)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">1005</span>],str2[<span class="number">1005</span>],str3[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str1+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str2+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str3+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fill(dp[<span class="number">0</span>],dp[<span class="number">0</span>]+<span class="number">1005</span>*<span class="number">1005</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str1[<span class="number">1</span>]==str3[<span class="number">1</span>])</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(str2[<span class="number">1</span>]==str3[<span class="number">1</span>])</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">strlen</span>(str1+<span class="number">1</span>);i++)   <span class="comment">//注意都要从第0个开始 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">strlen</span>(str2+<span class="number">1</span>);j++)<span class="comment">//注意都要从第0个开始 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;str3[i+j]==str1[i]&amp;&amp;dp[i<span class="number">-1</span>][j])</span><br><span class="line">dp[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;str3[i+j]==str2[j]&amp;&amp;dp[i][j<span class="number">-1</span>])</span><br><span class="line">dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="built_in">strlen</span>(str1+<span class="number">1</span>)][<span class="built_in">strlen</span>(str2+<span class="number">1</span>)])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Data set %d: yes\n"</span>,tt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Data set %d: no\n"</span>,tt);</span><br><span class="line">&#125;</span><br><span class="line">tt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划专题篇</title>
      <link href="/2019/03/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98%E7%AF%87/"/>
      <url>/2019/03/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的动态规划类型"><a href="#常见的动态规划类型" class="headerlink" title="常见的动态规划类型"></a>常见的动态规划类型</h1><h2 id="最大连续子序和"><a href="#最大连续子序和" class="headerlink" title="最大连续子序和"></a>最大连续子序和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]=max(dp[i<span class="number">-1</span>]+A[i],A[i])</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> maxn1=-INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=max(dp[i<span class="number">-1</span>]+a[i],a[i]);</span><br><span class="line">maxn1=max(maxn1,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i]表示以i结尾的最长不下降子序列</span><br><span class="line">dp[i]=max(dp[i],dp[j]+<span class="number">1</span>)  <span class="comment">//j=1到i-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];   <span class="comment">//以i结尾的最大子序列长度 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[j]&lt;=A[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,dp[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]表示第<span class="number">1</span>个字符串前i个和第<span class="number">2</span>个字符串的前j个字符的最长公共子序列</span><br><span class="line">(<span class="number">1</span>)dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;   <span class="comment">//A[i]==A[j]</span></span><br><span class="line">(<span class="number">2</span>)dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])   <span class="comment">//A[i]!=A[j]</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> A;</span><br><span class="line"><span class="built_in">string</span> B;</span><br><span class="line"><span class="keyword">char</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> b[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];   <span class="comment">//dp[i][j]表示A的前i个和B的前j个的最长公共子序列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cin&gt;&gt;A&gt;&gt;B;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,b+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">strlen</span>(a+<span class="number">1</span>);i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">strlen</span>(b+<span class="number">1</span>);i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(a+<span class="number">1</span>)+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="built_in">strlen</span>(b+<span class="number">1</span>)+<span class="number">1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="built_in">strlen</span>(a+<span class="number">1</span>)][<span class="built_in">strlen</span>(b+<span class="number">1</span>)]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]表示第i到j个字符是否为回文串</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size()<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(str[i]==str[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">ans=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[str.size()<span class="number">-1</span>][str.size()<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=str.size();len++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size()-len+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(str[i]==str[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=len;</span><br><span class="line">ans=max(ans,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAG最长路"><a href="#DAG最长路" class="headerlink" title="DAG最长路"></a>DAG最长路</h2><p>拓扑排序的逆过程。主要思想是：dp[i]代表了以顶点i为开始的最长路径。</p><p>dp[i]=max(dp[j1],dp[j2],…dp[jN]);</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i]&gt;<span class="number">0</span>)<span class="keyword">return</span> dp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i][j]!=INF)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(DP(j)+G[i][j],dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩形嵌套"><a href="#矩形嵌套" class="headerlink" title="矩形嵌套"></a>矩形嵌套</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>];     <span class="comment">//记录从i出发的最长路径 </span></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">105</span>];    <span class="comment">//记录最长路径 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i]&gt;<span class="number">0</span>)<span class="keyword">return</span> dp[i];    <span class="comment">//已经计算了,防止重复计算 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i][j]!=INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=DP(j)+G[i][j];</span><br><span class="line"><span class="keyword">if</span>(temp&gt;dp[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=temp;</span><br><span class="line">path[i]=j;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line"><span class="keyword">while</span>(path[i]!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i=path[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">node A[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"></span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+<span class="number">105</span>*<span class="number">105</span>,INF);</span><br><span class="line">fill(dp,dp+<span class="number">105</span>,<span class="number">0</span>);</span><br><span class="line">fill(path,path+<span class="number">105</span>,<span class="number">-1</span>);  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;A[i].length&gt;&gt;A[i].width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((A[i].length&gt;A[j].length&amp;&amp;A[i].width&gt;A[j].width)||(A[i].width&gt;A[j].length&amp;&amp;A[i].length&gt;A[j].width))</span><br><span class="line">&#123;</span><br><span class="line">G[i][j]=<span class="number">1</span>;     <span class="comment">//i嵌套j的情况 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((A[j].length&gt;A[i].length&amp;&amp;A[j].width&gt;A[i].width)||(A[j].width&gt;A[i].length&amp;&amp;A[j].length&gt;A[i].width))</span><br><span class="line">&#123;</span><br><span class="line">G[j][i]=<span class="number">1</span>;     <span class="comment">//j嵌套i的情况 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,DP(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>01背包的公式为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[i][v]=max(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]])   <span class="comment">//不选第i个，选第i个</span></span><br><span class="line">    </span><br><span class="line">dp[v]=max(dp[v],dp[v-w[i]])   <span class="comment">//使用滚动数组的时候需要注意从后往前推</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>; <span class="comment">//物品最大数量 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>;  <span class="comment">//背包最大容量 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> dp1[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;      <span class="comment">//滚动数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;V;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">&#125;</span><br><span class="line">fill(dp[<span class="number">0</span>],dp[<span class="number">0</span>]+<span class="number">105</span>*<span class="number">1000</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][v]=max(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)     <span class="comment">//打印 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[i][v]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[N][V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**滚动数组**/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)</span><br><span class="line">&#123;</span><br><span class="line">dp1[v]=max(dp1[v],dp1[v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)       <span class="comment">//打印 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp1[v]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dp1[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;dp1[V]&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">3 5 1 2 2</span></span><br><span class="line"><span class="comment">4 5 2 1 3</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">0 0 0 4 4 4 4 4 4</span></span><br><span class="line"><span class="comment">0 0 0 0 0 5 5 5 9</span></span><br><span class="line"><span class="comment">0 2 2 2 2 5 7 7 9</span></span><br><span class="line"><span class="comment">0 0 2 3 3 5 7 7 9</span></span><br><span class="line"><span class="comment">0 0 3 3 5 6 7 8 10</span></span><br><span class="line"><span class="comment">ans=10;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 0 0 4 4 4 4 4 4</span></span><br><span class="line"><span class="comment">0 0 0 4 4 5 5 5 9</span></span><br><span class="line"><span class="comment">0 2 2 4 6 6 7 7 9</span></span><br><span class="line"><span class="comment">0 2 2 4 6 6 7 7 9</span></span><br><span class="line"><span class="comment">0 2 3 5 6 7 9 9 10</span></span><br><span class="line"><span class="comment">ans=10;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="问题-A-装箱问题"><a href="#问题-A-装箱问题" class="headerlink" title="问题 A: 装箱问题"></a>问题 A: 装箱问题</h3><p><a href="http://codeup.cn/problem.php?cid=100000631&amp;pid=0" target="_blank" rel="noopener">http://codeup.cn/problem.php?cid=100000631&amp;pid=0</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> V,N;</span><br><span class="line"><span class="keyword">int</span> w[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)</span><br><span class="line">&#123;</span><br><span class="line">dp[v]=max(dp[v],dp[v-w[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for(int j=0;j&lt;=V;j++)</span></span><br><span class="line"><span class="comment">cout&lt;&lt;dp[j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;V-dp[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-B-采药"><a href="#问题-B-采药" class="headerlink" title="问题 B: 采药"></a>问题 B: 采药</h3><p><a href="http://codeup.cn/problem.php?cid=100000631&amp;pid=1" target="_blank" rel="noopener">http://codeup.cn/problem.php?cid=100000631&amp;pid=1</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,T;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">105</span>];</span><br><span class="line">ll dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(dp,dp+<span class="number">1005</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=T;v&gt;=w[i];v--)</span><br><span class="line">&#123;</span><br><span class="line">dp[v]=max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[T]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包和01背包的区别在于01背包只能选择一个物品一次，但是完全背包可以无限选择物品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[i][v]=max(dp[i<span class="number">-1</span>][v],dp[i][v-w[i]])   <span class="comment">//不选第i个，选第i个，注意和01背包的区别</span></span><br><span class="line">    </span><br><span class="line">dp[v]=max(dp[v],dp[v-w[i]])   <span class="comment">//使用滚动数组的时候需要注意从前往后推</span></span><br></pre></td></tr></table></figure><h3 id="问题-C-货币系统"><a href="#问题-C-货币系统" class="headerlink" title="问题 C: 货币系统"></a>问题 C: 货币系统</h3><p><a href="http://codeup.cn/problem.php?cid=100000631&amp;pid=2" target="_blank" rel="noopener">http://codeup.cn/problem.php?cid=100000631&amp;pid=2</a></p><p>主要思路：</p><p>​    dp[i]表示的是当需要求的货币总和为i的时候一共拥有的解决方案。我们的目标是求dp[V]。因此初始化的时候需要把dp[0]设置为1，这样在递推的刚开始的时候就确定了一个初始的dp[w[i]]值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推公式如下</span></span><br><span class="line">dp[i][v]=dp[i<span class="number">-1</span>][v]+dp[i][v-w[i]];<span class="comment">//最多只有上一种货币的总和+已有当前类型货币解决方案的总和。</span></span><br><span class="line"><span class="comment">//滚动数组</span></span><br><span class="line">dp[v]=dp[v]+dp[v-w[i]];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">10050</span>];</span><br><span class="line"><span class="keyword">int</span> V,N;</span><br><span class="line">ll w[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;V))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll count=<span class="number">0</span>;</span><br><span class="line">fill(dp,dp+<span class="number">10050</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*for(int j=0;j&lt;=V;j++)</span></span><br><span class="line"><span class="comment">cout&lt;&lt;dp[j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;*/</span></span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(ll v=w[i];v&lt;=V;v++)</span><br><span class="line">&#123;</span><br><span class="line">dp[v]=dp[v]+dp[v-w[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图模板</title>
      <link href="/2019/03/11/%E5%9B%BE%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/03/11/%E5%9B%BE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h1><p>Tarjan算法是求解有向图强连通分量的线性时间的算法。</p><h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p>如果两个顶点可以相互通达，则称两个顶点<a href="https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A" target="_blank" rel="noopener"><strong>强连通</strong></a>(strongly connected)。</p><p>如果<a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743" target="_blank" rel="noopener">有向图</a>G的每两个顶点都<a href="https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A/1131406" target="_blank" rel="noopener">强连通</a>，称G是一个<a href="https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE" target="_blank" rel="noopener"><strong>强连通图</strong></a>。有向图的极大强连通子图，称为<a href="https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F" target="_blank" rel="noopener"><strong>强连通分量</strong></a>(strongly connected components)。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>tarjan求强连通分量的程序实现</p><p>首先需要介绍一些辅助数组</p><blockquote><p>(1)、dfn[ ]，表示这个点在dfs时是<strong>第几个被搜到的</strong>。<br>(2)、low[ ]，表示这个点以及其子孙节点连的所有点中<strong>dfn最小的值</strong><br>(3)、stack[ ]，表示当前<strong>所有可能能构成强连通分量的点。</strong><br>(4)、ins[ ]，表示一个点是否还在stack[ ]数组中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[MAX];<span class="comment">//dfn[i]表示i是第几个被访问的结点</span></span><br><span class="line"><span class="keyword">int</span> low[MAX];<span class="comment">//low[i]表示从i出发经有向边可到达的所有节点中最小的index</span></span><br><span class="line"><span class="keyword">int</span> Com[MAX];<span class="comment">//Com[i]记录i所属的强连通分量的编号</span></span><br><span class="line"><span class="keyword">bool</span> ins[MAX];   <span class="comment">//记录是否在栈中（说明已经访问过） </span></span><br><span class="line"><span class="keyword">int</span> deep=<span class="number">0</span>,numCom=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//最终结果</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++deep;     </span><br><span class="line">    s.push(u);         </span><br><span class="line">ins[u]=<span class="literal">true</span>;       </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:graph[u])&#123;      <span class="comment">//遍历和u相连接的节点 </span></span><br><span class="line">        <span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;     <span class="comment">//还没有访问过v点 </span></span><br><span class="line">            DFS(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ins[v])   <span class="comment">//已经在栈中 </span></span><br><span class="line">            low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])&#123;<span class="comment">//是一个强连通分支的根结点</span></span><br><span class="line">        ++numCom;</span><br><span class="line">        <span class="keyword">int</span> t,num=<span class="number">0</span>;<span class="comment">//num表示该强连通分量中结点的个数</span></span><br><span class="line">        <span class="keyword">do</span>&#123;            <span class="comment">//一直把栈中的强连通分支中的节点弹出来 </span></span><br><span class="line">            t=s.top();</span><br><span class="line">            ins[t]=<span class="literal">false</span>;           </span><br><span class="line">            s.pop();</span><br><span class="line">            ++num;</span><br><span class="line">            Com[t]=numCom;</span><br><span class="line">        &#125;<span class="keyword">while</span>(t!=u);          </span><br><span class="line">        ans+=(num<span class="number">-1</span>)*num/<span class="number">2</span>;<span class="comment">//加上该强连通分量中的便利城市对个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(dfn[i]==<span class="number">0</span>)</span><br><span class="line">            DFS(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 做题模板 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>做题模板</title>
      <link href="/2019/02/11/%E5%81%9A%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/02/11/%E5%81%9A%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a><strong><em>cin.get()</em></strong></h3><p>用于字符数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法1： cin.get(字符变量名)可以用来接收字符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">main () </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">char</span> ch; </span><br><span class="line">ch=<span class="built_in">cin</span>.get();               <span class="comment">//或者cin.get(ch); </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入：jljkljkl </span></span><br><span class="line"><span class="comment">//输出：j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法2：cin.get(字符数组名,接收字符数目)用来接收一行字符串,可以接收空格</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">main () </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">cin</span>.get(a,<span class="number">20</span>); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入：jkl jkl jkl </span></span><br><span class="line"><span class="comment">//输出：jkl jkl jkl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入：abcdeabcdeabcdeabcdeabcde （输入25个字符） </span></span><br><span class="line"><span class="comment">//输出：abcdeabcdeabcdeabcd              （接收19个字符+1个'\0'）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法3：cin.get(无参数)没有参数主要是用于舍弃输入流中的不需要的字符,或者舍弃回车,弥补cin.get(字符数组名,接收字符数目)的不足.</span></span><br><span class="line"><span class="comment">//吃掉一个回车</span></span><br></pre></td></tr></table></figure><h3 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()  "></a><strong>cin.getline()  </strong></h3><p>用于字符数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个字符串，可以接收空格并输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">main () </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">char</span> m[<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">cin</span>.getline(m,<span class="number">5</span>); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：jkljkljkl </span></span><br><span class="line"><span class="comment">输出：jklj</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接受5个字符到m中，其中最后一个为'\0'，所以只看到4个字符输出；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果把5改成20： </span></span><br><span class="line"><span class="comment">输入：jkljkljkl </span></span><br><span class="line"><span class="comment">输出：jkljkljkl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：jklf fjlsjf fjsdklf </span></span><br><span class="line"><span class="comment">输出：jklf fjlsjf fjsdklf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//延伸： </span></span><br><span class="line"><span class="comment">//cin.getline()实际上有三个参数，cin.getline(接受字符串的看哦那间m,接受个数5,结束字符) </span></span><br><span class="line"><span class="comment">//当第三个参数省略时，系统默认为'\0' </span></span><br><span class="line"><span class="comment">//如果将例子中cin.getline()改为cin.getline(m,5,'a');当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当用在多维数组中的时候，也可以用cin.getline(m[i],20)之类的用法：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">main () </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">char</span> m[<span class="number">3</span>][<span class="number">20</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"\n请输入第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"个字符串："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cin</span>.getline(m[i],<span class="number">20</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输出m["</span>&lt;&lt;j&lt;&lt;<span class="string">"]的值:"</span>&lt;&lt;m[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*请输入第1个字符串： </span></span><br><span class="line"><span class="comment">kskr1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请输入第2个字符串： </span></span><br><span class="line"><span class="comment">kskr2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请输入第3个字符串： </span></span><br><span class="line"><span class="comment">kskr3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出m[0]的值:kskr1 </span></span><br><span class="line"><span class="comment">输出m[1]的值:kskr2 </span></span><br><span class="line"><span class="comment">输出m[2]的值:kskr3*/</span></span><br></pre></td></tr></table></figure><h3 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h3><p>string专用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个字符串，可以接收空格并输出，需包含“#include&lt;string&gt;”</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">main () </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">string</span> str; </span><br><span class="line">getline(<span class="built_in">cin</span>,str); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输入：jkljkljkl </span><br><span class="line">输出：jkljkljkl</span><br><span class="line"></span><br><span class="line">输入：jkl jfksldfj jklsjfl </span><br><span class="line">输出：jkl jfksldfj jklsjfl</span><br><span class="line"></span><br><span class="line">和<span class="built_in">cin</span>.getline()类似，但是<span class="built_in">cin</span>.getline()属于istream流，而getline()属于<span class="built_in">string</span>流，是不一样的两个函数</span><br></pre></td></tr></table></figure><h2 id="数字字符"><a href="#数字字符" class="headerlink" title="数字字符"></a>数字<-->字符</--></h2><h3 id="字符转数字"><a href="#字符转数字" class="headerlink" title="字符转数字"></a>字符转数字</h3><h4 id="（sscanf-str-”格式”-数字变量-）"><a href="#（sscanf-str-”格式”-数字变量-）" class="headerlink" title="（sscanf(str,”格式”,数字变量)）"></a>（sscanf(str,”格式”,数字变量)）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>]=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">"%d"</span>,&amp;n);   <span class="comment">//把str中的内容以%d的形式写入n</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> n1=stoi(str1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2=<span class="string">"123.5"</span>;</span><br><span class="line"><span class="keyword">double</span> n2=stod(str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf"</span>,n2);</span><br></pre></td></tr></table></figure><h3 id="数字转字符"><a href="#数字转字符" class="headerlink" title="数字转字符"></a>数字转字符</h3><h4 id="sprintf-str-”格式”-数字变量"><a href="#sprintf-str-”格式”-数字变量" class="headerlink" title="(sprintf(str,”格式”,数字变量))"></a>(sprintf(str,”格式”,数字变量))</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">123</span>;      <span class="comment">// </span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,n);   <span class="comment">//把n中的内容以%d的形式写入str</span></span><br></pre></td></tr></table></figure><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">string</span> str1=to_string(a);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> b=<span class="number">5.5</span>;</span><br><span class="line"><span class="built_in">string</span> str2=to_string(b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="字符判断函数"><a href="#字符判断函数" class="headerlink" title="字符判断函数"></a>字符判断函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="built_in">isalpha</span>(c)用来检查c是否为字母，如果是字母，则返回<span class="number">1</span>；否则返回<span class="number">0</span>。</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">isdigit</span>(c)用来检查c是否为数字（<span class="number">0</span>～<span class="number">9</span>），如果是数字，则返回<span class="number">1</span>；否则返回<span class="number">0</span>。</span><br><span class="line">（<span class="number">3</span>）<span class="built_in">toupper</span>(c)用来将c字符转换为大写字母，返回c对应的大写字母。</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">tolower</span>(c)用来将c字符转换为小写字母，返回c对应的小写字母。</span><br></pre></td></tr></table></figure><h2 id="string大小写转换"><a href="#string大小写转换" class="headerlink" title="string大小写转换"></a>string大小写转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(strA.begin(), strA.end(), strA.begin(),::<span class="built_in">toupper</span>); <span class="comment">//全大写</span></span><br><span class="line">transform(strA.begin(), strA.end(), strA.begin(), ::<span class="built_in">tolower</span>);<span class="comment">//全小写</span></span><br></pre></td></tr></table></figure><h1 id="string-的操作"><a href="#string-的操作" class="headerlink" title="string 的操作"></a>string 的操作</h1><h2 id="字符串截取-string-substr-start-length"><a href="#字符串截取-string-substr-start-length" class="headerlink" title="字符串截取-string.substr(start,length);"></a>字符串截取-string.substr(start,length);</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串截取</span></span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> cuts=s.substr(start,length);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cuts&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>string的成员函数insert有以下多种重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;——在p0位置插入字符串s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;——在p0位置插入字符串s的前n个字符</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;——在p0位置插入字符串s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;——在p0位置插入字符串s从pos开始的连续n个字符</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在p0处插入n个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在it处插入字符c，返回插入后迭代器的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it, const_iterator first, const_iteratorlast)</span></span>;<span class="comment">//在it处插入从first开始至last-1的所有字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在it处插入n个字符c</span></span><br></pre></td></tr></table></figure><h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><p>常用的是replace函数，有三个输入参数：第一个用于指示从字符串的什么位置开始改写，第二个用于指示从源字符串中删除多少个字符，第三个是替换字符串的值。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><ol><li>string::npos:这是string类中的一个成员变量，一般应用在判断系统查询函数的返回值上，若等于该值，表明没有符合查询条件的结果值。</li><li>find函数：在一个字符串中查找指定的单个字符或字符组。如果找到，就返回首次匹配的开始位置；如果没有找到匹配的内容，则返回string：：npos。一般有两个输入参数，一个是待查询的字符串，一个是查询的起始位置，默认起始位置为0.</li><li>find_first_of函数：在一个字符串中进行查找，返回值是第一个与指定字符串中任何字符匹配的字符位置；如果没有找到匹配的内容，则返回string：：npos。一般有两个输入参数，一个是待查询的字符串，一个是查询的起始位置，默认起始位置为0.</li><li>find_last_of函数：在一个字符串中进行查找，返回值是最后一个与指定字符串中任何字符匹配的字符位置；如果没有找到匹配的内容，则返回string：：npos。一般有两个输入参数，一个是待查询的字符串，一个是查询的起始位置，默认起始位置为0.</li><li>find_first_not_of函数：在一个字符串中进行查找，返回值是第一个与指定字符串中任何字符都不匹配的字符位置；如果没有找到匹配的内容，则返回string：：npos。一般有两个输入参数，一个是待查询的字符串，一个是查询的起始位置，默认起始位置为0.</li><li>find_last_not_of函数：在一个字符串中进行查找，返回下标值最大的与指定字符串中任何字符都不匹配的字符位置；如果没有找到匹配的内容，则返回string：：npos。一般有两个输入参数，一个是待查询的字符串，一个是查询的起始位置，默认起始位置为0.</li><li>rfind函数：对一个串从尾至头查找指定的单个字符或字符组，如果找到，就返回首次匹配的开始位置；如果没有找到匹配的内容，则返回string：：npos。一般有两个输入参数，一个是待查询的字符串，一个是查询的起始位置，默认起始位置为0.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"what's your name? my name is TOM. How do you do? Fine,thanks."</span>)</span></span>; </span><br><span class="line">    <span class="keyword">int</span> n = s1.find(<span class="string">"your"</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the first your pos:"</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    n = s1.find(<span class="string">"you"</span>,<span class="number">15</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the first you pos begin from 15:"</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    n = s1.find_first_of(<span class="string">"abcde"</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"find pos when character within abcde:"</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    n = s1.find_first_of(<span class="string">"abcde"</span>,<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"find pos when character within abcde from third character:"</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除字符操作"><a href="#删除字符操作" class="headerlink" title="删除字符操作"></a>删除字符操作</h4><p>主要用erase函数，有两个迭代器输入参数，之间表示的字符将被删除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello c++! +++"</span>;</span><br><span class="line">    <span class="comment">// 从位置pos=10处开始删除，直到结尾</span></span><br><span class="line">    <span class="comment">// 即： " +++"</span></span><br><span class="line">    str.erase(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; str &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 从位置pos=6处开始，删除4个字符</span></span><br><span class="line">    <span class="comment">// 即: "c++!"</span></span><br><span class="line">    str.erase(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; str &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找＋删除"><a href="#查找＋删除" class="headerlink" title="查找＋删除"></a>查找＋删除</h4><p>在使用<code>erase</code>删除函数的时候,经常会和查找函数一起使用</p><p><code>*find*(**)</code>系列方法参数可以是char 或者 string 类型, 为待查找的目标, 返回值为 size_type;当 查找不到目标时,返回值为 npos, 可以这样判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longer</span><span class="params">(<span class="string">"That's a funny hat."</span>)</span></span>;</span><br><span class="line"><span class="comment">//size_type loc1 = longer.find("hat"); // 存在</span></span><br><span class="line">size_type loc1 = longer.find(<span class="string">"hello"</span>); <span class="comment">//不存在</span></span><br><span class="line"><span class="keyword">if</span> (loc1 == <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"not found"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>在头文件#include<sstream>下.</sstream></p><h2 id="实现split效果"><a href="#实现split效果" class="headerlink" title="实现split效果"></a>实现split效果</h2><h3 id="按照‘-’分割"><a href="#按照‘-’分割" class="headerlink" title="按照‘/’分割"></a>按照‘/’分割</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">inputString</span><span class="params">(<span class="string">"/home/fun/./../code/"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(inputString)</span></span>;</span><br><span class="line"><span class="built_in">string</span> tmp;</span><br><span class="line"><span class="keyword">while</span>(getline(ss,tmp,<span class="string">'/'</span>))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.empty())   <span class="keyword">continue</span>; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现格式化输入输出"><a href="#实现格式化输入输出" class="headerlink" title="实现格式化输入输出"></a>实现格式化输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">inputString</span><span class="params">(<span class="string">"123abc 123.4one two three four"</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(inputString)</span></span>;</span><br><span class="line">   <span class="built_in">string</span> s;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line">   ss &gt;&gt; i &gt;&gt; s &gt;&gt; d;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; s.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; d ;</span><br><span class="line">   <span class="keyword">while</span> (ss &gt;&gt; s)</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>&lt;&lt;s.c_str();</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><h3 id="针对字符数组"><a href="#针对字符数组" class="headerlink" title="针对字符数组"></a>针对字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] =<span class="string">"a,b,c,d*e"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * split = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">char</span> * p;</span><br><span class="line">    p = strtok(str,split);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%s\n"</span>,p);</span><br><span class="line">        p = strtok(<span class="literal">NULL</span>,split);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"a,#b,#c,#d"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sep = <span class="string">",#"</span>; <span class="comment">//可按多个字符来分割</span></span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    p = strtok(s, sep);</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, p);</span><br><span class="line">        p = strtok(<span class="literal">NULL</span>, sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spilt</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sv,<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;   <span class="comment">//s是原串，t是分割串,sv是分割结果</span></span><br><span class="line">    <span class="keyword">char</span> *sp = strtok(s,t);</span><br><span class="line">    <span class="keyword">while</span>(sp)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;sp&lt;&lt;endl;</span></span><br><span class="line">        sv.push_back(sp);</span><br><span class="line">        sp  = strtok(<span class="literal">NULL</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对string"><a href="#针对string" class="headerlink" title="针对string"></a>针对string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysplite</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;A,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">inputString</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(inputString)</span></span>;</span><br><span class="line"><span class="built_in">string</span> tmp;</span><br><span class="line"><span class="keyword">while</span>(getline(ss,tmp,ch))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.empty())   <span class="keyword">continue</span>;   </span><br><span class="line">A.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">inputString</span><span class="params">(<span class="string">"/home/fun/./../code/"</span>)</span></span>;</span><br><span class="line">mysplite(inputString,ans,<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=ans.begin();it!=ans.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v, <span class="keyword">const</span> <span class="built_in">string</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>::size_type pos1, pos2;</span><br><span class="line">    pos2 = s.find(c);</span><br><span class="line">    pos1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">string</span>::npos != pos2)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(s.substr(pos1, pos2-pos1));</span><br><span class="line">         </span><br><span class="line">        pos1 = pos2 + c.size();</span><br><span class="line">        pos2 = s.find(c, pos1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos1 != s.length())</span><br><span class="line">        v.push_back(s.substr(pos1));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"a,#b,#c,#d,#e,#f"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">    SplitString(s, v,<span class="string">",#"</span>); <span class="comment">//可按多个字符来分隔;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type i = <span class="number">0</span>; i != v.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出: a b c d e f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p><a href="https://www.cnblogs.com/zwfymqz/p/7800654.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwfymqz/p/7800654.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"><span class="comment">//node是一个结构体</span></span><br><span class="line"><span class="comment">//结构体里重载了‘&lt;’小于符号</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//不需要#include&lt;vector&gt;头文件</span></span><br><span class="line"><span class="comment">//注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><p>结构体的优先队列必须要重载运算符,另外要注意的是：参数列表中的const不能省略，否则报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Time&amp; a,<span class="keyword">const</span> Time&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.start &gt; b.start;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Time&amp; a,<span class="keyword">const</span> Time&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.start &gt; b.start;</span><br><span class="line">&#125;  <span class="comment">//这里以大于重载小于是因为默认情况下，优先队列是以大的作为队首，这样一反，就可以再默认情况下使得小的作为队首</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;Time&gt; q;</span><br></pre></td></tr></table></figure><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q.size();<span class="comment">//返回q里元素个数</span></span><br><span class="line">q.empty();<span class="comment">//返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.push(k);<span class="comment">//在q的末尾插入k</span></span><br><span class="line">q.pop();<span class="comment">//删掉q的第一个元素</span></span><br><span class="line">q.top();<span class="comment">//返回q的第一个元素</span></span><br><span class="line">q.back();<span class="comment">//返回q的末尾元素</span></span><br></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><strong>next_permutation和prev_permutation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;num[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;num[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;num[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(num,num+<span class="number">3</span>));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><p>C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。</p><p>构造函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;4&gt; bitset1;　　<span class="comment">//无参构造，长度为４，默认每一位为０</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bitset</span>&lt;8&gt; bitset2(<span class="number">12</span>);　　<span class="comment">//长度为８，二进制保存，前面用０补充</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"100101"</span>;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;10&gt; bitset3(s);　　<span class="comment">//长度为10，前面用０补充</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> s2[] = <span class="string">"10101"</span>;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;13&gt; bitset4(s2);　　<span class="comment">//长度为13，前面用０补充</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bitset1 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bitset2 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//00001100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bitset3 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0000100101</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bitset4 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0000000010101</span></span><br></pre></td></tr></table></figure><p>常用操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;4&gt; foo (<span class="built_in">string</span>(<span class="string">"1001"</span>));</span><br><span class="line">    <span class="built_in">bitset</span>&lt;4&gt; bar (<span class="built_in">string</span>(<span class="string">"0011"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo^=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 1010 (foo对bar按位异或后赋值给foo)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo&amp;=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 0010 (按位与后赋值给foo)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo|=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 0011 (按位或后赋值给foo)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo&lt;&lt;=<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 1100 (左移２位，低位补０，有自身赋值)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo&gt;&gt;=<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0110 (右移１位，高位补０，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (~bar) &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">// 1100 (按位取反)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (bar&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">// 0110 (左移，不赋值)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (bar&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo==bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// false (0110==0011为false)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo!=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// true  (0110!=0011为true)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo&amp;bar) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0010 (按位与，不赋值)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo|bar) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0111 (按位或，不赋值)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (foo^bar) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0101 (按位异或，不赋值)</span></span><br><span class="line"> <span class="built_in">bitset</span>&lt;4&gt; foo (<span class="string">"1011"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;8&gt; foo (<span class="string">"10011011"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.count() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//5　　（count函数用来求bitset中1的位数，foo中共有５个１</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.size() &lt;&lt; <span class="built_in">endl</span>;　　 <span class="comment">//8　　（size函数用来求bitset的大小，一共有８位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.test(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.test(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//false　　（同理，foo[2]为０，返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.any() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//true　　（any函数检查bitset中是否有１</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.none() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//false　　（none函数检查bitset中是否没有１</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.all() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//false　　（all函数检查bitset中是全部为１</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;8&gt; foo (<span class="string">"10011011"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.flip(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//10011111　　（flip函数传参数时，用于将参数位取反，本行代码将foo下标２处"反转"，即０变１，１变０</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.flip() &lt;&lt; <span class="built_in">endl</span>;　　 <span class="comment">//01100000　　（flip函数不指定参数时，将bitset每一位全部取反</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.<span class="built_in">set</span>() &lt;&lt; <span class="built_in">endl</span>;　　　　<span class="comment">//11111111　　（set函数不指定参数时，将bitset的每一位全部置为１</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.<span class="built_in">set</span>(<span class="number">3</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//11110111　　（set函数指定两位参数时，将第一参数位的元素置为第二参数的值，本行对foo的操作相当于foo[3]=0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.<span class="built_in">set</span>(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;　　  <span class="comment">//11111111　　（set函数只有一个参数时，将参数下标处置为１</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.reset(<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//11101111　　（reset函数传一个参数时将参数下标处置为０</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo.reset() &lt;&lt; <span class="built_in">endl</span>;　　 <span class="comment">//00000000　　（reset函数不传参数时将bitset的每一位全部置为０</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
            <tag> PAT </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-16</title>
      <link href="/2019/02/09/PAT-16/"/>
      <url>/2019/02/09/PAT-16/</url>
      
        <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>prim算法的思想和dijkstra算法很接近。</p><p>不同的是dijkstra算法中 d[]数组记录的是<strong>起始点到各点V的最小距离</strong>，而prim算法中d[]记录的是<strong>顶点V到巨型防护罩S（已经访问顶点集合）的最小距离。</strong></p><p>在代码中，我们可以发现也和dijkstra算法大致相同，只是优化d[v]部分不同，其它相同。</p><p>prim算法适合用于<strong>稠密图（边多）</strong>。</p><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];    <span class="comment">//记录顶点V到已经访问的顶点集合S(巨型防护罩)的最小距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;  <span class="comment">//记录顶点V是否已经加入巨型防护罩S中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,G[maxn][maxn];  <span class="comment">//n顶点数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//s为起始点，可以默认0号顶点为起始点,返回的是最小生成树的权值之和 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//说明剩下的点和集合S不连通</span></span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line">ans+=d[u];     <span class="comment">//把与集合S距离最小的边加入最小生成树 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF&amp;&amp;G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=G[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;   <span class="comment">//返回最小生成树之和 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************邻接表版本</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v; </span><br><span class="line"><span class="keyword">int</span> dis; </span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//说明剩下的点和集合S不连通</span></span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line">ans+=d[u];     <span class="comment">//把与集合S距离最小的边加入最小生成树 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=G[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;   <span class="comment">//返回最小生成树之和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="prim（恶魔大陆）"><a href="#prim（恶魔大陆）" class="headerlink" title="prim（恶魔大陆）"></a>prim（恶魔大陆）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">6 10</span></span><br><span class="line"><span class="comment">0 1 4</span></span><br><span class="line"><span class="comment">0 4 1</span></span><br><span class="line"><span class="comment">0 5 2</span></span><br><span class="line"><span class="comment">1 2 6</span></span><br><span class="line"><span class="comment">1 5 3</span></span><br><span class="line"><span class="comment">2 3 6</span></span><br><span class="line"><span class="comment">2 5 5</span></span><br><span class="line"><span class="comment">3 4 4</span></span><br><span class="line"><span class="comment">3 5 5</span></span><br><span class="line"><span class="comment">4 5 3</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];    <span class="comment">//记录顶点V到已经访问的顶点集合S(巨型防护罩)的最小距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;  <span class="comment">//记录顶点V是否已经加入巨型防护罩S中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,G[maxn][maxn];  <span class="comment">//n顶点数 ,m边数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line">ans+=d[u];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]&amp;&amp;G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=G[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">G[u][v]=w;</span><br><span class="line">G[v][u]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=prim(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h1><p>kruskal算法的思想是：对边贪心，每一次选择图中最小边权的边，如果边两端顶点在不同的连通块中，就把这条边加入最小生成树。</p><p>kruskal算法适合用于稀疏图（边少）</p><p>可以分成以下步骤：</p><ul><li>对所有的边按照边权大小进行排序</li><li>按边权大小从小到大测试所有的边，如果当前测试边所连接的两个顶点不在同一个连通块中，就把这个测试边加入最小生成树中，否则把边舍弃。</li><li>执行上一步，直到最小生成树的边数=总顶点数-1。或者是测试完所有的边之后结束。如果结束的时候最小生成树的边数小于总顶点数-1，说明这个图不连通。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v;   <span class="comment">//边的两个端点</span></span><br><span class="line"><span class="keyword">int</span> cost;  <span class="comment">//边权 </span></span><br><span class="line">&#125;;</span><br><span class="line">edge E[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[maxn];   <span class="comment">//并查集数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//查 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=x;</span><br><span class="line"><span class="keyword">while</span>(x!=father[x])</span><br><span class="line">x=father[x];</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩 </span></span><br><span class="line"><span class="keyword">while</span>(a!=father[a])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> z=a;</span><br><span class="line">a=father[a];</span><br><span class="line">father[z]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span>  <span class="comment">//n为顶点个数，m为边数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,Num_Edge=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">father[i]=i;       <span class="comment">//初始化并查集 </span></span><br><span class="line"></span><br><span class="line">sort(E,E+m,cmp);   <span class="comment">//对边进行排序</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> faU=findFather(E[i].u);</span><br><span class="line"><span class="keyword">int</span> faV=findFather(E[i].v);</span><br><span class="line"><span class="keyword">if</span>(faU!=faV)   <span class="comment">//如果两个端点不在同一个集合中 </span></span><br><span class="line">&#123;</span><br><span class="line">father[faU]=faV ;  <span class="comment">//合并集合(把测试边加入最小生成树中)</span></span><br><span class="line">ans+=E[i].cost;</span><br><span class="line">Num_Edge++;</span><br><span class="line"><span class="keyword">if</span>(Num_Edge==n<span class="number">-1</span>)   <span class="comment">//已经选出了最小生成树 </span></span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Num_Edge!=n<span class="number">-1</span>)   <span class="comment">//无法连通 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">E[i].u=u;</span><br><span class="line">E[i].v=v;</span><br><span class="line">E[i].cost=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=kruskal(n,m);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>常常用于判断是不是有向无环图。</p><p>步骤：</p><ul><li>定义一个队列Q，把所有入度为0的结点加入队列</li><li>取出队首元素，删去由他出发的边，并令这些边到达的顶点入度-1。如果某个顶点的入度为0，则将其加入队列</li><li>反复进行上一步，直到队列为空。此时入过队的结点数目恰好为N，说明拓扑排序成功，这是一个有向无环图，否则失败，证明有环。</li></ul><p>模板:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[maxn];    <span class="comment">//数组用于记录每个点的入度 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[maxn];  <span class="comment">//邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;   <span class="comment">//记录加入拓扑排序序列的顶点数</span></span><br><span class="line"><span class="comment">//priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;    //记录入度为0加入的顶点</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)    <span class="comment">//如果入度为0，加入 </span></span><br><span class="line">&#123;</span><br><span class="line">p.push(i);</span><br><span class="line"><span class="comment">//q.push(i);</span></span><br><span class="line"><span class="comment">//inDegree[i]=-1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=p.top();</span><br><span class="line">p.pop();</span><br><span class="line">path.push_back(u);    <span class="comment">//路径 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=G[u][i];</span><br><span class="line">inDegree[v]--;     <span class="comment">//与u相连接的v点入度-1 </span></span><br><span class="line"><span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p.push(v);</span><br><span class="line"><span class="comment">//q.push(v);</span></span><br><span class="line"><span class="comment">//inDegree[v]=-1;</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">G[u].clear();   <span class="comment">//清除u的所有出边 </span></span><br><span class="line">num++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==n)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line"><span class="keyword">if</span>(v)</span><br><span class="line">&#123;</span><br><span class="line">G[i].push_back(j);</span><br><span class="line">inDegree[j]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(topologicalSort())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=path.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"ERROR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统复习</title>
      <link href="/2019/02/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/02/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><ul><li><p>定义：应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一管理。凡是用户程序要使用资源相关的操作的时候，都必须使用系统调用的方式向操作系统提出服务请求，让操作系统代为完成。这样可以保证操作系统的<strong>稳定性和安全性</strong>，防止非法操作。</p></li><li><p>系统调用的相关处理是运行在核心态的</p></li></ul><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549638817377.png" alt="1549638817377"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549639261246.png" alt="1549639261246"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549639402601.png" alt="1549639402601"></p><h1 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li><p>指令可以分成特权指令和非特权指令。</p></li><li><p>处理器状态又可以分为用户态（目态）和核心态（管态）。</p></li></ul><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549639675755.png" alt="1549639675755"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549639849124.png" alt="1549639849124"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549640058052.png" alt="1549640058052"></p><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549640163559.png" alt="1549640163559"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549640218528.png" alt="1549640218528"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549640485829.png" alt="1549640485829"></p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549983773357.png" alt="1549983773357">                                                      </p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549984283145.png" alt="1549984283145"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549984316595.png" alt="1549984316595"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549984392781.png" alt="1549984392781"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549984481011.png" alt="1549984481011"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549984752241.png" alt="1549984752241"></p><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985006995.png" alt="1549985006995"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985322476.png" alt="1549985322476"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985367173.png" alt="1549985367173"></p><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985667375.png" alt="1549985667375"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985794203.png" alt="1549985794203"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985919103.png" alt="1549985919103"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549986101180.png" alt="1549986101180"></p><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549987068768.png" alt="1549987068768"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549987243343.png" alt="1549987243343"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549987320884.png" alt="1549987320884"></p><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549987364911.png" alt="1549987364911"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550419939212.png" alt="1550419939212"></p><h1 id="引入线程与进程的对比"><a href="#引入线程与进程的对比" class="headerlink" title="引入线程与进程的对比"></a>引入线程与进程的对比</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550420115241.png" alt="1550420115241"></p><h1 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550420252710.png" alt="1550420252710"></p><h1 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h1><h2 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550420433410.png" alt="1550420433410"></p><h2 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550420495659.png" alt="1550420495659"></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550420578345.png" alt="1550420578345"></p><h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><h2 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550420968750.png" alt="1550420968750"></p><h2 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550421046621.png" alt="1550421046621"></p><h2 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h2><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550421105377.png" alt="1550421105377"></p><h1 id="线程总结"><a href="#线程总结" class="headerlink" title="线程总结"></a>线程总结</h1><p><img src="/2019/02/08/操作系统复习/J:/hexo\source\_posts\操作系统复习\%5CUsers%5Cyyyywd%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550421198755.png" alt="1550421198755"></p><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><p><a href="https://blog.csdn.net/weixin_30363263/article/details/80732156" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30363263/article/details/80732156</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-15</title>
      <link href="/2019/02/07/PAT-15/"/>
      <url>/2019/02/07/PAT-15/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>是解决单源最短路径问题。给定G（V,E）和起点s，求从起点s到其他顶点的最短距离。</p><p>dijstra算法基本模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">10000000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxn][maxn]; <span class="comment">//n为结点数，G定义邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[maxn]; <span class="comment">//记录开始点到各点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">//记录这个点是否访问过</span></span><br><span class="line"><span class="keyword">int</span> pre[maxn]; <span class="comment">//记录前驱结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span>    <span class="comment">//s为起始点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF); <span class="comment">//</span></span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//进行n次，分别求出s点到各个点的距离 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF; <span class="comment">//u用来记录每一次的最小值中介点 ,MIN记录最小的值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)   <span class="comment">//说明其他剩下的点和s不连通 </span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;  <span class="comment">//访问u</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)   <span class="comment">//遍历所有节点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];</span><br><span class="line">pre[v]=u; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,dis;  <span class="comment">//v是目标顶点，dis是边权值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//进行n次 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="comment">//说明已经没有点和s连通了 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+Adj[u][j].dis;</span><br><span class="line">pre[v]=u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m; <span class="comment">//边数 </span></span><br><span class="line"><span class="keyword">int</span> s; <span class="comment">//开始点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> v)</span> <span class="comment">//寻找路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==s)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">G[u][v]=w;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为做题不可能出现裸的dijkstra,依据第一标尺肯定会出现多条最短路径，所以要加入第二或者第三标尺判断。有两种办法。</p><ul><li>直接在dijkstra算法里面写</li><li>dijkstra只计算第一标尺，而且计算必须要求的包括最短路径数量和pre前结点。</li></ul><p>第一种的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,M;     <span class="comment">//点数，边数，起点，终点 </span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> w[maxn]=&#123;<span class="number">0</span>&#125;; <span class="comment">//记录s点到各点的最大点权</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn]=&#123;<span class="number">0</span>&#125;;    <span class="comment">//记录各点的点权</span></span><br><span class="line"><span class="keyword">int</span> num[maxn]=&#123;<span class="number">0</span>&#125;; <span class="comment">//记录到各点最短路径的数量 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line">w[s]=weight[s];</span><br><span class="line">num[s]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];</span><br><span class="line">w[v]=w[u]+weight[v];</span><br><span class="line">num[v]=num[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+G[u][v]==d[v])   <span class="comment">//出现多条最短路径的时候 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w[u]+weight[v]&gt;w[v])</span><br><span class="line">&#123;</span><br><span class="line">w[v]=w[u]+weight[v];</span><br><span class="line">&#125;</span><br><span class="line">num[v]+=num[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s,e;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;M&gt;&gt;s&gt;&gt;e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;weight[i]);</span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,w1;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w1);</span><br><span class="line">G[a][b]=w1;</span><br><span class="line">G[b][a]=w1;</span><br><span class="line">&#125; </span><br><span class="line">dijkstra(s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种的模板：</p><p>先是用dijkstra算法根据第一标尺得到一颗最短路径树，再在这颗最短路径树上进行第二第三标尺的计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pre[maxn];   <span class="comment">//记录前驱结点 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn];  </span><br><span class="line"><span class="keyword">int</span> n,m;   <span class="comment">//结点数 边数 </span></span><br><span class="line"><span class="keyword">int</span> st,ed;  <span class="comment">//st为起点，ed为终点 </span></span><br><span class="line"><span class="keyword">int</span> W[maxn];   <span class="comment">//记录 点权值</span></span><br><span class="line"><span class="keyword">int</span> V[maxn][maxn];   <span class="comment">//记录边 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];</span><br><span class="line">pre[v].clear();</span><br><span class="line">pre[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+G[u][v]==d[v])</span><br><span class="line">&#123;</span><br><span class="line">pre[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> optvalue=INF;   <span class="comment">//第二标尺的最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path,tempPath;   <span class="comment">//path为最优路径，tempPath临时路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=tempPath.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> id=tempPath[i];</span><br><span class="line">value+=W[id];    </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Edge_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tempPath.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=tempPath[i],idNext=tempPath[i<span class="number">-1</span>];</span><br><span class="line">value+=V[id][idNext];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span>    <span class="comment">//v为当前访问节点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==st)</span><br><span class="line">&#123;</span><br><span class="line">tempPath.push_back(v);</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;    <span class="comment">//存放临时路径temppath的第二标尺的值</span></span><br><span class="line"><span class="comment">//****** 计算第二标尺的值 </span></span><br><span class="line">value=Edge_val();</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****</span></span><br><span class="line"><span class="keyword">if</span>(value&lt;optvalue)</span><br><span class="line">&#123;</span><br><span class="line">optvalue=value;</span><br><span class="line">path=tempPath;</span><br><span class="line">&#125;</span><br><span class="line">tempPath.pop_back();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">tempPath.push_back(v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre[v].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(pre[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">tempPath.pop_back();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed; </span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[a][b]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V[a][b]);   <span class="comment">//边花费 </span></span><br><span class="line">G[b][a]=G[a][b];</span><br><span class="line">V[b][a]=V[a][b];</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(st);</span><br><span class="line">dfs(ed);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;path.size()&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d[ed]&lt;&lt;<span class="string">" "</span>&lt;&lt;optvalue&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>他可以解决存在负权边的问题。通常使用邻接表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;  <span class="comment">//邻接边的目标顶点 </span></span><br><span class="line"><span class="keyword">int</span> dis;   <span class="comment">//邻接边边权值 </span></span><br><span class="line">node(<span class="keyword">int</span> vv,<span class="keyword">int</span> diss):v(vv),dis(diss)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn]; </span><br><span class="line"><span class="keyword">int</span> n,m,st,ed,weight[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],w[maxn],num[maxn];  <span class="comment">//</span></span><br><span class="line"><span class="comment">//bool vis[maxn]=&#123;false&#125;;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">fill(w,w+maxn,<span class="number">0</span>);</span><br><span class="line">fill(num,num+maxn,<span class="number">0</span>);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line">w[s]=weight[s];</span><br><span class="line">num[s]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解数组d </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)   <span class="comment">//进行n-1轮操作 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每一次都要遍历所有的边 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)       </span><br><span class="line">&#123;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u]+dis&lt;d[v])   <span class="comment">//以u作为中介点能够让v的路径更短 </span></span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+dis;</span><br><span class="line">w[v]=w[u]+weight[v];   <span class="comment">//更新点权</span></span><br><span class="line">num[v]=num[u];</span><br><span class="line">pre[v].clear();</span><br><span class="line">pre[v].insert(u); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis==d[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w[u]+weight[v]&gt;w[v])</span><br><span class="line">&#123;</span><br><span class="line">w[v]=w[u]+weight[v];   <span class="comment">//更新点权</span></span><br><span class="line">&#125;</span><br><span class="line">pre[v].insert(u);</span><br><span class="line">num[v]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=pre[v].begin();it!=pre[v].end();it++)</span><br><span class="line">&#123;</span><br><span class="line">num[v]+=num[*it];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;weight[i];    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v,wt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;wt;</span><br><span class="line">Adj[u].push_back(node(v,wt));</span><br><span class="line">Adj[v].push_back(node(u,wt));</span><br><span class="line">&#125;</span><br><span class="line">Bellman(st);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[ed]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[ed]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><p>SPFA算法是在Bellman-Ford算法的基础上拓展的。利用了只有d[u]改变了，和u所连接的结点v才会改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;  <span class="comment">//邻接边的目标顶点 </span></span><br><span class="line"><span class="keyword">int</span> dis;   <span class="comment">//邻接边边权值 </span></span><br><span class="line">node(<span class="keyword">int</span> vv,<span class="keyword">int</span> diss):v(vv),dis(diss)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn]=&#123;<span class="literal">false</span>&#125;;  <span class="comment">//记录点是否在队列中 </span></span><br><span class="line"><span class="keyword">int</span> n,d[maxn],num[maxn];  <span class="comment">//num记录的是点v进入队列的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">fill(num,num+maxn,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;      <span class="comment">//队列的作用是如果某一点的d改变了，这个点就要加入队列 ，更新与这个点相连接的其他点 </span></span><br><span class="line">Q.push(s);</span><br><span class="line">inq[s]=<span class="literal">true</span>;</span><br><span class="line">num[s]++;</span><br><span class="line">d[s]=<span class="number">0</span>;    </span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=Q.front();   <span class="comment">//u为队首元素</span></span><br><span class="line">Q.pop();</span><br><span class="line">inq[u]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u]+dis&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+dis;</span><br><span class="line"><span class="keyword">if</span>(!inq[v])  <span class="comment">//如果v不在队列中 </span></span><br><span class="line">&#123;</span><br><span class="line">Q.push(v);</span><br><span class="line">num[v]++;</span><br><span class="line">inq[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(num[v]&gt;=n)<span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//有可达负环 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis==d[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里写第二标尺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>Floyd算法是全源最短路径算法。它基于一个这样的思想：如果k作为中介点，使得</p><p>d  [ i ] [ k ]+d  [ k ] [ j ]&lt;d  [ i ] [ j ]，那么就更新d  [ i ] [ j ]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m ;<span class="comment">//点数和边数</span></span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn] ; <span class="comment">//记录的是i到j的最短距离 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)    <span class="comment">//当k作为中介点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果k到i和j都可达且 dis[i][k]+dis[k][j]&lt;dis[i][j]</span></span><br><span class="line"><span class="keyword">if</span>(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])</span><br><span class="line">&#123;</span><br><span class="line">dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-14</title>
      <link href="/2019/02/02/PAT-14/"/>
      <url>/2019/02/02/PAT-14/</url>
      
        <content type="html"><![CDATA[<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;    <span class="comment">//终点编号</span></span><br><span class="line"><span class="keyword">int</span> w;     <span class="comment">//边的权值 </span></span><br><span class="line">Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> ww):v(vv),w(ww)&#123;&#125;  <span class="comment">//构造函数 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Adj[maxn]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><ul><li>连通分量：是针对无向图来说的。</li><li>强连通分量：针对有向图而言，任意两个顶点可以各自通过一条有向路径连通，称之为这两个顶点强连通。</li></ul><h1 id="图的DFS和BFS模板"><a href="#图的DFS和BFS模板" class="headerlink" title="图的DFS和BFS模板"></a>图的DFS和BFS模板</h1><h2 id="图的DFS（邻接矩阵版本）"><a href="#图的DFS（邻接矩阵版本）" class="headerlink" title="图的DFS（邻接矩阵版本）"></a>图的DFS（邻接矩阵版本）</h2><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>有无访问和是否可达这里需要注意！</p><p>这是处理是否有环的关键。如果可以到达但是已经访问过了，说明是有环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];    <span class="comment">//n为最大顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问单个连通分支 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span>  <span class="comment">//u表示当前访问的节点，depth表示当前深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//***********以下中间写对u进行的一些操作，例如打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,u);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来对所有u能够到达的节点进行枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)    <span class="comment">//如果v没有被访问，且u可以到达v </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(v,depth+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrace</span><span class="params">()</span>   <span class="comment">//遍历图 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)   <span class="comment">//访问不同的连通分支 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(u,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的DFS（邻接表版）"><a href="#图的DFS（邻接表版）" class="headerlink" title="图的DFS（邻接表版）"></a>图的DFS（邻接表版）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;    <span class="comment">//终点编号</span></span><br><span class="line"><span class="keyword">int</span> w;     <span class="comment">//边的权值 </span></span><br><span class="line">Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> ww):v(vv),w(ww)&#123;&#125;  <span class="comment">//构造函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Adj[maxv];     <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span>   <span class="comment">//遍历连通分支 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//对u进行的操作写在下面 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][i];     <span class="comment">//如果是node的话，应该写成Adj[u][i].v </span></span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">DFS(v,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrace</span><span class="params">()</span>   <span class="comment">//遍历图 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)   <span class="comment">//访问不同的连通分支 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(u,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的BFS（邻接矩阵）"><a href="#图的BFS（邻接矩阵）" class="headerlink" title="图的BFS（邻接矩阵）"></a>图的BFS（邻接矩阵）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,G[maxn][maxn];    <span class="comment">//n是总的节点数 </span></span><br><span class="line"><span class="keyword">bool</span> inq[maxn]=&#123;<span class="literal">false</span>&#125;;   <span class="comment">//记录是否加入队列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//遍历u所在的连通块 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">inq[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top=q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>；i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inq[i]==<span class="literal">false</span>&amp;&amp;G[top][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">inq[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">bfs(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的BFS（邻接表）"><a href="#图的BFS（邻接表）" class="headerlink" title="图的BFS（邻接表）"></a>图的BFS（邻接表）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Adj[maxn];   <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//顶点数</span></span><br><span class="line"><span class="keyword">bool</span> inq[maxn]=&#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">inq[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;Adj[top].size();v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i=Adj[top][v];</span><br><span class="line"><span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)   <span class="comment">//未曾入队 </span></span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">inq[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">bfs(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-13</title>
      <link href="/2019/02/02/PAT-13/"/>
      <url>/2019/02/02/PAT-13/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一颗完全二叉树，树中的每一个结点的值都不小于（或者说不大于）其左右孩子结点的值，以此来区分最大堆和最小堆。</p><p>以下是堆的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆是一个完全二叉树，因此使用数组来模拟堆</span></span><br><span class="line"><span class="comment">// 第1个结点在数组的第1号位，而且数组的第 i个结点的左孩子结点是在2i号位，右孩子是在2i+1 号位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;<span class="comment">// n是总节点个数 </span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span>  <span class="comment">//low是将要调整结点的数组下标，high一般为堆的最后一个元素的数组下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=low;      <span class="comment">//i是将要调整的结点 </span></span><br><span class="line"><span class="keyword">int</span> j=i*<span class="number">2</span>;    <span class="comment">//j存的是将要调整结点的左孩子的结点 </span></span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)   <span class="comment">//存在孩子结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((j+<span class="number">1</span>&lt;=high) &amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j])  <span class="comment">//存在右孩子，并且右孩子大于左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">j=j+<span class="number">1</span> ;     <span class="comment">//就让j存的是右孩子的结点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过上面那一步，j存放的一定是最大孩子结点</span></span><br><span class="line"><span class="keyword">if</span>(heap[j]&gt;heap[i])</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[i],heap[j]);</span><br><span class="line">i=j;       <span class="comment">//把i设置为将要调整的结点 </span></span><br><span class="line">j=i*<span class="number">2</span>; <span class="comment">//j继续是i的左孩子结点，继续进入循环 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;   <span class="comment">//不满足调整需求，跳出循环 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span>   <span class="comment">//从后往前遍历，从n/2处，刚好是非叶子结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">downAdjust(i,n);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span>   <span class="comment">//删除堆顶元素，要把最后一个元素覆盖在堆顶 ，再向下调整 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[<span class="number">1</span>]=heap[n--];  <span class="comment">//最后一个元素覆盖堆顶 </span></span><br><span class="line">downAdjust(<span class="number">1</span>,n);  <span class="comment">//再向下调整 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=high;<span class="comment">//i是将要调整的结点 </span></span><br><span class="line"><span class="keyword">int</span> j=i/<span class="number">2</span>;<span class="comment">//j是i的父亲节点</span></span><br><span class="line"><span class="keyword">while</span>(j&gt;=low)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(heap[j]&lt;heap[i])<span class="comment">//如果父亲节点小于将要调整的节点</span></span><br><span class="line">&#123;</span><br><span class="line">swap(heap[i],heap[j]);</span><br><span class="line">i=j;   <span class="comment">//i继续变成将要调整的节点 </span></span><br><span class="line">j=i/<span class="number">2</span>;<span class="comment">//j继续是i的父亲节点 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[++n]=x;</span><br><span class="line">upAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序的思想</span></span><br><span class="line"><span class="comment">//把堆顶元素和最后一个元素交换，然后在[1,n-1]的范围内进行downAdjust</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">create();  <span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;heap[i]);</span><br><span class="line">heapSort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==n)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,heap[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,heap[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>哈夫曼树叶子节点×叶子节点到顶点的路径长度=这个叶子节点的带权路径长度。</p><p>一般使用优先队列或者堆来实现。</p><p>每次从优先队列或者堆中取出两个元素，再把其相加的和放回队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ll,<span class="built_in">vector</span>&lt;ll&gt;,greater&lt;ll&gt; &gt;q;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll temp,x,y,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">q.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">y=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">q.push(x+y);</span><br><span class="line">ans+=(x+y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-12</title>
      <link href="/2019/02/01/PAT-12/"/>
      <url>/2019/02/01/PAT-12/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>以下是AVL树的模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;  <span class="comment">//权值</span></span><br><span class="line"><span class="keyword">int</span> height;  <span class="comment">//子树的高度</span></span><br><span class="line">node* lchild;<span class="comment">//左子树 </span></span><br><span class="line">node* rchild; <span class="comment">//右子树 </span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span>    <span class="comment">//建立新的结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node*Node =<span class="keyword">new</span> node;</span><br><span class="line">Node-&gt;v=v;</span><br><span class="line">Node-&gt;height=<span class="number">1</span>;  <span class="comment">//初始高度为1</span></span><br><span class="line">Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node*root)</span>  <span class="comment">//获取当前结点的高度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************基本操作</span></span><br><span class="line"><span class="comment">//1.查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node*root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"search failed!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;v==x)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;v&gt;x)</span><br><span class="line">search(root-&gt;lchild,x);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">search(root-&gt;rchild,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">//L左旋</span></span><br><span class="line"><span class="comment">//让root的右子树的左子树成为root的新的右子树，再让原来root的右子树的左子树指向toot，使得其成为新的root</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node*&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node *temp=root-&gt;rchild;</span><br><span class="line">root-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">temp-&gt;lchild=root;</span><br><span class="line">updateHeight(root);   <span class="comment">//更新高度必须从下往上更新 </span></span><br><span class="line">updateHeight(temp);</span><br><span class="line">root=temp;     <span class="comment">//更新root </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//R 右旋</span></span><br><span class="line"><span class="comment">//同理，先让root的左子树变成root左子树的右子树，再让root的右子树的右子树变成root</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node*temp=root-&gt;lchild;</span><br><span class="line">root-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">temp-&gt;rchild=root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(temp);</span><br><span class="line">root=temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> v)</span>    <span class="comment">//插入 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=newNode(v);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(x&lt;root-&gt;v)</span><br><span class="line">&#123;</span><br><span class="line">insert(root-&gt;lchild,v);</span><br><span class="line">updateHeight(root);<span class="comment">//更新树的高度,因为是递归的原因，所有每一层回溯都会更新树高</span></span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">2</span>)   <span class="comment">//平衡被破坏 </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">1</span>) <span class="comment">//LL型    //判断是哪一种类型的 </span></span><br><span class="line"> &#123;</span><br><span class="line"> R(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">-1</span>)  <span class="comment">//LR型</span></span><br><span class="line">&#123;</span><br><span class="line">L(root-&gt;lchild);<span class="comment">//先转root结点的左结点 ，变成LL型 </span></span><br><span class="line">R(root);<span class="comment">//再转root结点 </span></span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//x大于等于root-&gt;v </span></span><br><span class="line">&#123;</span><br><span class="line">insert(root-&gt;rchild,v);</span><br><span class="line">updateHeight(root);</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">-2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">-1</span>)  <span class="comment">//RR型</span></span><br><span class="line">&#123;</span><br><span class="line">L(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild )==<span class="number">1</span>)   <span class="comment">//RL型 </span></span><br><span class="line">&#123;</span><br><span class="line">R(root-&gt;rchild);</span><br><span class="line">L(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node*root=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">insert(root,data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集模板只有两个操作，一个是查找，一个是合并，很好理解。</p><ul><li>首先一开始都是要初始化，把每一个结点的父节点都设置为自己。</li><li>然后就是查找父节点这个操作</li><li>最后就是通过合并父节点然后合并多个集合这个操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1001</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">bool</span> is_father[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span>   <span class="comment">//初始化，刚开始，每个点的根结点都是自己 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">father[i]=i;</span><br><span class="line">is_father[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> faA=findFather(a);</span><br><span class="line"><span class="keyword">int</span> faB=findFather(b);</span><br><span class="line"><span class="keyword">if</span>(faA!=faB)</span><br><span class="line">father[faA]=faB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//复杂度为O（1）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=x;</span><br><span class="line"><span class="keyword">while</span>(x!=father[x])  <span class="comment">//找到x的根节点 </span></span><br><span class="line">x=father[x];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(a!=father[a])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> z=a;</span><br><span class="line">a=father[a];</span><br><span class="line">father[z]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">init(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">Union(a,b);   <span class="comment">//合并a,b所在的集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;   </span><br><span class="line"><span class="comment">//cout&lt;&lt;findFather[i]&lt;&lt;"   "&lt;&lt;father[i]&lt;&lt;endl;</span></span><br><span class="line">is_father[findFather(i)]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(is_father[i]==<span class="literal">true</span>)</span><br><span class="line">ans++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-11</title>
      <link href="/2019/01/31/PAT-11/"/>
      <url>/2019/01/31/PAT-11/</url>
      
        <content type="html"><![CDATA[<h1 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h1><p>一般来说，树的定义都是使用静态定义。而不是动态的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数据</span></span><br><span class="line"><span class="keyword">int</span> layer;  <span class="comment">//层数 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;   <span class="comment">//记录子节点的编号 </span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>输入的时候也是要注意，输入结点的权值和结点的子节点。</p><h2 id="树的先根序遍历"><a href="#树的先根序遍历" class="headerlink" title="树的先根序遍历"></a>树的先根序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> root)</span><span class="comment">//树的先根序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,Node[root].data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">preOrder(Node[root].child[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(root);</span><br><span class="line">Node[root].layer=<span class="number">0</span>;   <span class="comment">//根结点的层号记录为0 </span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[top].data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[top].child.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">q.push(Node[top].child[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A1053"><a href="#A1053" class="headerlink" title="A1053"></a>A1053</h1><p>使用了dfs进行树的深搜。而bfs一般对于树的广搜.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> layer;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;chird;</span><br><span class="line">&#125;;</span><br><span class="line">node Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Node[a].data&gt;Node[b].data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,S;<span class="comment">// N 结点数，S总和，M 输入的行数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;S;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Node[i].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> No,num;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;No&gt;&gt;num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">Node[No].chird.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">sort(Node[No].chird.begin(),Node[No].chird.end(),cmp);   <span class="comment">//排序 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp,<span class="keyword">int</span> sum)</span>   <span class="comment">//root当前处理的结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sum&gt;S)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum==S)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Node[root].chird.size()!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[temp[i]].data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[temp[i]].data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;S)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].chird.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(Node[root].chird[i]);  </span><br><span class="line"> </span><br><span class="line">dfs(Node[root].chird[i],temp,sum+Node[Node[root].chird[i]].data);   </span><br><span class="line"></span><br><span class="line">temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">input();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t1;</span><br><span class="line">t1.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout&lt;&lt;"-----------"&lt;&lt;endl;</span></span><br><span class="line">dfs(<span class="number">0</span>,t1,Node[<span class="number">0</span>].data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>BST的特点:</p><p>（1）要么二叉搜索树是一颗空树</p><p>（2）要么二叉搜索树由根结点，左子树和右子树组成。左子树和右子树也是二叉搜索树。左子树上的所有结点的数据都小于等于根节点的数据，右子树上的所有结点数都大于根节点的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-10</title>
      <link href="/2019/01/30/PAT-10/"/>
      <url>/2019/01/30/PAT-10/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>树的基本定义：</p><ul><li>如果一棵树没有节点，称为空树。</li><li>树的层次从根节点开始算起，即根节点为第一层。</li><li>把结点的子树棵树称为结点的度，而树中结点的最大度称为树的度。</li><li><strong>对于一个结点树为n的树，其边数一定为n-1（保证了没有环）。并且，如果满足连通，边数等于顶点数-1的结构一定是一棵树。</strong></li><li>叶子节点的度数为0，如果一棵树中只有一个根节点也算是叶子节点。</li><li>结点的深度是指从根节点（深度为1）开始自顶而下逐层累加至该结点时的深度值。结点的高度是指从最底层叶子结点（高度为1）开始自底向上逐层累加至该结点的最高值（最长路径）。对于树而言，深度和高度是相等的。</li><li>森林是多颗树的集合</li></ul><h2 id="几种二叉树的定义"><a href="#几种二叉树的定义" class="headerlink" title="几种二叉树的定义"></a>几种二叉树的定义</h2><h4 id="满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。"><a href="#满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。" class="headerlink" title="满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。"></a>满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。</h4><h4 id="完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。"><a href="#完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。" class="headerlink" title="完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。"></a>完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。</h4><p>完全二叉树的存储结构：</p><p>对于完全二叉树中任意一个节点编号为x，其左节点的编号为2x，右节点的编号为2x+1.  也就是说完全二叉树可以使用一个2的k次方大的数组去存储所有节点的信息，其中K为完全二叉树的最大高度，且1号位必须存储根节点（不使用0号位存储根节点）。这个数组存放顺序刚好为这个完全二叉树的层次遍历顺序。</p><p>重要结论：</p><p>如何判断一个结点有没有叶子节点？</p><p>只需要判断这个结点的左节点2x是否大于总个数n。如果大于总个数n说明没有子结点，那么他就是叶子结点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP-网络编程-1</title>
      <link href="/2019/01/30/TCP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/"/>
      <url>/2019/01/30/TCP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP网络编程的第一天"><a href="#TCP网络编程的第一天" class="headerlink" title="TCP网络编程的第一天"></a>TCP网络编程的第一天</h1><p>总结几个常用的函数</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><h3 id="Linux-下"><a href="#Linux-下" class="headerlink" title="Linux 下"></a>Linux 下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="comment">// domain</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr *myaddr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//成功返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="comment">//path文件的字符串地址</span></span><br><span class="line"><span class="comment">//flag 打开模式</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1；</span></span><br><span class="line"><span class="comment">//fd是要打开的文件描述符</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">//成功返回写入的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">//fd 显示数据传输对象的文件描述符</span></span><br><span class="line"><span class="comment">//buf 写入的数据首地址</span></span><br><span class="line"><span class="comment">// 要写入的数据字节数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// fd  显示数据接收对象的文件描述符</span></span><br><span class="line"><span class="comment">// buf  要保存接受数据的首地址</span></span><br><span class="line"><span class="comment">// nbytes 要接收数据的最大字节数</span></span><br></pre></td></tr></table></figure><h3 id="WINDOWS下"><a href="#WINDOWS下" class="headerlink" title="WINDOWS下"></a>WINDOWS下</h3><p>以下两个函数只是初始化Winsock库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested,LPWSADATA lpWSAData)</span></span>;</span><br><span class="line"><span class="comment">//WORD类型实际是是unsigned short类型（int只取正数）</span></span><br><span class="line"><span class="comment">//wVersionRequested，套接字版本信息，如果是1.2，1代表主版本号，2表示副版本号，应该写成0x0201。经常使用MAKEWORD（1，2）返回值构造。</span></span><br><span class="line"><span class="comment">//LPWSADATA是WSADATA的指针类型，需要传递的是WSADATA结构体的变量地址。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回SOCKET_ERROR。通常只在程序结束的时候调用</span></span><br></pre></td></tr></table></figure><p>接下来介绍和Linux对应的的套接字函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//成功返回句柄，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET s,<span class="keyword">const</span> struct sockaddr* name,<span class="keyword">int</span> namelen)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-9</title>
      <link href="/2019/01/29/PAT-9/"/>
      <url>/2019/01/29/PAT-9/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS入门"><a href="#BFS入门" class="headerlink" title="BFS入门"></a>BFS入门</h1><p>bfs模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">   取出栈顶元素top</span><br><span class="line">        访问栈顶元素</span><br><span class="line">        将栈顶元素弹出栈</span><br><span class="line">        把取出的栈顶元素top下一层节点中未曾入队列入队，并设置入队状态。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> matrix[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=n||x&lt;<span class="number">0</span>||y&gt;=m||y&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(matrix[x][y]==<span class="number">0</span>||inq[x][y]==<span class="literal">true</span>)    <span class="comment">//不可以访问的地方，或者是已经访问过了的地方 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node Node;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;Q;</span><br><span class="line">Node.x=x;</span><br><span class="line">Node.y=y;</span><br><span class="line">Q.push(Node);</span><br><span class="line">inq[x][y]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line">node temp=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> newX=temp.x+X[i];</span><br><span class="line"><span class="keyword">int</span> newY=temp.y+Y[i];</span><br><span class="line"><span class="keyword">if</span>(judge(newX,newY))</span><br><span class="line">&#123;</span><br><span class="line">Node.x=newX;</span><br><span class="line">Node.y=newY;</span><br><span class="line">Q.push(Node);</span><br><span class="line">inq[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;matrix[i][j]);</span><br><span class="line">inq[i][j]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>&amp;&amp;inq[i][j]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">bfs(i,j);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**6 7</span></span><br><span class="line"><span class="comment">0 1 1 1 0 0 1</span></span><br><span class="line"><span class="comment">0 0 1 0 0 0 0</span></span><br><span class="line"><span class="comment">0 0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">0 0 0 1 1 1 0</span></span><br><span class="line"><span class="comment">1 1 1 0 1 0 1</span></span><br><span class="line"><span class="comment">1 1 1 1 0 0 0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//ans=5</span></span><br></pre></td></tr></table></figure><h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p>这里需要注意的是结构体的定义，需要加入一个step记录步数。也可以加入其他元素去记录上一个节点，方便打印出路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> matrix[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">//记录迷宫 </span></span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">105</span>][<span class="number">105</span>]=&#123;<span class="literal">false</span>&#125;;   <span class="comment">//记录是否走过 </span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y; </span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line">node Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=n||x&lt;<span class="number">0</span>||y&gt;=m||y&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(matrix[x][y]==<span class="string">'*'</span>||inq[x][y]==<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">Node.x=x;</span><br><span class="line">Node.y=y;</span><br><span class="line">Node.step=<span class="number">0</span>;</span><br><span class="line">q.push(Node);</span><br><span class="line">inq[x][y]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">node top=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(matrix[top.x][top.y]==<span class="string">'T'</span>)</span><br><span class="line"><span class="keyword">return</span> top.step;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> newX=top.x+X[i];</span><br><span class="line"><span class="keyword">int</span> newY=top.y+Y[i];</span><br><span class="line"><span class="comment">/*if(newX==endx&amp;&amp;newY=endy)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ans++;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">if</span>(judge(newX,newY))</span><br><span class="line">&#123;</span><br><span class="line">Node.x=newX;</span><br><span class="line">Node.y=newY;</span><br><span class="line">Node.step=top.step+<span class="number">1</span>;</span><br><span class="line">q.push(Node);</span><br><span class="line">inq[newX][newY]=<span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> sx,sy;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scanf("%c",&amp;c);</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">matrix[i][j]=c;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'S'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;sx&lt;&lt;" "&lt;&lt;sy&lt;&lt;endl;</span></span><br><span class="line">ans=bfs(sx,sy);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-8</title>
      <link href="/2019/01/28/PAT-8/"/>
      <url>/2019/01/28/PAT-8/</url>
      
        <content type="html"><![CDATA[<h1 id="A1002"><a href="#A1002" class="headerlink" title="A1002"></a>A1002</h1><p>这题实际上是非常简单的一道题，</p><p>主要是从中学会了两个知识点。</p><h2 id="对于map根据value的排序方法，巩固了一下之前学过的内容。"><a href="#对于map根据value的排序方法，巩固了一下之前学过的内容。" class="headerlink" title="对于map根据value的排序方法，巩固了一下之前学过的内容。"></a>对于map根据value的排序方法，巩固了一下之前学过的内容。</h2><p>首先需要创建一个pair的vector，只有将map中的pair放到了vector中才能够用搜sort进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt; test(mp.begin(),mp.end());</span><br></pre></td></tr></table></figure><p>然后写一个cmp函数,注意这里cmp函数的参数是pair。</p><p>pair.first是key，pair.second是value。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.first&gt;b.first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再用sort进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(test.begin(),test.end(),cmp);</span><br></pre></td></tr></table></figure><h2 id="在使用容器的erase删除容器元素的时候需要注意一点。"><a href="#在使用容器的erase删除容器元素的时候需要注意一点。" class="headerlink" title="在使用容器的erase删除容器元素的时候需要注意一点。"></a>在使用容器的erase删除容器元素的时候需要注意一点。</h2><p><strong>注意！erase()的返回值是指向下一个元素的迭代器。如果你在循环中使用erase删除的时候需要特别注意！</strong></p><p>应该写成如下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt;::iterator it=test.begin();it!=test.end();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(it-&gt;second==<span class="number">0</span>)</span><br><span class="line">it=test.erase(it);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上形式是标准形式。</p><p>本题全部代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K1,K2;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; mp;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool cmp(double a, double b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return a&lt;b;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.first&gt;b.first; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;K1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>,&amp;a,&amp;N);</span><br><span class="line">mp[a]+=N; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;K2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K2;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>,&amp;a,&amp;N);</span><br><span class="line">mp[a]+=N; </span><br><span class="line"><span class="comment">/*if(mp[a]==0)可以在这里就直接删除了 </span></span><br><span class="line"><span class="comment">mp.erase(a);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt; test(mp.begin(),mp.end());</span><br><span class="line">sort(test.begin(),test.end(),cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt;::iterator it=test.begin();it!=test.end();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(it-&gt;second==<span class="number">0</span>)</span><br><span class="line">it=test.erase(it);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">it++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d %0.1lf"</span>,test[i].first,test[i].second);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>由于自己的懒惰，所以今天没怎么学习。现在补上。</p><p>看着思路做了一道模板题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">101</span>]; </span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> W,<span class="keyword">int</span> V)</span>   <span class="comment">//index是指当前处理的物品，W是指背包剩余容量 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(W&lt;<span class="number">0</span>)<span class="comment">//剪枝操作 </span></span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">if</span>(index==N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(maxn&lt;V&amp;&amp;W&gt;=<span class="number">0</span>)</span><br><span class="line">maxn=V;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(W&lt;w[index])</span></span><br><span class="line">dfs(index+<span class="number">1</span>,W,V);   <span class="comment">//处理当前物品 </span></span><br><span class="line"></span><br><span class="line">dfs(index+<span class="number">1</span>,W-w[index],V+c[index]);   <span class="comment">//不处理当前物品。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;V;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">dfs(<span class="number">0</span>,V,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归入门—-全排列"><a href="#递归入门—-全排列" class="headerlink" title="递归入门—-全排列"></a>递归入门—-全排列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> is_use[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t1.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=t1.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(is_use[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">is_use[i]=<span class="number">1</span>;</span><br><span class="line">t1.push_back(i);</span><br><span class="line">dfs(index+<span class="number">1</span>,t1);</span><br><span class="line">t1.pop_back();</span><br><span class="line">is_use[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">dfs(<span class="number">0</span>,temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归入门—组合的输出"><a href="#递归入门—组合的输出" class="headerlink" title="递归入门—组合的输出"></a>递归入门—组合的输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">25</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t1)</span>   <span class="comment">//n1存储当前已经用了的数字个数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//if(t1.size()&gt;=2&amp;&amp;t1[t1.size()-1]&lt;t1[t1.size()-2])   //后一位一定比前一位大 ，以这个为条件可以判断 </span></span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line"><span class="keyword">if</span>(n1==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t1.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=t1.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(t1.size()!=<span class="number">0</span>)</span><br><span class="line">start=t1[t1.size()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]==<span class="number">0</span>)  <span class="comment">//没有用过这个数字 </span></span><br><span class="line">&#123;</span><br><span class="line">num[i]=<span class="number">1</span>;</span><br><span class="line">t1.push_back(i);</span><br><span class="line">dfs(n1+<span class="number">1</span>,t1);</span><br><span class="line">t1.pop_back();</span><br><span class="line">num[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r;</span><br><span class="line"><span class="comment">//count=</span></span><br><span class="line">dfs(<span class="number">0</span>,temp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合-判断素数"><a href="#组合-判断素数" class="headerlink" title="组合+判断素数"></a>组合+判断素数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; temp;</span><br><span class="line">ll num[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll count1=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;ll&gt;t1)</span> <span class="comment">//dfs的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==k)</span><br><span class="line">&#123;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;t1.size();i++)</span><br><span class="line">sum+=num[t1[i]];</span><br><span class="line"><span class="keyword">if</span>(is_prime(sum))</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(t1.size()!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">start=t1[t1.size()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=start;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=<span class="number">1</span>;</span><br><span class="line">t1.push_back(i);</span><br><span class="line">dfs(index+<span class="number">1</span>,t1);</span><br><span class="line">t1.pop_back();</span><br><span class="line">p[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">dfs(<span class="number">0</span>,temp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> count1;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp)</span>   <span class="comment">//index 表示处理到第index行，temp保存 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;index&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,temp[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,temp[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//为行选列 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="number">0</span>)  <span class="comment">//没有用过 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.size();j++)<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;abs(j+1-index)&lt;&lt;" "&lt;&lt;abs(temp[j]-i)&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(j+<span class="number">1</span>-index)==<span class="built_in">abs</span>(temp[j]-i))  <span class="comment">//对角线 </span></span><br><span class="line">&#123;</span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=<span class="number">1</span>;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">dfs(index+<span class="number">1</span>,temp);</span><br><span class="line">temp.pop_back();</span><br><span class="line">p[i]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="comment">//for(int i=0;i&lt;)</span></span><br><span class="line">dfs(<span class="number">1</span>,ans);</span><br><span class="line"><span class="keyword">if</span>(count1==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"no solute!"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                                </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-7</title>
      <link href="/2019/01/27/PAT-7/"/>
      <url>/2019/01/27/PAT-7/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列的使用"><a href="#栈和队列的使用" class="headerlink" title="栈和队列的使用"></a>栈和队列的使用</h1><h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><p>这题没有括号的约束。</p><p><strong>主要思路：</strong></p><ul><li>最重要的一点！将中缀表达式变化成后缀表达式</li><li>对于符号的优先级处理，如果当前字符串的符号优先级<strong>大于</strong>符号栈顶的符号优先级，就把当前符号压入符号栈。1</li><li>如果当前字符的符号优先级<strong>小于等于</strong>符号栈顶的符号优先级，一直将符号栈里的符号弹出到后缀表达式中直到栈顶符号优先级大于当前符号优先级。<strong>最后将当前字符符号压入符号栈。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> num;<span class="comment">//操作数</span></span><br><span class="line"><span class="keyword">char</span> op ;<span class="comment">// 操作符</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">//true表示操作数</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">stack</span>&lt;node&gt; sta1;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que1;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i++]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.length()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.num=temp.num*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">que1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//如果当前操作符的优先级小于栈顶操作符优先级 就不断的把栈顶的弹出来， </span></span><br><span class="line"><span class="keyword">while</span>(!sta1.empty()&amp;&amp;mp[sta1.top().op]&gt;=mp[str[i]])</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node cur,temp;</span><br><span class="line"><span class="keyword">while</span>(!que1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=que1.front();</span><br><span class="line">que1.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.flag==<span class="literal">true</span>)</span><br><span class="line">sta1.push(cur);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp2=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line">temp1=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line"></span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cur.op==<span class="string">'+'</span>)temp.num=temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'-'</span>)temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'*'</span>)temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp.num=temp1/temp2;</span><br><span class="line">sta1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sta1.top().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp[<span class="string">'+'</span>]=mp[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">mp[<span class="string">'*'</span>]=mp[<span class="string">'/'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str),str!=<span class="string">"0"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>)</span><br><span class="line">str.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">deal();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,cal());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂计算器"><a href="#复杂计算器" class="headerlink" title="复杂计算器"></a>复杂计算器</h2><p>这题有了括号的约束，但是总体思路不变，在简单计算器的基础上只加入了一段代码即可。</p><p>主要思路：</p><ul><li>当碰到表达式中的左括号’(‘时候，需要将其压入栈中</li><li>碰到右括号的时候，一直将符号栈中的栈顶符号弹出到后缀表达式，直到碰到左括号。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(sta1.top().op!=<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">sta1.pop();</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------</span></span><br></pre></td></tr></table></figure><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> num;<span class="comment">//操作数</span></span><br><span class="line"><span class="keyword">char</span> op ;<span class="comment">// 操作符</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">//true表示操作数</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">stack</span>&lt;node&gt; sta1;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que1;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i++]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.length()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.num=temp.num*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">que1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(sta1.top().op!=<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">sta1.pop();</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">//如果当前操作符的优先级小于栈顶操作符优先级 就不断的把栈顶的弹出来， </span></span><br><span class="line"><span class="keyword">while</span>(!sta1.empty()&amp;&amp;mp[sta1.top().op]&gt;=mp[str[i]])</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node cur,temp;</span><br><span class="line"><span class="keyword">while</span>(!que1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=que1.front();</span><br><span class="line">que1.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.flag==<span class="literal">true</span>)</span><br><span class="line">sta1.push(cur);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp2=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line">temp1=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line"></span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cur.op==<span class="string">'+'</span>)temp.num=temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'-'</span>)temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'*'</span>)temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp.num=temp1/temp2;</span><br><span class="line">sta1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sta1.top().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp[<span class="string">'+'</span>]=mp[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">mp[<span class="string">'*'</span>]=mp[<span class="string">'/'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str),str!=<span class="string">"0"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>)</span><br><span class="line">str.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">deal();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,cal());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 第7章 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-6</title>
      <link href="/2019/01/26/PAT-6/"/>
      <url>/2019/01/26/PAT-6/</url>
      
        <content type="html"><![CDATA[<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>队列中的元素访问只能通过front()访问队首元素，back()访问队尾元素。队列是一种先进先出的容器。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>(1)push(x)把x加入队列</p><p>(2)front(),back()访问队首元素和队尾元素</p><p>(3)pop()让队首元素出队</p><p>(4)empty()判断queue是否为空，为空返回true，不为空返回false</p><p>(5)size()返回队列里面元素个数</p><h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><p>（1）BFS的时候会用到</p><p>（2）注意在front（）和pop（）使用之前，必须用empty（）判断队列是否为空。</p><h2 id="例题A1056-Mice-and-Rice"><a href="#例题A1056-Mice-and-Rice" class="headerlink" title="例题A1056 Mice and Rice"></a>例题A1056 Mice and Rice</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Np,Ng;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> rank;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">mice all[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Np,&amp;Ng);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Np;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;all[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Np;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;order);</span><br><span class="line">q.push(order);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp=Np,group;  <span class="comment">//temp为当前轮的老鼠总数,group是当前轮的组数</span></span><br><span class="line"><span class="keyword">while</span>(q.size()!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp%Ng==<span class="number">0</span>)</span><br><span class="line">group=temp/Ng;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">group=temp/Ng+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;group;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k=q.front();     <span class="comment">//记录当前组最大老鼠的编号 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Ng;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i*Ng+j&gt;=temp)   <span class="comment">//不足NG，退出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> front=q.front();</span><br><span class="line"><span class="keyword">if</span>(all[front].w&gt;all[k].w)</span><br><span class="line">k=front;</span><br><span class="line">all[front].rank=group+<span class="number">1</span>;</span><br><span class="line">q.pop(); </span><br><span class="line">&#125;</span><br><span class="line">q.push(k);   <span class="comment">//胜利的一组老鼠又推回队列 </span></span><br><span class="line">&#125;</span><br><span class="line">temp=group;</span><br><span class="line">&#125; </span><br><span class="line">all[q.front()].rank=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Np;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,all[i].rank);</span><br><span class="line"><span class="keyword">if</span>(i&lt;Np<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h1><p>优先队列底层是用堆实现的。在优先队列中，队首元素一定是当前队列中优先级最高的元素（注意！并不是说整个队列是有序的！）</p><h2 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h2><p>优先队列和队列的不同在于优先队列没有front()和back(),只能通过top()函数来访问队首元素（也叫做堆顶元素），即优先级最高的元素。</p><h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><p>(1)push(x)将x入队，时间复杂度为O(logN)</p><p>(2)top()获取堆顶元素</p><p>(3)pop()堆顶元素出队，时间复杂度为O(logN)</p><p>(4)empty()判断队列是否为空。</p><p>(5)size()返回队内元素总数。时间复杂度为O(1)。</p><h2 id="结构体优先级的设置"><a href="#结构体优先级的设置" class="headerlink" title="结构体优先级的设置"></a>结构体优先级的设置</h2><h3 id="最大堆和最小堆的设置"><a href="#最大堆和最小堆的设置" class="headerlink" title="最大堆和最小堆的设置"></a>最大堆和最小堆的设置</h3><p>less<int>表示数字大的优先级大，greater<int>表示数字小的优先级大</int></int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;maxn_q;<span class="comment">//最大堆,等价于priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;minn_q1;<span class="comment">//最小堆</span></span><br></pre></td></tr></table></figure><h3 id="优先级的设置需要重载运算符"><a href="#优先级的设置需要重载运算符" class="headerlink" title="优先级的设置需要重载运算符"></a>优先级的设置需要重载运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price&lt;f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="另一种写法"><a href="#另一种写法" class="headerlink" title="另一种写法"></a>另一种写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price&lt;f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue&lt;fruit,<span class="built_in">vector</span>&lt;fruit&gt;,cmp &gt;q;</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>一种后进先出的容器，只能通过top（）访问。</p><h2 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h2><p>(1)push(x)将x入栈，时间复杂度为O(1)</p><p>(2)top()获取栈顶元素，时间复杂度为O(1)</p><p>(3)pop()栈顶元素出队，时间复杂度为O(1)</p><p>(4)empty()判断队列是否为空，时间复杂度为O(1)</p><p>(5)size()返回队内元素总数。时间复杂度为O(1)。</p><h2 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a>常见用途</h2><p>模拟递归</p><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>可以将两个元素绑定在一起作为合成元素。可以看成是内部有两个元素的结构体。</p><p>使用pair的时候，应该先添加头文件#include<utility> ,写#include<map>可以包括它。</map></utility></p><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p(<span class="string">"hhhh"</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p=make_pair(<span class="string">"aaaa"</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较方式"><a href="#比较方式" class="headerlink" title="比较方式"></a>比较方式</h2><p>可以直接用==，！=，&lt;,&gt;等符号比较大小。比较规则是先以first的大小作为标准，只有first相等了才去比较second。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>（1）代替二元struct</p><p>（2）作为map的键值对插入</p><h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="reverse-it1-it2"><a href="#reverse-it1-it2" class="headerlink" title="reverse(it1,it2)"></a>reverse(it1,it2)</h2><p>将数组指针或者容器迭代器在[it1,it2)范围内的元素进行反转</p><h2 id="next-permutation-a-a-len"><a href="#next-permutation-a-a-len" class="headerlink" title="next_permutation(a,a+len)"></a>next_permutation(a,a+len)</h2><p>给出一个序列在全排列中的下一个序列</p><h2 id="fill-a-a-len-value"><a href="#fill-a-a-len-value" class="headerlink" title="fill(a,a+len,value)"></a>fill(a,a+len,value)</h2><p>填充数据。</p><h2 id="sort-首元素地址，尾元素地址的下一个地址，比较函数（非必填）"><a href="#sort-首元素地址，尾元素地址的下一个地址，比较函数（非必填）" class="headerlink" title="sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填）)"></a>sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填）)</h2><h2 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h2><p>lower_bound(first,last,val)用来查找在数组或者容器[first,last)范围内<strong>第一个值小于等于</strong>val的元素的位置，返回的是这个位置的<strong>指针</strong>。如果是容器，则返回这个位置的<strong>迭代器</strong>。</p><p>upper_bound(first,last,val)用来查找在数组或者容器[first,last)范围内<strong>第一个值大于</strong>val的元素的位置，返回的是这个位置的<strong>指针</strong>，如果是容器，则返回这个位置的<strong>迭代器</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-5</title>
      <link href="/2019/01/25/PAT-5/"/>
      <url>/2019/01/25/PAT-5/</url>
      
        <content type="html"><![CDATA[<h1 id="STL（一）"><a href="#STL（一）" class="headerlink" title="STL（一）"></a>STL（一）</h1><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ul><li><p>（1）用于存储数据</p></li><li><p>（2）用邻接表存储图</p></li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="push-back-x"><a href="#push-back-x" class="headerlink" title="push_back(x)"></a>push_back(x)</h3><p>在vector后面添加一个元素</p><h3 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back()"></a>pop_back()</h3><p>在vector后面删除一个元素</p><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>计算vector的长度</p><h3 id="clear（）"><a href="#clear（）" class="headerlink" title="clear（）"></a>clear（）</h3><p>清除vector</p><h3 id="insert（it，x）"><a href="#insert（it，x）" class="headerlink" title="insert（it，x）"></a>insert（it，x）</h3><p>it是迭代器，在it位置插入一个元素x</p><h3 id="erase有两种用法"><a href="#erase有两种用法" class="headerlink" title="erase有两种用法"></a>erase有两种用法</h3><ul><li>erase(it) 删除迭代器it处的元素</li><li>erase(first,last) 删除[first,last)之间的元素，注意左闭右开</li></ul><h1 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h1><ul><li><p>set是一个内部自动有序且不含重复元素的容器。</p></li><li><p>set只能够通过迭代器访问内部元素。但不能通过*（it+i）的方式访问。</p></li></ul><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p>insert(x)</p></li><li><p>find(value)：返回的是迭代器</p></li><li><p>erase():</p><p>两种用法:(1)删除单个元素：set.erase(it) —-删除迭代器位置的元素    set.erase(value)—–删除值为value的元素 (2)删除区间元素：set.erase(first,last),first和last都是迭代器。注意还是左闭右开原则[first,last)</p></li><li><p>size()获取set的长度</p></li><li><p>clear清空set</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4></li><li><p>insert(pos,string) ，在pos处插入string</p></li><li>insert(it,it2,it3)，it是被插入字符串1的迭代器位置，it2和it3是即将插入字符串2的迭代器位置。把字符串2的[it2,it3)插入字符串1it处</li><li>erase(it)，删除单个元素</li><li>erase(pos,length),pos为需要删除的起始位置，length为删除的字符个数</li><li>substr(pos,len)，用于截取字符串,从pos位置开始，截取长度为len的字符串</li><li>find() str.find(str2)，当str2是str的字串的时候，返回其在str中第一次出现的位置。时间复杂度为O（nm)</li><li><p>replace(pos,len,str2) </p><p>把str1中的字符串从pos开始，到pos+len变成str2.即使len&lt;str2.length(),也可以成功添加，相当于是把pos到pos+len的字符串清空，str2从pos开始填充。</p></li><li><p>replace(it1,it2,str2) 类似。相当于把str1在it1和it2之间清空，变成str2.</p><h3 id="A1060"><a href="#A1060" class="headerlink" title="A1060"></a>A1060</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">// s的下标 </span></span><br><span class="line"><span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'0'</span>)<span class="comment">//去掉前导零 </span></span><br><span class="line">s.erase(s.begin());       </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'.'</span>)     <span class="comment">//说明s是小于1的小数 </span></span><br><span class="line">&#123;</span><br><span class="line">s.erase(s.begin());</span><br><span class="line"><span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.erase(s.begin());</span><br><span class="line">e--;<span class="comment">//e为指数 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(k&lt;s.length()&amp;&amp;s[k]!=<span class="string">'.'</span>)</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">e++;   <span class="comment">//只要不碰到小数点就让指数e++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k&lt;s.length())</span><br><span class="line">&#123;</span><br><span class="line">s.erase(s.begin()+k);<span class="comment">//删除小数点 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(s.length()==<span class="number">0</span>)   <span class="comment">//去除前导0之后长度变为0，说明这个数是0 </span></span><br><span class="line">&#123;</span><br><span class="line">e=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="keyword">while</span>(num&lt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;s.length())res+=s[k++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res+=<span class="string">'0'</span>;    <span class="comment">//补0</span></span><br><span class="line">num++;<span class="comment">// 精度+1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">int</span> e1=<span class="number">0</span>,e2=<span class="number">0</span>;</span><br><span class="line">s3=deal(s1,e1);</span><br><span class="line">s4=deal(s2,e2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s3==s4&amp;&amp;e1==e2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES 0."</span>&lt;&lt;s3&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"0."</span>&lt;&lt;s3&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e1&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"0."</span>&lt;&lt;s4&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器），map中的键是唯一的！map中是使用红黑树实现的，key会像set那样从小到大排序。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>map&lt;key,value&gt;</p><h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><p>(1)通过类似于下标的方式访问，例如定义了map&lt;char,int&gt;,可以使用mp[‘c’]的方式访问。</p><p>(2)通过迭代器的方式访问。</p><p>定义map&lt;typename1,typename2&gt;::iterator it;</p><p><strong>使用it-&gt;first来访问key，it-&gt;second访问value. </strong></p><h2 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h2><p>（1）find（key）返回键为key的迭代器，时间复杂度为O(logN)</p><p>（2） 删除单个元素erase(it)或者erase(key)</p><p>​      删除多个元素 erase(first,last) ,[first,last) first和last都是<strong>迭代器</strong></p><p>（3）size（）返回映射的对数</p><p>（4） clear（）清除map</p><h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><ul><li>需要建立字符或者字符串到整数之间的映射题目</li><li>判断大整数或者其他类型数据是否存在，可以把map当成bool数组用</li><li>字符串和字符串之间的映射</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-4</title>
      <link href="/2019/01/24/PAT-4/"/>
      <url>/2019/01/24/PAT-4/</url>
      
        <content type="html"><![CDATA[<h1 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h1><p>求N的质因数。根据下列公式：</p><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\zhishu.png" alt=""></p><p>也是必须用素数打表，然后计算。p表示质因数，a表示指数。</p><p>例如：    </p><p>​            180=2^2 <em> 3^2 </em> 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;; <span class="comment">//  false表示是质数</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> pnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">factor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;      <span class="comment">//质因子</span></span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">//  质因子个数</span></span><br><span class="line">&#125;;</span><br><span class="line">factor fac[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[pnum++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    find_prime();</span><br><span class="line">    <span class="comment">/*for(int i=0;i&lt;100;i++)</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;p[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;*/</span></span><br><span class="line">    <span class="keyword">int</span> n,num=<span class="number">0</span>;  <span class="comment">//num为n的不同的质因子的个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1=1"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d="</span>,n);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n*<span class="number">1.0</span>);  <span class="comment">//根号n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pnum&amp;&amp;prime[i]&lt;=sqr;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fac[num].x=prime[i];</span><br><span class="line">                fac[num].cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fac[num].cnt++;</span><br><span class="line">                    n/=prime[i];               </span><br><span class="line">                &#125;              </span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)    <span class="comment">//说明无法被根号n以内的质因子除尽</span></span><br><span class="line">    &#123;</span><br><span class="line">        fac[num].x=n;</span><br><span class="line">        fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照格式输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,fac[i].x);</span><br><span class="line">        <span class="keyword">if</span>(fac[i].cnt&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"^%d"</span>,fac[i].cnt);  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>约数是在素数的基础上解决的问题。</p><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\zhishu.png" alt=""></p><p>N为输入的数，d(N)表示N的约数的个数。</p><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\yuanshu-gongshi.png" alt=""></p><p>一般先通过线性筛把素数表打出来，再根据得到的质因数指数再使用一次线性筛计算出约数的个数。</p><p><a href="https://blog.csdn.net/ControlBear/article/details/77527115" target="_blank" rel="noopener">https://blog.csdn.net/ControlBear/article/details/77527115</a></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>这里我没有用约数个数筛，只是用了素数筛。嘻嘻，因为我不会。</p><p>原来cout真的比printf慢好多。。。用cout超时，用printf过了。</p><p><a href="http://codeup.cn/problem.php?cid=100000592&amp;pid=3" target="_blank" rel="noopener">http://codeup.cn/problem.php?cid=100000592&amp;pid=3</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;; <span class="comment">//  false表示是质数</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> pnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">factor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;      <span class="comment">//质因子</span></span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">//  质因子个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[pnum++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">find_prime();</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> temp=<span class="number">0</span>;temp&lt;N;temp++)  <span class="comment">//输入 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[temp]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n=A[i];</span><br><span class="line">factor fac[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pnum&amp;&amp;prime[i]&lt;=sqr;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fac[num].x=prime[i];</span><br><span class="line">fac[num].cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fac[num].cnt++;</span><br><span class="line">n/=prime[i];</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fac[num].x=n;</span><br><span class="line">fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;num;t++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sum*=(fac[t].cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);<span class="comment">//sum&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h1><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\yuanshu-sum.png" alt=""></p><h1 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h1><p>一般来说，要这样定义大整数结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bign</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">bign()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">len=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>高精度加法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span>  <span class="comment">//高精度加法 ,只能处理两个正数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bign c;</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;  <span class="comment">//控制进位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">carry=temp/<span class="number">10</span>; <span class="comment">//是否进位 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(carry!=<span class="number">0</span>)<span class="comment">//最后是否进位 </span></span><br><span class="line">&#123;</span><br><span class="line">c.d[c.len++]=carry;</span><br><span class="line">&#125;</span><br><span class="line">reverse(c.d,c.d+c.len);<span class="comment">//逆序 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>高精度减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span>  <span class="comment">//高精度减法！！注意！计算之前要用，compare函数比较大小. </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bign c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a.d[i]&lt;b.d[i])</span><br><span class="line">&#123;</span><br><span class="line">a.d[i+<span class="number">1</span>]--;</span><br><span class="line">a.d[i]+=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">c.d[c.len++]=a.d[i]-b.d[i];  <span class="comment">//减法结果为当前位结果 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)  <span class="comment">//去掉高位0 </span></span><br><span class="line">c.len--;</span><br><span class="line"></span><br><span class="line">reverse(c.d,c.d+c.len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>高精度和低精度混合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span>   <span class="comment">//低精度与高精度乘法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bign c;</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a.d[i]*b+carry;  </span><br><span class="line">c.d[c.len++]=temp%<span class="number">10</span>;     <span class="comment">//取temp的个位作为当前位</span></span><br><span class="line">carry=temp/<span class="number">10</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(carry!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c.d[c.len++]=carry%<span class="number">10</span>;<span class="comment">//取最右边一位</span></span><br><span class="line">carry/=<span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse(c.d,c.d+c.len);<span class="comment">//需要把C的d数组逆转</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>高精度和低精度混合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)</span>  <span class="comment">// r为余数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">bign c;</span><br><span class="line">c.len=a.len;   <span class="comment">//商的位数和被除数位数一一对应</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line"><span class="keyword">if</span>(r&lt;b)<span class="comment">//不够除的情况 </span></span><br><span class="line">c.d[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">c.d[i]=r/b;</span><br><span class="line">r=r%b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;c.len<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">c.len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合数的计算"><a href="#组合数的计算" class="headerlink" title="组合数的计算"></a>组合数的计算</h1><p><strong>核心</strong>：</p><ul><li><p><strong>C（i,j）=C(i-1,j)+C(i-1,j-1)</strong></p></li><li><p><strong>采用变形式</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 n!的质因子p的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">ans+=n/p;</span><br><span class="line">n/=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">ll res[<span class="number">67</span>][<span class="number">67</span>];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> <span class="comment">//用递推公式计算的 ，递归算法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>||m==n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>)<span class="keyword">return</span> res[n][m]; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res[n][m]=C(n<span class="number">-1</span>,m)+C(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整张表一起计算出来</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n1=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calC</span><span class="params">()</span>   <span class="comment">//非递归 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n1;i++)</span><br><span class="line">&#123;</span><br><span class="line">res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;  <span class="comment">//初始化边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">res[i][j]=res[i<span class="number">-1</span>][j]+res[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">res[i][i-j]=res[i][j];<span class="comment">//对称 ,C(i,j)=C(i,i-j)</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*---变形式--*/</span></span><br><span class="line"><span class="function">ll <span class="title">C1</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ans=ans*(n-m+i)/i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">calC();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;C1(n,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-3</title>
      <link href="/2019/01/23/PAT-3/"/>
      <url>/2019/01/23/PAT-3/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp)right--;</span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=Partition(A,left,right);</span><br><span class="line">quickSort(A,left,pos);<span class="comment">//对左边区间递归 </span></span><br><span class="line">quickSort(A,pos+<span class="number">1</span>,right);<span class="comment">//对右边区间递归 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=(round(<span class="number">1.0</span>*rand()/RAND_MAX*(right-left))+left);  <span class="comment">//算出一个随机的位置index  P</span></span><br><span class="line">swap(A[p],A[left]);   <span class="comment">//把p的位置和left交换</span></span><br><span class="line"><span class="comment">//  以下和 Partition一样 </span></span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&lt;temp)right--;   <span class="comment">//注意，是按照从大到小排序还是从小到大排序 </span></span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&gt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选取第K大的数"><a href="#选取第K大的数" class="headerlink" title="选取第K大的数"></a>选取第K大的数</h1><p>这里利用了快排划分的思想。注意是按照从大到小排序还是从小到大排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp)right--;</span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=(round(<span class="number">1.0</span>*rand()/RAND_MAX*(right-left))+left);  <span class="comment">//算出一个随机的位置index  P</span></span><br><span class="line">swap(A[p],A[left]);   <span class="comment">//把p的位置和left交换</span></span><br><span class="line"><span class="comment">//  以下和 Partition一样 </span></span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&lt;temp)right--;   <span class="comment">//注意，是按照从大到小排序还是从小到大排序 </span></span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&gt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=Partition(A,left,right);</span><br><span class="line">quickSort(A,left,pos<span class="number">-1</span>);<span class="comment">//对左边区间递归 </span></span><br><span class="line">quickSort(A,pos+<span class="number">1</span>,right);<span class="comment">//对右边区间递归 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> K)</span>  <span class="comment">//返回第K大的数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)</span><br><span class="line"><span class="keyword">return</span> A[left];  <span class="comment">//边界？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P=randPartition(A,left,right);</span><br><span class="line"><span class="keyword">int</span> M=P-left+<span class="number">1</span>;  <span class="comment">//返回的P是第M大的元素</span></span><br><span class="line"><span class="keyword">if</span>(K==M)</span><br><span class="line"><span class="keyword">return</span> A[P];</span><br><span class="line"><span class="keyword">if</span>(K&lt;M)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> randSelect(A,left,P<span class="number">-1</span>,K);   <span class="comment">//往左边收缩，找到第K大的元素</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> randSelect(A,P+<span class="number">1</span>,right,K-M);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum1=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;randSelect(A,<span class="number">0</span>,m<span class="number">-1</span>,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/gcd(a,b) *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;gcd(<span class="number">33</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>素数的题目一般采用打表的方式去做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> Prime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;;  <span class="comment">//是素数就是false,默认为false </span></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">()</span>  <span class="comment">//埃式筛法(时间复杂度是O(nloglogn) 空间复杂度是O(n)) </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"ii";</span></span><br><span class="line">Prime[num++]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">&#123;</span><br><span class="line">p[j]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Find_Prime();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Prime[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-2</title>
      <link href="/2019/01/22/PAT-2/"/>
      <url>/2019/01/22/PAT-2/</url>
      
        <content type="html"><![CDATA[<h1 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>对于贪心的理解，大概就是每一步都选取最优的解，对问题进行排序是很重要的部分！</p><h3 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h3><p>  给出N个开区间(x,y)，选择尽可能多的区间，使得这些开区间两两之间没有交集。输出这些区间的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qujian</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Qujian a,Qujian b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x!=b.x)</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;   <span class="comment">//如果左端点不同，按照区间的左端点从大到小排序 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;<span class="comment">//  左端点相同，按照区间的右端点从小到大排序 </span></span><br><span class="line">&#125;</span><br><span class="line">Qujian A[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;A[i].x,&amp;A[i].y);</span><br><span class="line">&#125;</span><br><span class="line">sort(A,A+N,cmp);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>; <span class="keyword">int</span> lastX=A[<span class="number">0</span>].x;    <span class="comment">//选取排序后第一个区间，并且记录下该区间的左端点</span></span><br><span class="line"><span class="comment">//lastX是记录上一个选取区间的左端点 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i].y&lt;=lastX)        <span class="comment">//如果某一区间的右端点小于等于上一个选取区间的左端点，说明其不相交 </span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">lastX=A[i].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;oo</span><br></pre></td></tr></table></figure><h3 id="题目2："><a href="#题目2：" class="headerlink" title="题目2："></a>题目2：</h3><p>给出N个闭区间[x,y],求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点。思路和上一题一样，先是需要对区间根据从左端点的大小进行排序，然后选择满足条件的左端点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qujian</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Qujian a,Qujian b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x!=b.x)</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;   <span class="comment">//如果左端点不同，按照区间的左端点从大到小排序 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;<span class="comment">//  左端点相同，按照区间的右端点从小到大排序 </span></span><br><span class="line">&#125;</span><br><span class="line">Qujian A[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;A[i].x,&amp;A[i].y);</span><br><span class="line">&#125;</span><br><span class="line">sort(A,A+N,cmp);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>; <span class="keyword">int</span> lastX=A[<span class="number">0</span>].x;    <span class="comment">//选取排序后第一个区间，并且记录下该区间的左端点</span></span><br><span class="line"><span class="comment">//lastX是记录上一个选取区间的左端点 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i].y&lt;lastX)        <span class="comment">//如果某一区间的右端点小于上一个选取区间的左端点，选取这个区间的左端点 </span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">lastX=A[i].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p>模板见另一篇博文。</p><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>快速幂本质上还是二分的思想。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>计算a的b次方%m。</p><p>if b=0，a的b次方=1</p><p>else if b为奇数，a的b次方=a的b-1次方 *a</p><p>else if b为偶数，a的b次方=a的b/2次方 * a的b/2次方 </p><h3 id="递归的写法"><a href="#递归的写法" class="headerlink" title="递归的写法"></a>递归的写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法 </span></span><br><span class="line"><span class="function">ll <span class="title">binaryPow</span><span class="params">(ll a,ll b,ll m)</span><span class="comment">//计算a的b次方%m </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> a*binaryPow(a,b<span class="number">-1</span>,m)%m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll mul=binaryPow(a,b/<span class="number">2</span>,m);</span><br><span class="line"><span class="keyword">return</span> mul*mul%m; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><p>b可以拆分成多个2的倍数的偶数和一个奇数相加。</p><p>例如b=13</p><p>13=8+4+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">binaryPow1</span><span class="params">(ll a,ll b,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//如果b的二进制最后一位是1</span></span><br><span class="line">&#123;</span><br><span class="line">ans=ans*a%m;</span><br><span class="line">    &#125; </span><br><span class="line">    a=a*a%m;<span class="comment">//令a平方，从而计算出 a的2,4,8次方 </span></span><br><span class="line">    b&gt;&gt;=<span class="number">1</span>;   <span class="comment">//b右移一位，相当于b=b/2 </span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Two-pointer"><a href="#Two-pointer" class="headerlink" title="Two pointer"></a>Two pointer</h1><p>可以解决序列合并问题。</p><h2 id="2-路归并排序"><a href="#2-路归并排序" class="headerlink" title="2-路归并排序"></a>2-路归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=L1;</span><br><span class="line"><span class="keyword">int</span> j=L2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=R1&amp;&amp;j&lt;=R2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;=A[j])</span><br><span class="line">temp[index++]=A[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[index++]=A[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=R1)temp[index++]=A[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=R2)temp[index++]=A[j++];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">&#123;</span><br><span class="line">A[L1+i]=temp[i];  <span class="comment">//写回去A</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  <span class="comment">//递归实现 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">mergesort(A,left,mid);</span><br><span class="line">mergesort(A,mid+<span class="number">1</span>,right);</span><br><span class="line">merge(A,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort1</span><span class="params">(<span class="keyword">int</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step/<span class="number">2</span>&lt;=n;step+=<span class="number">2</span>)   <span class="comment">//子区间的元素总数为step </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//step个元素作为一组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=step)     <span class="comment">//对于每一组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=i+step/<span class="number">2</span><span class="number">-1</span>  ;<span class="comment">//左子区间的元素个数为step/2 </span></span><br><span class="line"><span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//左子区间[i,mid] ,右子区间 [mid+1,min(i+step-1,n)]</span></span><br><span class="line">merge(A,i,mid,mid+<span class="number">1</span>,min(i+step<span class="number">-1</span>,n));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-1</title>
      <link href="/2019/01/21/PAT-1/"/>
      <url>/2019/01/21/PAT-1/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体的排序方法（sort的使用）"><a href="#结构体的排序方法（sort的使用）" class="headerlink" title="结构体的排序方法（sort的使用）"></a>结构体的排序方法（sort的使用）</h1><h2 id="A1025"><a href="#A1025" class="headerlink" title="A1025"></a>A1025</h2><h3 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h3><p>结构体的排序方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> student &amp;a,<span class="keyword">const</span> student &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score==b.score)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id)&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> id[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="keyword">int</span> location_number;</span><br><span class="line"><span class="keyword">int</span> local_rank;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> student &amp;a,<span class="keyword">const</span> student &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score==b.score)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id)&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line">student stu[<span class="number">30010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);<span class="comment">//n为考场数目</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);<span class="comment">//每个考场人数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,stu[num].id,&amp;stu[num].score);</span><br><span class="line">stu[num].location_number=i;</span><br><span class="line">num++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sort(stu+num-k,stu+num,cmp);</span><br><span class="line">stu[num-k].local_rank=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//int temp=1;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=num-k+<span class="number">1</span>;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(stu[j].score==stu[j<span class="number">-1</span>].score)</span><br><span class="line">stu[j].local_rank=stu[j<span class="number">-1</span>].local_rank;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">stu[j].local_rank=j-(num-k)+<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line"></span><br><span class="line">sort(stu,stu+num,cmp);</span><br><span class="line"><span class="keyword">int</span> temp1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;stu[i].score!=stu[i<span class="number">-1</span>].score)</span><br><span class="line">temp1=i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %d %d %d\n"</span>,stu[i].id,temp1,stu[i].location_number+<span class="number">1</span>,stu[i].local_rank);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash的使用"><a href="#hash的使用" class="headerlink" title="hash的使用"></a>hash的使用</h1><h2 id="将字符串转换成整数"><a href="#将字符串转换成整数" class="headerlink" title="将字符串转换成整数"></a>将字符串转换成整数</h2><p>主要用到的函数：</p><h4 id="注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1-X表示字符串所出现的最大字符种类个数。"><a href="#注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1-X表示字符串所出现的最大字符种类个数。" class="headerlink" title="注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1.X表示字符串所出现的最大字符种类个数。"></a>注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1.X表示字符串所出现的最大字符种类个数。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span>    <span class="comment">//可以将只包含了a-z,A-Z的字符串映射到一个整数表示 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span>&amp;&amp;S[i]&lt;=<span class="string">'Z'</span>) </span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc1</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">id=id*<span class="number">26</span>+(s[i]-<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目-给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。"><a href="#题目-给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。" class="headerlink" title="题目:给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。"></a>题目:给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn][<span class="number">5</span>],temp[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span>    <span class="comment">//可以将只包含了a-z,A-Z的字符串映射到一个整数表示 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span>&amp;&amp;S[i]&lt;=<span class="string">'Z'</span>) </span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc1</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">id=id*<span class="number">26</span>+(s[i]-<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S[i]);</span><br><span class="line"><span class="keyword">int</span> id=hashFunc1(S[i],<span class="number">3</span>);  <span class="comment">//string to int</span></span><br><span class="line">hashTable[id]++;       <span class="comment">//count++</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line"><span class="keyword">int</span> id=hashFunc1(temp,<span class="number">3</span>);    <span class="comment">//将测试字符串转换成int  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hashTable[id]);<span class="comment">//输出该字符串的出现次数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>全排列主要还是利用了递归的思路，之前在leetcode做了挺多，重新看算法笔记，发现自己又忘记了。。。</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>输入一个n，输出1-n的数字全排列。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)   <span class="comment">//递归的边界,表示已经处理了1-n位 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,P[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)<span class="comment">//循环测试 i放入P[index] 是否合适 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)     <span class="comment">//看X是否已经使用了 </span></span><br><span class="line">&#123;</span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;<span class="comment">//设置x已经使用了的状态 </span></span><br><span class="line"></span><br><span class="line">generateP(index+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">hashTable[x]=<span class="literal">false</span>; <span class="comment">//还原状态 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">generateP(<span class="number">1</span>);  <span class="comment">//从第一位开始填充！ </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得思考的是，如果要求输出的是字符a-z的全排列，也是需要hashTable的思想，从第一位开始填充，使用hashTable判断某一个字符是否使用过。</p><h4 id="关键"><a href="#关键" class="headerlink" title="关键:"></a>关键:</h4><p>1.就是要记得递归的时候的递归边界</p><p>2.设置状态之后，记得还原状态。</p><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p>本质上也是一个全排列问题。详情见下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">11</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> P[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span>  <span class="comment">//暴力法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(P[i]-P[j]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)count1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generateP(index+<span class="number">1</span>);</span><br><span class="line">hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP1</span><span class="params">(<span class="keyword">int</span> index)</span>   <span class="comment">//表示的是第index列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(P[pre]-x))</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generateP1(index+<span class="number">1</span>);</span><br><span class="line">hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">generateP1(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中generateP（）表示的是暴力法，没有剪枝操作。</p><p>其中generateP1（）表示的是回溯法，有剪枝操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>little dp</title>
      <link href="/2018/12/18/little-dp/"/>
      <url>/2018/12/18/little-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划入门"><a href="#动态规划入门" class="headerlink" title="动态规划入门"></a>动态规划入门</h1><p>一直感觉动态规划好难，最近看了一下leetcode的两道题，慢慢有了一点感觉。</p><a id="more"></a><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="[53] Maximum Subarray"></a>[53] Maximum Subarray</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=53 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [53] Maximum Subarray</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/maximum-subarray/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (41.99%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    417.5K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 994.1K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[-2,1,-3,4,-1,2,1,-5,4]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given an integer array nums, find the contiguous subarray (containing at</span></span><br><span class="line"><span class="comment"> * least one number) which has the largest sum and return its sum.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [-2,1,-3,4,-1,2,1,-5,4],</span></span><br><span class="line"><span class="comment"> * Output: 6</span></span><br><span class="line"><span class="comment"> * Explanation: [4,-1,2,1] has the largest sum = 6.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Follow up:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If you have figured out the O(n) solution, try coding another solution using</span></span><br><span class="line"><span class="comment"> * the divide and conquer approach, which is more subtle.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                    dp[i]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(ans&lt;dp[i])</span><br><span class="line">                ans=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="[70] Climbing Stairs"></a>[70] Climbing Stairs</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=70 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [70] Climbing Stairs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/climbing-stairs/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (42.57%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    322.2K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 757K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '2'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You are climbing a stair case. It takes n steps to reach to the top.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Each time you can either climb 1 or 2 steps. In how many distinct ways can</span></span><br><span class="line"><span class="comment"> * you climb to the top?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note: Given n will be a positive integer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: 2</span></span><br><span class="line"><span class="comment"> * Output: 2</span></span><br><span class="line"><span class="comment"> * Explanation: There are two ways to climb to the top.</span></span><br><span class="line"><span class="comment"> * 1. 1 step + 1 step</span></span><br><span class="line"><span class="comment"> * 2. 2 steps</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: 3</span></span><br><span class="line"><span class="comment"> * Output: 3</span></span><br><span class="line"><span class="comment"> * Explanation: There are three ways to climb to the top.</span></span><br><span class="line"><span class="comment"> * 1. 1 step + 1 step + 1 step</span></span><br><span class="line"><span class="comment"> * 2. 1 step + 2 steps</span></span><br><span class="line"><span class="comment"> * 3. 2 steps + 1 step</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">     </span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>旋转矩阵</title>
      <link href="/2018/12/14/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2018/12/14/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><h2 id="Leetcode-48"><a href="#Leetcode-48" class="headerlink" title="Leetcode-48"></a>Leetcode-48</h2><p>下面给出两种解法：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=48 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [48] Rotate Image</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/rotate-image/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (45.23%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    204.8K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 452.8K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You are given an n x n 2D matrix representing an image.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Rotate the image by 90 degrees (clockwise).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You have to rotate the image in-place, which means you have to modify the</span></span><br><span class="line"><span class="comment"> * input 2D matrix directly. DO NOT allocate another 2D matrix and do the</span></span><br><span class="line"><span class="comment"> * rotation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given input matrix = </span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1,2,3],</span></span><br><span class="line"><span class="comment"> * ⁠ [4,5,6],</span></span><br><span class="line"><span class="comment"> * ⁠ [7,8,9]</span></span><br><span class="line"><span class="comment"> * ],</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rotate the input matrix in-place such that it becomes:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [7,4,1],</span></span><br><span class="line"><span class="comment"> * ⁠ [8,5,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [9,6,3]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given input matrix =</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [ 5, 1, 9,11],</span></span><br><span class="line"><span class="comment"> * ⁠ [ 2, 4, 8,10],</span></span><br><span class="line"><span class="comment"> * ⁠ [13, 3, 6, 7],</span></span><br><span class="line"><span class="comment"> * ⁠ [15,14,12,16]</span></span><br><span class="line"><span class="comment"> * ], </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rotate the input matrix in-place such that it becomes:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [15,13, 2, 5],</span></span><br><span class="line"><span class="comment"> * ⁠ [14, 3, 4, 1],</span></span><br><span class="line"><span class="comment"> * ⁠ [12, 6, 8, 9],</span></span><br><span class="line"><span class="comment"> * ⁠ [16, 7,10,11]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">       <span class="comment">/* for(int i=0;i&lt;n/2;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j=i;j&lt;n-1-i;j++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                int temp=matrix[j][n-i-1];</span></span><br><span class="line"><span class="comment">                matrix[j][n-i-1]=matrix[i][j];</span></span><br><span class="line"><span class="comment">                matrix[i][j]=matrix[n-j-1][i];</span></span><br><span class="line"><span class="comment">                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];</span></span><br><span class="line"><span class="comment">                matrix[n-i-1][n-j-1] = temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//对角线对折</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//对中线对折</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(matrix[i][j],matrix[i][n<span class="number">-1</span>-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全排列</title>
      <link href="/2018/12/08/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/12/08/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>  全排列类型的题目一般使用回溯算法去解决，需要注意的是如何去递归，每次递归改变的条件。</p><a id="more"></a><h2 id="Leetcode-46"><a href="#Leetcode-46" class="headerlink" title="Leetcode 46"></a>Leetcode 46</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">√ Accepted</span><br><span class="line">√ <span class="number">25</span>/<span class="number">25</span> <span class="function">cases <span class="title">passed</span> <span class="params">(<span class="number">8</span> ms)</span></span></span><br><span class="line">√ Your runtime beats 40.39 % of cpp submissions</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=46 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [46] Permutations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/permutations/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (51.59%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    306.6K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 594.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,2,3]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a collection of distinct integers, return all possible permutations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,2,3]</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1,2,3],</span></span><br><span class="line"><span class="comment"> * ⁠ [1,3,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,1,3],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,3,1],</span></span><br><span class="line"><span class="comment"> * ⁠ [3,1,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [3,2,1]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n=nums[i];</span><br><span class="line">                now.push_back(nums[i]);</span><br><span class="line">                nums.erase(nums.begin()+i);<span class="comment">//删除这个元素</span></span><br><span class="line">                backtrace(nums,now,ans);</span><br><span class="line">                nums.insert(nums.begin()+i, n);<span class="comment">//把删除的元素加回来，不改变相对位置。</span></span><br><span class="line">                now.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now;</span><br><span class="line">        backtrace(nums,now,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-47"><a href="#Leetcode-47" class="headerlink" title="Leetcode 47"></a>Leetcode 47</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=47 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [47] Permutations II</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/permutations-ii/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (37.93%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    203.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 537.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,1,2]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a collection of numbers that might contain duplicates, return all</span></span><br><span class="line"><span class="comment"> * possible unique permutations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,1,2]</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1,1,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [1,2,1],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,1,1]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)   <span class="comment">//表示每一次都选数组中的一个一个数当作第一个数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 和leetcode46 比起来 相对于重复的元素进行了处理！ */</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="comment">// 精华！！！ 和46题的对比！！！</span></span><br><span class="line">                    <span class="keyword">continue</span>;               <span class="comment">//精华！！！</span></span><br><span class="line">                <span class="keyword">int</span> n=nums[i];</span><br><span class="line">                now.push_back(nums[i]);</span><br><span class="line">                nums.erase(nums.begin()+i);<span class="comment">//删除这个元素</span></span><br><span class="line">                backtrace(nums,now,ans);</span><br><span class="line">                nums.insert(nums.begin()+i, n);<span class="comment">//把删除的元素加回来，不改变相对位置。</span></span><br><span class="line">                now.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">        backtrace(nums,now,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回溯算法</title>
      <link href="/2018/12/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-39"><a href="#Leetcode-39" class="headerlink" title="Leetcode 39"></a>Leetcode 39</h1><a id="more"></a><p>参考链接</p><p><a href="https://blog.csdn.net/zr1076311296/article/details/51374923" target="_blank" rel="noopener">https://blog.csdn.net/zr1076311296/article/details/51374923</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [39] Combination Sum</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/combination-sum/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (44.92%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    275.2K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 612.7K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[2,3,6,7]\n7'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a set of candidate numbers (candidates) (without duplicates) and a</span></span><br><span class="line"><span class="comment"> * target number (target), find all unique combinations in candidates where the</span></span><br><span class="line"><span class="comment"> * candidate numbers sums to target.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The same repeated number may be chosen from candidates unlimited number of</span></span><br><span class="line"><span class="comment"> * times.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * All numbers (including target) will be positive integers.</span></span><br><span class="line"><span class="comment"> * The solution set must not contain duplicate combinations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [2,3,6,7], target = 7,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [7],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,2,3]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [2,3,5], target = 8,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * [2,2,2,2],</span></span><br><span class="line"><span class="comment"> * [2,3,3],</span></span><br><span class="line"><span class="comment"> * [3,5]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;tmp,<span class="keyword">int</span> target,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i]&gt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                backTrace(candidates,res,tmp,target-candidates[i],i);</span><br><span class="line">                tmp.pop_back();<span class="comment">//把元素弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ret;</span><br><span class="line">       ret.clear();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">       tmp.clear();</span><br><span class="line">       sort(candidates.begin(),candidates.end());</span><br><span class="line">       backTrace(candidates,ret,tmp,target,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-40"><a href="#Leetcode-40" class="headerlink" title="Leetcode 40"></a>Leetcode 40</h1><p>与39题类似，但是要注意去重复，还有从i+1进入下次递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [40] Combination Sum II</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/combination-sum-ii/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (38.78%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    184.7K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 476.1K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[10,1,2,7,6,1,5]\n8'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a collection of candidate numbers (candidates) and a target number</span></span><br><span class="line"><span class="comment"> * (target), find all unique combinations in candidates where the candidate</span></span><br><span class="line"><span class="comment"> * numbers sums to target.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Each number in candidates may only be used once in the combination.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * All numbers (including target) will be positive integers.</span></span><br><span class="line"><span class="comment"> * The solution set must not contain duplicate combinations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [10,1,2,7,6,1,5], target = 8,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1, 7],</span></span><br><span class="line"><span class="comment"> * ⁠ [1, 2, 5],</span></span><br><span class="line"><span class="comment"> * ⁠ [2, 6],</span></span><br><span class="line"><span class="comment"> * ⁠ [1, 1, 6]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [2,5,2,1,2], target = 5,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * [1,2,2],</span></span><br><span class="line"><span class="comment"> * [5]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i]&lt;=target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class="number">-1</span>])<span class="comment">//精华！</span></span><br><span class="line">                        <span class="keyword">continue</span>;                   </span><br><span class="line">                    now.push_back(candidates[i]);</span><br><span class="line">                    backtracing(now,candidates,target-candidates[i],ans,i+<span class="number">1</span>);<span class="comment">//精华！</span></span><br><span class="line">                    now.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ret;</span><br><span class="line">       ret.clear();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">       tmp.clear();</span><br><span class="line">       sort(candidates.begin(),candidates.end());</span><br><span class="line">       backtracing(tmp,candidates,target,ret,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分搜索的写法</title>
      <link href="/2018/11/28/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%86%99%E6%B3%95/"/>
      <url>/2018/11/28/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索的写法总结"><a href="#二分搜索的写法总结" class="headerlink" title="二分搜索的写法总结"></a>二分搜索的写法总结</h1><p>参考了</p><p><a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">https://www.zhihu.com/question/36132386</a></p><a id="more"></a><p>参考题目链接</p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找任意一个等于target的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> length)</span>    <span class="comment">//注意这里的范围要写成[0,n-1].即left=0，right=length-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]==target)<span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num[left]==target)     <span class="comment">//注意这里不能够漏掉</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求下界 ，返回的是第一个等于target的数字 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_binary</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> length)</span>    <span class="comment">//这里的区间也是[0,n-1]，left=0，right=n-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=mid; <span class="comment">//nums[mid]&lt;=target right一直往左边靠 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[left]==target)</span><br><span class="line"><span class="keyword">return</span> left; <span class="comment">//返回的是第一个等于target的数字 </span></span><br><span class="line"><span class="comment">//return left-1  //返回的是第一个小于target的数字 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求上界 ,返回的是第一个大于target的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">up_binary</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((right<span class="number">-1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[right<span class="number">-1</span>]==target)   <span class="comment">//right=0说明没有一个大于tar的元素</span></span><br><span class="line"><span class="keyword">return</span> right;<span class="comment">//返回的是第一个大于target的位置</span></span><br><span class="line"><span class="comment">//return right-1; //返回的是最后一个等于target的位置</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;binary(a,<span class="number">1</span>,<span class="number">22</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-33"><a href="#Leetcode-33" class="headerlink" title="Leetcode-33"></a>Leetcode-33</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [33] Search in Rotated Sorted Array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/search-in-rotated-sorted-array/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (32.28%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    330.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 1M</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[4,5,6,7,0,1,2]\n0'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Suppose an array sorted in ascending order is rotated at some pivot unknown</span></span><br><span class="line"><span class="comment"> * to you beforehand.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You are given a target value to search. If found in the array return its</span></span><br><span class="line"><span class="comment"> * index, otherwise return -1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You may assume no duplicate exists in the array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your algorithm's runtime complexity must be in the order of O(log n).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [4,5,6,7,0,1,2], target = 0</span></span><br><span class="line"><span class="comment"> * Output: 4</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [4,5,6,7,0,1,2], target = 3</span></span><br><span class="line"><span class="comment"> * Output: -1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[right])<span class="comment">//搜索右边</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[right])<span class="comment">//搜索左边</span></span><br><span class="line">            &#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    right=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target||nums[right]==target)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-35"><a href="#Leetcode-35" class="headerlink" title="Leetcode-35"></a>Leetcode-35</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [35] Search Insert Position</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/search-insert-position/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (40.02%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    325.8K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 814K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,3,5,6]\n5'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a sorted array and a target value, return the index if the target is</span></span><br><span class="line"><span class="comment"> * found. If not, return the index where it would be if it were inserted in</span></span><br><span class="line"><span class="comment"> * order.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You may assume no duplicates in the array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 5</span></span><br><span class="line"><span class="comment"> * Output: 2</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 2</span></span><br><span class="line"><span class="comment"> * Output: 1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 3:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 7</span></span><br><span class="line"><span class="comment"> * Output: 4</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 4:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 0</span></span><br><span class="line"><span class="comment"> * Output: 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left==length<span class="number">-1</span>&amp;&amp;nums[length<span class="number">-1</span>]&lt;target)</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-34"><a href="#Leetcode-34" class="headerlink" title="Leetcode-34"></a>Leetcode-34</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [34] Find First and Last Position of Element in Sorted Array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (32.34%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    240.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 743.1K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[5,7,7,8,8,10]\n8'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given an array of integers nums sorted in ascending order, find the starting</span></span><br><span class="line"><span class="comment"> * and ending position of a given target value.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your algorithm's runtime complexity must be in the order of O(log n).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the target is not found in the array, return [-1, -1].</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="comment"> * Output: [3,4]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [5,7,7,8,8,10], target = 6</span></span><br><span class="line"><span class="comment"> * Output: [-1,-1]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.size()<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)<span class="comment">//求第一个等于target的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">           mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t1=left;</span><br><span class="line">        </span><br><span class="line">        right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((left<span class="number">-1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[left<span class="number">-1</span>]==target&amp;&amp;nums[left]!=target)</span><br><span class="line">            t2=left<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((left<span class="number">-1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[left]==target)</span><br><span class="line">            t2=left;</span><br><span class="line">        <span class="keyword">return</span> &#123;t1,t2&#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="A1044-Shopping-in-Mars"><a href="#A1044-Shopping-in-Mars" class="headerlink" title="A1044 Shopping in Mars"></a>A1044 Shopping in Mars</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[maxn]=&#123;<span class="number">0</span>&#125; ;   <span class="comment">//记录money[1]-money[i]的和 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span>  <span class="comment">//查找在[L,R)中的第一个大于x的数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=L,right=R,mid;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line">mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sum[mid]&gt;x)</span><br><span class="line">&#123;</span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nearS=<span class="number">10000000010</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sum[i]);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+sum[i]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=upper_bound(i,N+<span class="number">1</span>,sum[i<span class="number">-1</span>]+M);</span><br><span class="line"><span class="keyword">if</span>(sum[j<span class="number">-1</span>]-sum[i<span class="number">-1</span>]==M)</span><br><span class="line">&#123;</span><br><span class="line">nearS=M;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j&lt;=N&amp;&amp;sum[j]-sum[i<span class="number">-1</span>]&lt;nearS)</span><br><span class="line">&#123;</span><br><span class="line">nearS=sum[j]-sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=upper_bound(i,N+<span class="number">1</span>,sum[i<span class="number">-1</span>]+nearS);</span><br><span class="line"><span class="keyword">if</span>(sum[j<span class="number">-1</span>]-sum[i<span class="number">-1</span>]==nearS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d-%d\n"</span>,i,j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ResNet</title>
      <link href="/2018/11/27/ResNet/"/>
      <url>/2018/11/27/ResNet/</url>
      
        <content type="html"><![CDATA[<h1 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h1><p><strong>网络的深度为什么重要？</strong></p><p>  因为CNN能够提取low/mid/high-level的特征，网络的层数越多，意味着能够提取到不同level的特征越丰富。并且，越深的网络提取的特征越抽象，越具有语义信息。</p><p><strong>为什么不能简单地增加网络层数？</strong></p><p>对于原来的网络，如果简单地增加深度，会导致梯度弥散或梯度爆炸。</p><p><strong>对于该问题的解决方法是正则化初始化和中间的正则化层（Batch Normalization），这样的话可以训练几十层的网络。</strong></p><p>虽然通过上述方法能够训练了，但是又会出现另一个问题，就是<strong>退化问题</strong>，网络层数增加，但是在训练集上的准确率却饱和甚至下降了。这个不能解释为overfitting，因为overfit应该表现为在训练集上表现更好才对。</p><p><strong>怎么解决退化问题？</strong></p><p>深度残差网络。如果深层网络的后面那些层是恒等映射，那么模型就退化为一个浅层网络。那现在要解决的就是学习恒等映射函数了。 但是直接让一些层去拟合一个潜在的恒等映射函数H(x) = x，比较困难，这可能就是深层网络难以训练的原因。但是，如果把网络设计为H(x) = F(x) + x,如下图。我们可以转换为学习一个残差函数F(x) = H(x) - x. 只要F(x)=0，就构成了一个恒等映射H(x) = x. 而且，拟合残差肯定更加容易。</p><h2 id="为什么非常深度的网络在增加更多层时会表现得更差？"><a href="#为什么非常深度的网络在增加更多层时会表现得更差？" class="headerlink" title="为什么非常深度的网络在增加更多层时会表现得更差？"></a>为什么非常深度的网络在增加更多层时会表现得更差？</h2><p>   直觉上推测，更深度的网络不会比更浅度的同类型网络表现更差吧，至少在训练时间上是这样（当不存在过拟合的风险时）。让我们进行一个思想实验，假设我们已经构建了一个   n   层网络，并且实现了一定准确度。那么一个   n+1   层网络至少也应该能够实现同样的准确度——只要简单复制前面   n   层，再在最后一层增加一层恒等映射就可以了。类似地，n+2、n+3   和   n+4   层的网络都可以继续增加恒等映射，然后实现同样的准确度。但是在实际情况下，这些更深度的网络基本上都会表现得更差。</p><p>ResNet   的作者将这些问题归结成了一个单一的假设：直接映射是难以学习的。而且他们提出了一种修正方法：不再学习从   x   到   H ( x )   的基本映射关系，而是学习这两者之间的差异，也就是「残差（residual）」。然后，为了计算   H ( x ) ，我们只需要将这个残差加到输入上即可。</p><p>假设残差为   F ( x ) =H ( x ) -x，那么现在我们的网络不会直接学习   H ( x )   了，而是学习   F ( x ) +x。</p><p>ResNet   的每一个「模块（block）」都由一系列层和一个「捷径（shortcut）」连接组成，这个「捷径」将该模块的输入和输出连接到了一起。然后在元素层面上执行「加法（add）」运算，如果输入和输出的大小不同，那就可以使用零填充或投射（通过   1 × 1   卷积）来得到匹配的大小。</p><p>回到我们的思想实验，这能大大简化我们对恒等层的构建。直觉上就能知道，比起从头开始学习一个恒等变换，学会使   F ( x )   为   0   并使输出仍为   x   要容易得多。一般来说，ResNet   会给层一个「参考」点   x，以   x   为基础开始学习。</p><p>在此之前，深度神经网络常常会有梯度消失问题的困扰，即来自误差函数的梯度信号会在反向传播回更早的层时指数级地下降。本质上讲，在误差信号反向回到更早的层时，它们会变得非常小以至于网络无法学习。但是，因为   ResNet   的梯度信号可以直接通过捷径连接回到更早的层，所以我们一下子就可以构建   50   层、101   层、152   层甚至   1000   层以上的网络了，而且它们的表现依然良好。</p><p>对于shortcut的方式，作者提出了三个选项：<br>A. 使用恒等映射，如果residual block的输入输出维度不一致，对增加的维度用0来填充；<br>B. 在block输入输出维度一致时使用恒等映射，不一致时使用线性投影以保证维度一致； </p><p>C. 对于所有的block均使用线性投影。 </p><p>对这三个选项都进行了实验，发现虽然C的效果好于B的效果好于A的效果，但是差距很小，因此线性投影并不是必需的，而使用0填充时，可以保证模型的复杂度最低，这对于更深的网络是更加有利的。<br>模型结构图中，我们可以清楚的<strong>”实线“</strong>和<strong>”虚线“</strong>两种连接方式，<br>1）实线的的Connection部分都是3x3x64的特征图，他们的channel个数一致，所以采用计算方式：<br><strong>y=F(x)+x</strong><br>2）虚线的的Connection部分分别是3x3x64和3x3x128的特征图，他们的channel个数不同(64和128)，所以采用计算方式： <strong>y=F(x)+Wx</strong> 。其中W是卷积操作，用来调整x的channel维度的。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO模型epoll</title>
      <link href="/2018/11/22/IO%E6%A8%A1%E5%9E%8Bepoll/"/>
      <url>/2018/11/22/IO%E6%A8%A1%E5%9E%8Bepoll/</url>
      
        <content type="html"><![CDATA[<h1 id="IO模型epoll"><a href="#IO模型epoll" class="headerlink" title="IO模型epoll"></a>IO模型epoll</h1><p>epoll的设计和实现与select完全不同。epoll使用红黑树实现的。把原先的select/poll调用分成了3个部分：<br>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)<br>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字 </p><p>3）调用epoll_wait收集发生的事件的连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO模型</title>
      <link href="/2018/11/22/IO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/22/IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="同步、异步与阻塞、非阻塞的区别"><a href="#同步、异步与阻塞、非阻塞的区别" class="headerlink" title="同步、异步与阻塞、非阻塞的区别"></a>同步、异步与阻塞、非阻塞的区别</h2><p><strong>同步和异步关注的是消息通信机制。</strong></p><p>同步就是发出一个调用之后，在没有得到结果之前，这个调用就不返回。调用返回就得到了结果。调用者主动等待得到这个结果。</p><p>异步就是发出一个调用之后，就直接返回了，没有返回结果。有结果之后被调用者通过其他方式通知调用者消息。</p><p><strong>阻塞和非阻塞关注的是程序等待调用结果（消息，返回值）时的状态</strong></p><p>阻塞调用是指调用结果返回之前，当前线程被挂起来。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用是指不能立即得到结果之前，这个调用不会阻塞当前线程。</p><h2 id="IO模型可以分为"><a href="#IO模型可以分为" class="headerlink" title="IO模型可以分为"></a>IO模型可以分为</h2><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>同步阻塞迭代模型是最简单的一种IO模型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind(srvfd);</span><br><span class="line">listen(srvfd);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    clifd = accept(srvfd,...); <span class="comment">//开始接受客户端来的连接</span></span><br><span class="line">    read(clifd,buf,...); <span class="comment">//从客户端读取数据</span></span><br><span class="line">    dosomthingonbuf(buf);</span><br><span class="line">    write(clifd,buf)<span class="comment">//发送数据到客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序存在如下一些弊端：</p><p>1）如果没有客户端的连接请求，进程会阻塞在accept系统调用处，程序不能执行其他任何操作。(系统调用使得程序从用户态陷入内核态，具体请参考：程序员的自我修养<br>2）在与客户端建立好一条链路后，通过read系统调用从客户端接受数据，而客户端合适发送数据过来是不可控的。如果客户端迟迟不发生数据过来，则程序同样会阻塞在read调用，此时，如果另外的客户端来尝试连接时，都会失败。 </p><p>3）同样的道理，<strong>write系统</strong>调用也会使得程序出现阻塞(例如：客户端接受数据异常缓慢，导致写缓冲区满，数据迟迟发送不出)。</p><p><strong>2.多进程并发模型</strong><br>同步阻塞迭代模型有诸多缺点。多进程并发模型在同步阻塞迭代模型的基础上进行了一些改进，以避免是程序阻塞在read系统调用上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bind(srvfd);</span><br><span class="line">listen(srvfd);</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">clifd = accept(srvfd,...); <span class="comment">//开始接受客户端来的连接</span></span><br><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">switch</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span> :</span><br><span class="line">        do_err_handler();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 子进程</span></span><br><span class="line">        client_handler(clifd);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 父进程</span></span><br><span class="line">        close(clifd);</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handler</span><span class="params">(clifd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(clifd,buf,...); <span class="comment">//从客户端读取数据</span></span><br><span class="line">    dosomthingonbuf(buf);</span><br><span class="line">    write(clifd,buf)<span class="comment">//发送数据到客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序在accept系统调用时，如果没有客户端来建立连接，择<strong>会阻塞在accept处</strong>。一旦某个客户端连接建立起来，则立即开启一个新的进程来处理与这个客户的数据交互。避免程序阻塞在read调用，而影响其他客户端的连接。 </p><p><strong>多线程并发模型</strong><br>在多进程并发模型中，每一个客户端连接开启fork一个进程，虽然linux中引入了写实拷贝机制，大大降低了fork一个子进程的消耗，但若客户端连接较大，则系统依然将不堪负重。<strong>通过多线程(或线程池)并发模型，可以在一定程度上改善这一问题。</strong></p><p>在服务端的线程模型实现方式一般有三种：<br>（1）按需生成(来一个连接生成一个线程)<br>（2）线程池(预先生成很多线程)**<br>（3）Leader follower（LF）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_callback</span><span class="params">( <span class="keyword">void</span> *args )</span> <span class="comment">//线程回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clifd = *(<span class="keyword">int</span> *)args ;</span><br><span class="line">    client_handler(clifd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handler</span><span class="params">(clifd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(clifd,buf,...); <span class="comment">//从客户端读取数据</span></span><br><span class="line">    dosomthingonbuf(buf);</span><br><span class="line">    write(clifd,buf)<span class="comment">//发送数据到客户端</span></span><br><span class="line">&#125;</span><br><span class="line">bind(srvfd);</span><br><span class="line">listen(srvfd);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    clifd = accept();</span><br><span class="line">    pthread_create(...,thread_callback,&amp;clifd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端分为主线程和工作线程，主线程负责accept()连接，而工作线程负责处理业务逻辑和流的读取等。<br>因此，即使在工作线程阻塞的情况下，也只是阻塞在线程范围内，对继续接受新的客户端连接不会有影响。<br>第二种实现方式，通过线程池的引入可以避免频繁的创建、销毁线程，能在很大程序上提升性能。<br>但不管如何实现，<strong>多线程模型先天具有如下缺点：</strong><br><strong>1）稳定性相对较差。一个线程的崩溃会导致整个程序崩溃。</strong> </p><p><strong>2）临界资源的访问控制，在加大程序复杂性的同时，锁机制的引入会是严重降低程序的性能。性能上可能会出现“辛辛苦苦好几年，一夜回到解放前”的情况。</strong></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>采用轮询的方式 （大量浪费CPU的资源）</p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>发送一个SIGIO信号通知，一般只适用与单线程。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用模型之select/poll<br>多进程模型和多线程(线程池)模型每个进程/线程只能处理一路IO，在服务器并发数较高的情况下，过多的进程/线程会使得服务器性能下降。而通过多路IO复用，能使得一个进程同时处理多路IO，提升服务器吞吐量。 </p><h2 id="在Linux支持epoll模型之前，都使用select-poll模型来实现IO多路复用。"><a href="#在Linux支持epoll模型之前，都使用select-poll模型来实现IO多路复用。" class="headerlink" title="在Linux支持epoll模型之前，都使用select/poll模型来实现IO多路复用。 "></a>在Linux支持epoll模型之前，都使用select/poll模型来实现IO多路复用。 </h2><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bind(listenfd);</span><br><span class="line">listen(listenfd);</span><br><span class="line">FD_ZERO(&amp;allset);</span><br><span class="line">FD_SET(listenfd, &amp;allset);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    select(...);</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) </span><br><span class="line">    &#123;<span class="comment">/*有新的客户端连接到来*/</span></span><br><span class="line">        clifd = accept();</span><br><span class="line">        cliarray[] = clifd; <span class="comment">/*保存新的连接套接字*/</span></span><br><span class="line">        FD_SET(clifd, &amp;allset);<span class="comment">/*将新的描述符加入监听数组中*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;<span class="comment">/*这个for循环用来检查所有已经连接的客户端是否有数据可读写*/</span></span><br><span class="line"></span><br><span class="line">        fd = cliarray[i];</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fd , &amp;rset))</span><br><span class="line">            dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select IO多路复用同样存在一些缺点，罗列如下：</p><p>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select<strong>采用轮询的方式扫描文件描述符</strong>，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024)<br>2、内核 / 用户空间内存拷贝问题    ，select需要复制大量的句柄数据结构，产生巨大的开销； </p><p>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；<br><strong>select的触发方式是水平触发，</strong>应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。<br>3、相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。 </p><h2 id="拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在-FD-SETSIZE-为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核-用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。"><a href="#拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在-FD-SETSIZE-为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核-用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。" class="headerlink" title="拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。"></a>拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。</h2><p>socket函数格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>先说明两个结构体：<br>第一 .struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄，这可以是我们所说的普通意义的文件，当然 Unix下任何设备、管道、FIFO等都是文件形式，全部包括在内，所以毫无疑问一个socket就是一个文件，socket句柄就是一个文件描述符。<br>fd_set集合可以通过一些宏由人为来操作，比如：<br><strong>FD_ZERO(fd_set <em>);清空集合<br>FD_SET(int, fd_set </em>);将一个给定的文件描述符加入集合之中<br>FD_CLR(int, fd_set*); 将一个给定的文件描述符从集合中删除</strong><br><strong>检查集合中指定的文件描述符是否可以读写FD_ISSET(int ,fd_set* )</strong>。一会儿举例说明。</p><p>第二 .struct timeval 是一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个是微秒。 具体解释select的参数：<br>int maxfdp：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。</p><p>fd_set<em> readfds：是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中 读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断 是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。<br>fd_set</em> writefds：是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件 中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判 断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。<br>fd_set * errorfds：同上面两个参数的意图，用来监视文件错误异常。</p><p>struct timeval* timeout：是select的超时时间，这个参数至关重要，它可以使select处于三种状态：<br>第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；<br>第二，若将时间值设为0秒0微秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值； </p><p>第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。</p><p><strong>select 返回值：</strong><br>负值：select错误<br>正值：某些文件可读写或出错<br>0：等待超时，没有可读写或错误的文件<br>在有了select后可以写出像样的网络程序来！<br>举个简单的例子，就是从网络上接受数据写入一个文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> sock;  </span><br><span class="line">    FILE *fp;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> <span class="title">fds</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>=&#123;</span><span class="number">3</span>,<span class="number">0</span>&#125;; <span class="comment">//select等待3秒，3秒轮询，要非阻塞就置0  </span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//256字节的接收缓冲区  </span></span><br><span class="line">    <span class="comment">/* 假定已经建立UDP连接，具体过程不写，简单，当然TCP也同理，主机ip和port都已经给定，要写的文件已经打开 </span></span><br><span class="line"><span class="comment">    sock=socket(...); </span></span><br><span class="line"><span class="comment">    bind(...); </span></span><br><span class="line"><span class="comment">    fp=fopen(...); */</span>  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">   &#123;  </span><br><span class="line">        FD_ZERO(&amp;fds); <span class="comment">//每次循环都要清空集合，否则不能检测描述符变化  </span></span><br><span class="line">        FD_SET(sock,&amp;fds); <span class="comment">//添加描述符  </span></span><br><span class="line">        FD_SET(fp,&amp;fds); <span class="comment">//同上  </span></span><br><span class="line">        maxfdp=sock&gt;fp?sock+<span class="number">1</span>:fp+<span class="number">1</span>;    <span class="comment">//描述符最大值加1  </span></span><br><span class="line">        <span class="keyword">switch</span>(select(maxfdp,&amp;fds,&amp;fds,<span class="literal">NULL</span>,&amp;timeout))   <span class="comment">//select使用  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>: <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="keyword">break</span>; <span class="comment">//select错误，退出程序  </span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>; <span class="comment">//再次轮询  </span></span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                  <span class="keyword">if</span>(FD_ISSET(sock,&amp;fds)) <span class="comment">//测试sock是否可读，即是否网络上有数据  </span></span><br><span class="line">                  &#123;  </span><br><span class="line">                        recvfrom(sock,buffer,<span class="number">256</span>,.....);<span class="comment">//接受网络数据  </span></span><br><span class="line">                        <span class="keyword">if</span>(FD_ISSET(fp,&amp;fds)) <span class="comment">//测试文件是否可写  </span></span><br><span class="line">                            fwrite(fp,buffer...);<span class="comment">//写入文件  </span></span><br><span class="line">                         buffer清空;  </span><br><span class="line">                   &#125;<span class="comment">// end if break;  </span></span><br><span class="line">          &#125;<span class="comment">// end switch  </span></span><br><span class="line">     &#125;<span class="comment">//end while  </span></span><br><span class="line">&#125;<span class="comment">//end main</span></span><br></pre></td></tr></table></figure><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gdb调试</title>
      <link href="/2018/11/20/gdb%E8%B0%83%E8%AF%95/"/>
      <url>/2018/11/20/gdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Cmake：</p><p><a href="https://blog.csdn.net/gg_18826075157/article/details/72780431" target="_blank" rel="noopener">https://blog.csdn.net/gg_18826075157/article/details/72780431</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-cmake/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-cmake/</a></p><table><thead><tr><th>命令</th><th>命令缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>显示多行源代码</td></tr><tr><td>break</td><td>b</td><td>设置断点,程序运行到断点的位置会停下来</td></tr><tr><td>info</td><td>i</td><td>描述程序的状态</td></tr><tr><td>run</td><td>r</td><td>开始运行程序</td></tr><tr><td>display</td><td>disp</td><td>跟踪查看某个变量,每次停下来都显示它的值</td></tr><tr><td>step</td><td>s</td><td>执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</td></tr><tr><td>next</td><td>n</td><td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</td></tr><tr><td>print</td><td>p</td><td>打印内部变量值</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行,直到遇到下一个断点</td></tr><tr><td>set var name=v</td><td></td><td>设置变量的值</td></tr><tr><td>start</td><td>st</td><td>开始执行程序,在main函数的第一条语句前面停下来</td></tr><tr><td>file</td><td></td><td>装入需要调试的程序</td></tr><tr><td>kill</td><td>k</td><td>终止正在调试的程序</td></tr><tr><td>watch</td><td></td><td>监视变量值的变化</td></tr><tr><td>backtrace</td><td>bt</td><td>产看函数调用信息(堆栈)</td></tr><tr><td>frame</td><td>f</td><td>查看栈帧</td></tr><tr><td>quit</td><td>q</td><td>退出GDB环境</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>进程通信</title>
      <link href="/2018/11/20/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/11/20/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：<br>​    进程同步：控制多个进程按一定顺序执行；<br>​    进程通信：进程间传输信息。<br>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><p>进程原语和线程原语的比较：</p><p>进程原语    线程原语            描述<br>fork      pthread_create        创建新的控制流<br>exit            pthread_exit                   从现有的控制流退出<br>waitpid    pthread_join            从控制流中得到退出状态<br>atexit    pthread_cancle_push    注册在退出控制流时调用的函数<br>getpid    pthread_self            获取控制流的ID</p><p>abort    pthread_cancle    请求控制流的非正常退出</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p><a href="https://blog.csdn.net/kowzb/article/details/77160249" target="_blank" rel="noopener">https://blog.csdn.net/kowzb/article/details/77160249</a></p><p>一、进程间的通信方式</p><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>有名管道 (FIFO) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>信号 (sinal ) (异步的过程)： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>二、线程间的通信方式</p><p>锁机制：<strong>包括互斥锁、条件变量、读写锁</strong><br>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量<br>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>STL原理实现</title>
      <link href="/2018/11/20/STL%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/20/STL%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="STL原理实现"><a href="#STL原理实现" class="headerlink" title="STL原理实现"></a>STL原理实现</h1><h2 id="智能指针原理"><a href="#智能指针原理" class="headerlink" title="智能指针原理"></a>智能指针原理</h2><p>智能指针是一种资源管理类，通过对原始指针进行封装，在资源管理对象进行析构时对指针指向的内存进行释放；通常使用引用计数方式进行管理</p><h2 id="STL中vector的实现原理"><a href="#STL中vector的实现原理" class="headerlink" title="STL中vector的实现原理"></a>STL中vector的实现原理</h2><p><strong>vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，  对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了  。</strong></p><h2 id="STL中map的实现原理"><a href="#STL中map的实现原理" class="headerlink" title="STL中map的实现原理"></a>STL中map的实现原理</h2><p>Map是关联容器，以键值对的形式进行存储，方便进行查找，关键词起到索引的作用，值则表示与索引相关联的数据，以红黑树的结构实现，插入删除等操作都可以在O(log n)时间内完成</p><h2 id="STL中set的实现原理"><a href="#STL中set的实现原理" class="headerlink" title="STL中set的实现原理"></a>STL中set的实现原理</h2><p>Set是关联容器，set中每个元素都只包含一个关键字，set支持高效的关键字查询操作—检查每一个给定的关键字是否在set中，set是以红黑树的平衡二叉检索树结构实现的，支持高效插入删除，插如元素的时候会自动调整二叉树的结构，使得每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值，另外还得保证左子树和右子树的高度相等</p><p>​     平衡二叉检索树使用中序遍历算法，检索效率高于vector，deque，list等容器，另外使用中序遍历可将键值按照从小到大遍历出来</p><p>  构造set集合的主要目的是为了快速检索，不可直接去修改键值</p><h2 id="verctor"><a href="#verctor" class="headerlink" title="verctor"></a>verctor</h2><p>vector类似于C语言中的数组，它维护一段连续的内存空间，具有固定的起始地址，因而能非常方便地进行随机存取，即 [] 操作符，但因为它的内存区域是连续的，所以在它中间插入或删除某个元素，需要复制并移动现有的元素。此外，当被插入的内存空间不够时，需要重新申请一块足够大的内存并进行内存拷贝。值得注意的是，vector每次扩容为原来的两倍，对小对象来说执行效率高，但如果遇到大对象，执行效率就低了。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h2><p>list类似于C语言中的双向链表，它通过指针来进行数据的访问，因此维护的内存空间可以不连续，这也非常有利于数据的随机存取，因而它没有提供 [] 操作符重载。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a><strong>deque</strong></h2><p>deque类似于C语言中的双向队列，即两端都可以插入或者删除的队列。queue支持 [] 操作符，也就是支持随机存取，而且跟vector的效率相差无几。它支持两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上与list的效率<br>也差不多。或者我们可以这么认为，deque是vector跟list的折中。</p><p><strong>map</strong></p><p>map类似于数据库中的１:１关系，它是一种关联容器，提供一对一(<a href="http://www.cpplive.com/html/tag/cpp" target="_blank" rel="noopener">C++</a> primer中文版中将第一个译为键，每个键只能在map中出现一次，第二个被译为该键对应的值)的数据处理能力，这种特性了使得map类似于数据结构里的红黑二叉树。</p><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a><strong>multimap</strong></h2><p>multimap类似于数据库中的１:Ｎ关系，它是一种关联容器,提供一对多的数据处理能力。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h2><p>set类似于数学里面的集合，不过set的集合中不包含重复的元素，这是和vector的第一个区别，第二个区别是set内部用平衡二叉树实现，便于元素查找，而vector是使用连续内存存储，便于随机存取。</p><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a><strong>multiset</strong></h2><p>multiset类似于数学里面的集合，集合中可以包含重复的元素。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>１、如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p><p>2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p><p>3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p><p>4、如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p><p>5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据库</title>
      <link href="/2018/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>索引的概述(什么是索引,索引的优缺点)</li><li>索引的基本使用（创建索引）</li><li>索引的基本原理（面试重点）</li><li>索引的数据结构（B树，hash）</li><li>创建索引的原则（重中之重，面试必问！敬请收藏！）</li><li>百万级别或以上的数据如何删除</li></ul><p><a href="https://www.cnblogs.com/shijingxiang/articles/4743324.html" target="_blank" rel="noopener">https://www.cnblogs.com/shijingxiang/articles/4743324.html</a></p><p><strong>一、索引的概述</strong></p><p><strong>1）什么是索引？</strong></p><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，索引就相当于目录。当你在用新华字典时，帮你把目录撕掉了，你查询某个字开头的成语只能从第一页翻到第一千页。累！把目录还给你，则能快速定位！</p><p><strong>2）索引的优缺点：</strong></p><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。，且通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。但是，索引也是有缺点的：索引需要额外的维护成本；因为索引文件是单独存在的文件,对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。</p><p><strong>二、索引的基本使用（真技术文）</strong></p><p><strong>1）创建索引：（三种方式）</strong></p><p>第一种方式：创建表的时候创建</p><p><img src="https://files.jb51.net/file_images/article/201711/2017111691555019.jpg?201710169164" alt="img"></p><p><strong>第二种方式：使用ALTER TABLE命令去增加索引：</strong></p><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p><img src="https://files.jb51.net/file_images/article/201711/2017111691657597.jpg?201710169175" alt="img"></p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p><strong>第三种方式：使用CREATE INDEX命令创建</strong></p><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p><img src="https://files.jb51.net/file_images/article/201711/2017111691857883.jpg?201710169196" alt="img"></p><p><strong>三、索引的基本原理（不想像别的文章那样一大堆篇幅废话）</strong></p><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><p>​      1、把创建了索引的列的内容进行排序</p><p>​      2、对排序结果生成倒排表</p><p>​      3、在倒排表内容上拼上数据地址链</p><p>​      4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>常用的数据结构</title>
      <link href="/2018/11/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/11/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">数据结构</a>。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933" target="_blank" rel="noopener">散列表</a>。</p><ul><li>若关键字为<strong>k</strong>，则其值存放在<strong>f(k)</strong>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<strong>f</strong>为散列函数，按这个思想建立的表为散列表。</li><li>对不同的关键字可能得到同一散列地址，即<strong>k1≠k2</strong>，而<strong>f(k1)=f(k2)</strong>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数<strong>f(k)</strong>和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</li><li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li></ul><p><strong>常用的构造散列函数的方法</strong></p><p>　　散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位：</p><p>　　<strong>1. 直接寻址法：</strong>取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，其中a和b为常数（这种散列函数叫做自身函数）</p><p>　　<strong>2. 数字分析法：</strong>分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><p>　　<strong>3. 平方取中法：</strong>取关键字平方后的中间几位作为散列地址。</p><p>　　<strong>4. 折叠法：</strong>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。</p><p>　　<strong>5. 随机数法：</strong>选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</p><p>　　<strong>6. 除留余数法：</strong>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。<br><strong>查找的性能分析</strong></p><p>实际工作中需视不同的情况采用不同的<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">哈希函数</a>，通常考虑的因素有：</p><p>· 计算<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">哈希函数</a>所需时间</p><p>· 关键字的长度</p><p>· 哈希表的大小</p><p>· 关键字的分布情况</p><p>· 记录的查找频率</p><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>（1）开散列的方法：把冲突记录存在表外。</p><p>把散列表的每个槽定义为一个链表的表头，散列到一个槽的所有记录都要放在这个槽的链表里面。</p><p>（2）闭散列的方法：</p><p>桶式散列</p><p>线性探测</p><p>伪随机探测</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis 概要</title>
      <link href="/2018/11/20/redis-%E6%A6%82%E8%A6%81/"/>
      <url>/2018/11/20/redis-%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。<br>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。<br>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><p>Key-Value存储:(基于Redis)</p><p>传统的关系型数据库，处理一对多的问题，需要把外键放在多的一端，因为RDBMS理论中没有集合这个概念。而使用Redis，我们可以在一端来管理一对多的关系，使用Set。</p><p>如果使用MySQL，当数据规模非常大时，上面两个查询操作都需要借助表关联技术，而大表间的join在大型系统中是需要极力避免的操作。相反Redis的每个操作都会局限在一个较小的数据集范围内，而且key-value的存储形式，定位key只是一个复杂度为O(1)的操作。在very huge的数据量下，Redis性能效果非常优异，这就是NoSQL的优势所在！</p><h2 id="Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted-set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。"><a href="#Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted-set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。" class="headerlink" title="Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。"></a>Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。</h2><h2 id="Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。"><a href="#Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。" class="headerlink" title="Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。"></a>Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。</h2><p><strong>Redis 选择了高效且实现简单的哈希表作为字典的底层实现。</strong></p><p>Redis通常将数据存储于内存中，或被配置为使用虚拟内存。Redis有一个很重要的特点就是它可以实现持久化数据，通过两种方式可以实现数据持久化：使用RDB快照的方式，将内存中的数据不断写入磁盘；或使用类似MySQL的AOF日志方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>C++设计模式</title>
      <link href="/2018/11/20/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/20/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的设计模式"><a href="#C-的设计模式" class="headerlink" title="C++的设计模式"></a>C++的设计模式</h1><p><strong>c++设计模式：</strong></p><p>简单工厂模式</p><p>工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。</p><p>使用情景：<br>  在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。<br>案例：<br>如果实现计算器的功能时，对于同样的输入数据，可能执行加、减、乘、除，甚至其他的功能。因此可以抽象出一个操作的抽象类或是接口，提供一个统一的处理方法(此处为process)，然后每种操作创建出一个子类出来。而判断具体使用哪个具体的实现类是在工厂类中进行判断的(将存放操作的变量传递给工厂的生产方法)。工厂类始终返回的是这个抽象类，这样如果对原有功能进行更改或是新添加新的功能，也不会对原来的其他类做修改，只编译修改的那个类或是新的类就可以了。<br>这样就做到了把耦合降到最低，同时也便于维护。 </p><p>简单工厂：针对同样的数据，不同的操作用同一个接口</p><p>工厂方法：针对同样的数据，不同的操作用不同的接口</p><p>抽象工厂：针对不同的数据，不同的操作用不同的接口</p><p>策略模式：依赖c++的多态，抽象类的指针可以访问所有子类对象，（纯虚函数），可以用一个指针访问所有策略的实现类</p><p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式(不能让一个程序打开两次  如：不能同时打开2个迅雷  迅雷用的单例模式)</p><p>访问者模式:适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数)</p><p>观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。(QT的信号机制，Windows的消息机制都应用了观察者模式，还有订阅邮件，邮件到了就会给你发邮件)</p><p>建造者模式：使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器)</p><p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式)</p><p>命令模式：把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构))</p><p>模板模式：不同的子类可以以不同的方式实现这些抽象方法，</p><p>从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，</p><p>而将逻辑的细节留给具体的子类去实现。(适用于本地化，做一个软件，在日本是日文，美国是英语…)</p><p>桥接模式：将抽象化与实现化脱离，使得二者可以独立的变化，</p><p>也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起)</p><p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。</p><p>外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用)</p><p>享元模式：享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。</p><p>原型模式：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p><p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了)</p><p>中介者模式：中介者模式包装了一系列对象相互作用的方式，</p><p>使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p><p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术）</p><p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p><p>状态模式：意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床…这就是状态)</p><p>合成模式：将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓展</title>
      <link href="/2018/11/19/%E6%8B%93%E5%B1%95/"/>
      <url>/2018/11/19/%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="手游如何克服网络延迟问题？"><a href="#手游如何克服网络延迟问题？" class="headerlink" title="手游如何克服网络延迟问题？"></a>手游如何克服网络延迟问题？</h1><p>网络游戏同步，常用的两种方案是<strong>帧同步和状态同步</strong></p><p>帧同步：是同步玩家的指令，服务器负责转发客户端的操作，每个客户端以固定的逻辑帧执行所有客户端的操作指令，通过在严格一致的时间轴上执行同样的命令序列获得同样的结果。</p><p>状态同步跟帧同步的最大区别是服务器不在进行切逻辑帧，而是同步玩家状态信息，比如位置、属性、跟玩法相关的数据。通常主逻辑在服务器运行，客户端只是作为一个显示。采用状态同步的游戏有CFM、LOL等。</p><p>帧同步的网络流量较小，但防外挂、断线重连的难度比较大。状态同步中服务器有所有玩家的状态，安全性较高，游戏运营更可控。是否选择状态同步，需要看同步的实体数量。在大场景中，同步的单位比较多时，往往会放弃状态同步。比如星际争霸中玩家可操作的实体多达上百个，如采用状态同步的话网络流量将非常大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下的常用操作</title>
      <link href="/2018/11/19/Linux%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/19/Linux%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-下的常用操作"><a href="#Linux-下的常用操作" class="headerlink" title="Linux 下的常用操作"></a>Linux 下的常用操作</h1><p><img src="/2018/11/19/Linux下的常用操作/H:/hexo\source\_posts\Linux下的常用操作\1.png" alt=""></p><h2 id="shell怎么写"><a href="#shell怎么写" class="headerlink" title="shell怎么写"></a>shell怎么写</h2><p><a href="https://www.cnblogs.com/wuyuegb2312/p/3399566.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyuegb2312/p/3399566.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串处理</title>
      <link href="/2018/11/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2018/11/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>计算机网络的基础知识</title>
      <link href="/2018/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的基础知识"><a href="#计算机网络的基础知识" class="headerlink" title="计算机网络的基础知识"></a>计算机网络的基础知识</h1><a id="more"></a><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><h2 id="ARP是地址解析协议，简单语言解释一下工作原理。"><a href="#ARP是地址解析协议，简单语言解释一下工作原理。" class="headerlink" title="ARP是地址解析协议，简单语言解释一下工作原理。"></a>ARP是地址解析协议，简单语言解释一下工作原理。</h2><p>答:1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。<br>广播发送ARP请求，单播发送ARP响应。</p><h2 id="各种协议的介绍"><a href="#各种协议的介绍" class="headerlink" title="各种协议的介绍"></a>各种协议的介绍</h2><p>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p><p>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p><p>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p><p>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p><p>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h1 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h1><p><strong>TCP与UDP区别总结：</strong><br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br>TCP对应的协议和UDP对应的协议<br>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>答:当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p><h2 id="tcp粘包问题，怎么处理？"><a href="#tcp粘包问题，怎么处理？" class="headerlink" title="tcp粘包问题，怎么处理？"></a>tcp粘包问题，怎么处理？</h2><p><a href="https://www.cnblogs.com/kex1n/p/6502002.html" target="_blank" rel="noopener">https://www.cnblogs.com/kex1n/p/6502002.html</a></p><h2 id="udp会粘包吗？为什么？"><a href="#udp会粘包吗？为什么？" class="headerlink" title="udp会粘包吗？为什么？"></a>udp会粘包吗？为什么？</h2><h2 id="https的原理，和http的区别"><a href="#https的原理，和http的区别" class="headerlink" title="https的原理，和http的区别"></a>https的原理，和http的区别</h2><h2 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h2><pre><code>客户端：SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT。 服务端：LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。</code></pre><h2 id="TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br>（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux的基础知识</title>
      <link href="/2018/11/18/Linux%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/18/Linux%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h1><a id="more"></a><h2 id="Linux的用户态和内核态"><a href="#Linux的用户态和内核态" class="headerlink" title="Linux的用户态和内核态"></a>Linux的用户态和内核态</h2><p><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5520860.html</a></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>（1）拥有资源：进程是资源分配的基本单元，但是线程不拥有资源，线程可以访问其所隶属进程的资源。</p><p>（2）调度：线程是独立调度的基本单位。在同一个进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>（3）系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>（4）线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="linux怎么查看内存占用、CPU占用、IO占用"><a href="#linux怎么查看内存占用、CPU占用、IO占用" class="headerlink" title="linux怎么查看内存占用、CPU占用、IO占用"></a>linux怎么查看内存占用、CPU占用、IO占用</h2><p>进程：ps aux</p><p>内存占用:free</p><p>CPU占用:top,</p><p>IO占用:iostat</p><p>虚拟内存统计:vmstat</p><p>sar</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>管道、共享内存、消息队列、套接字、信号、信号量</p><h2 id="fork的返回值，什么时候是子进程，什么时候是父进程"><a href="#fork的返回值，什么时候是子进程，什么时候是父进程" class="headerlink" title="fork的返回值，什么时候是子进程，什么时候是父进程"></a>fork的返回值，什么时候是子进程，什么时候是父进程</h2><p>子：0  父：子进程的pid</p><h2 id="进程和线程的区别以及孤儿、僵尸、守护进程"><a href="#进程和线程的区别以及孤儿、僵尸、守护进程" class="headerlink" title="进程和线程的区别以及孤儿、僵尸、守护进程"></a>进程和线程的区别以及孤儿、僵尸、守护进程</h2><h3 id="父进程、子进程："><a href="#父进程、子进程：" class="headerlink" title="父进程、子进程："></a><strong>父进程、子进程</strong>：</h3><p>父进程和子进程的关系是：子进程是父进程的一个副本，一个父进程能创建多个子进程，创建子进程能并发执行。一般来说，子进程先结束执行，然后父进程负责子进程的一些善后工作（回收资源）。</p><h3 id="孤儿进程："><a href="#孤儿进程：" class="headerlink" title="孤儿进程："></a><strong>孤儿进程</strong>：</h3><p>父进程运行结束，但子进程还在运行(未运行结束)的子进程就称为孤儿进程。孤儿进程最终会被init进程(进程号为1)所收养，因此init进程此时变成孤儿进程的父进程，并由init进程对它们完成状态收集工作。（linux下，init是内核启动的第一个用户级进程，init有许多很重要的任务，比如像启动getty（用于用户登录）、实现运行级别、以及处理孤立进程。）</p><h3 id="僵尸进程："><a href="#僵尸进程：" class="headerlink" title="僵尸进程："></a><strong>僵尸进程</strong>：</h3><p>一个进程使用fork创建子进程，如果子进程退出执行后，父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</p><p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。所以僵尸进程是有危害的。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程:"></a><strong>守护进程</strong>:</h3><p>守护进程也就是通常说的Daemon进程（精灵进程），是Linux中的后台服务进程，是个特殊的孤儿进程。它是一个生存期较长的进程，通常独立于控制终端（不会因为控制终端被关闭而中断）并且周期性地执行某种任务或等待处理某些发生的事件。举例：nignx、mysql、cron都是守护进程。</p><h2 id="讲讲守护进程"><a href="#讲讲守护进程" class="headerlink" title="讲讲守护进程"></a>讲讲守护进程</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的基础知识</title>
      <link href="/2018/11/18/C++%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/18/C++%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的基础知识"><a href="#C-的基础知识" class="headerlink" title="C++的基础知识"></a>C++的基础知识</h1><a id="more"></a><h2 id="C-的默认构造函数"><a href="#C-的默认构造函数" class="headerlink" title="C++的默认构造函数"></a>C++的默认构造函数</h2><p><strong>默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：</strong></p><ol><li><strong>没有带明显形参的构造函数。</strong></li><li><strong>提供了默认实参的构造函数。</strong>  </li></ol><p><strong>类设计者可以自己写一个默认构造函数。编译器帮我们写的默认构造函数，称为“合成的默认构造函数”。强调“没有带明显形参”的原因是，编译器总是会为我们的构造函数形参表插入一个隐含的this指针，所以”本质上”是没有不带形参的构造函数的，只有不带明显形参的构造函数，它就是默认构造函数。</strong></p><h2 id="C-类的构造顺序"><a href="#C-类的构造顺序" class="headerlink" title="C++类的构造顺序"></a>C++类的构造顺序</h2><ol><li>分配内存，在调用构造函数时候，隐式/显式的初始化各项在初始化列表的成员。</li><li>进入构造函数后在构造函数中执行一般的赋值与计算。</li></ol><h2 id="C-的初始化列表"><a href="#C-的初始化列表" class="headerlink" title="C++的初始化列表"></a>C++的初始化列表</h2><p><strong>对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表</strong>。但有的时候必须用带有初始化列表的构造函数：<br><strong>1.成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若程序员没有为类写默认构造函数，则编译器尝试使用默认构造函数将会失败。</strong><br><strong>2.const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值。</strong></p><h2 id="初始化数据成员与对数据成员赋值的含义是什么？有什么区别？"><a href="#初始化数据成员与对数据成员赋值的含义是什么？有什么区别？" class="headerlink" title="初始化数据成员与对数据成员赋值的含义是什么？有什么区别？"></a>初始化数据成员与对数据成员赋值的含义是什么？有什么区别？</h2><p><strong>在构造函数中再进行成员对象的赋值，这会导致成员对象被构造多次。 更重要的是，因为常量类型、引用类型的成员不接受赋值，它们只能在初始化列表中进行初始化。</strong></p><p>首先把数据成员按类型分类并分情况说明:<br>1.<strong>内置数据类型，复合类型（指针，引用）</strong><br>​    在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的<br>2.<strong>用户定义类型（类类型）</strong><br>​    结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行<strong>调用拷贝构造函数</strong>来构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）</p><h2 id="C-引用和指针的区别"><a href="#C-引用和指针的区别" class="headerlink" title="C++ 引用和指针的区别"></a>C++ 引用和指针的区别</h2><p>(1)当引用被创建时，它必须被初始化。而指针则可以在任何时候被初始化。</p><p>(2)一旦一个引用被初始化为指向一个对象，它就不能被改变为对另一个对象的引用。而指针则可以在任何时候指向另一个对象。</p><p>(3)不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</p><p>引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率</p><h2 id="C-中const和static的区别"><a href="#C-中const和static的区别" class="headerlink" title="C++中const和static的区别"></a>C++中const和static的区别</h2><p>const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。</p><p>​      static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。</p><p>​      在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static</p><p>​      在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。</p><p>​      const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。</p><p>const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。</p><h2 id="在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？"><a href="#在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？" class="headerlink" title="在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？"></a>在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？</h2><p>父构造函数–&gt;子构造函数–&gt;子析构函数–&gt;父析构函数</p><h2 id="在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为-virtual-吗？如果不申明为-virtual-会怎样？"><a href="#在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为-virtual-吗？如果不申明为-virtual-会怎样？" class="headerlink" title="在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？"></a>在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？</h2><p>构造函数不能够声明为virtual。因为创建对象之后虚函数表才开始创建。</p><h2 id="什么是-C-多态？C-多态的实现原理是什么？"><a href="#什么是-C-多态？C-多态的实现原理是什么？" class="headerlink" title="什么是 C++ 多态？C++ 多态的实现原理是什么？"></a>什么是 C++ 多态？C++ 多态的实现原理是什么？</h2><p>C++的多态分为静态多态和动态多态：</p><p>1.静态多态就是重载，因为在编译期决议确定，所以成为静态多态。</p><p>2.动态多态就是通过继承重写基类的虚函数实现的多态，因为是在运行时决议确定的所以称为动态多态。</p><p>C++的动态多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p><p>  1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  </p><p>  2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  </p><p>  3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  </p><p>  4：多态用虚函数来实现，结合动态绑定.  </p><p>  5:纯虚函数是虚函数再加上 = 0；  </p><p>  6：抽象类是指包括至少一个纯虚函数的类。</p><p>纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</p><h2 id="什么是虚函数？虚函数的实现原理是什么？"><a href="#什么是虚函数？虚函数的实现原理是什么？" class="headerlink" title="什么是虚函数？虚函数的实现原理是什么？"></a>什么是虚函数？虚函数的实现原理是什么？</h2><p>类中的<strong>成员函数</strong>分为<strong>静态成员函数</strong>和<strong>非静态成员函数</strong>，而<strong>非静态成员函数</strong>又分为<strong>普通函数</strong>和<strong>虚函数</strong>。</p><p>虚函数是用来实现动态绑定的。</p><p>虚函数使用虚函数表和虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的函数的地址（子类中可以不是<strong>虚</strong>函数，但是必须同名）；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应不同基类的虚函数表。</p><p><strong>虚函数表</strong>是每个（有虚函数的）<strong>类</strong>对应一个。<strong>虚函数表指针</strong>是每个<strong>对象</strong>对应一个。</p><p>虚函数表里只能存放虚函数，不能存放普通函数。</p><p>如果一个函数不是虚函数，那么对它的调用（即该函数的地址）在<strong>编译</strong>阶段就会确定。调用虚函数的话（它的地址）要<strong>运行</strong>时才能确定。</p><p>虚函数的函数入口是动态绑定的。在运行时，程序根据基类指针指向的<strong>实际对象</strong>，来调用<strong>该对象</strong>对应版本的函数。（用<strong>该对象</strong>的<strong>虚函数表指针</strong>找到其虚函数表，进而调用不同的函数。）（只有是<strong>虚函数</strong>的情况下才会这么做（用虚函数表指针去查虚函数表）。非虚函数直接就调用自己的。）</p><h2 id="为什么需要虚析构函数？（什么情况下要用虚析构函数？）"><a href="#为什么需要虚析构函数？（什么情况下要用虚析构函数？）" class="headerlink" title="为什么需要虚析构函数？（什么情况下要用虚析构函数？）"></a>为什么需要<strong>虚析构函数</strong>？（什么情况下要用虚析构函数？）</h2><p>在存在类继承并且析构函数中需要析构某些资源时，析构函数需要是虚函数。否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，造成内存泄露。</p><h2 id="一个对象访问普通成员函数和虚函数哪个更快？"><a href="#一个对象访问普通成员函数和虚函数哪个更快？" class="headerlink" title="一个对象访问普通成员函数和虚函数哪个更快？"></a><strong>一个对象访问普通成员函数和虚函数哪个更快？</strong></h2><p>访问普通成员函数更快，因为普通成员函数的<strong>地址</strong>在<strong>编译</strong>阶段就已确定，因此在访问时直接调用对应地址的函数；</p><p>而虚函数在调用时，需要首先在虚函数表中<strong>寻找</strong>虚函数所在<strong>地址</strong>，因此相比普通成员函数速度要慢一些。</p><h2 id="内联函数、构造函数、静态成员函数可以是虚函数吗？"><a href="#内联函数、构造函数、静态成员函数可以是虚函数吗？" class="headerlink" title="内联函数、构造函数、静态成员函数可以是虚函数吗？"></a>内联函数、构造函数、静态成员函数可以是虚函数吗？</h2><p>都不可以。</p><p><strong>内联函数</strong>（inline）需要在<strong>编译</strong>阶段展开（在编译时就已经确定了），而虚函数是<strong>运行时</strong>动态绑定的，编译时无法展开，因此是矛盾的；</p><p><strong>构造函数</strong>在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念（先有父类才能有子类，构造父类的时候子类还不存在，子类都还没有怎么可能在父类里动态调用子类）；</p><p><strong>静态成员函数</strong>（static）是以<strong>类</strong>为单位的函数，<strong>与具体对象无关</strong>，虚函数是与对象动态绑定的，因此是两个矛盾的概念；</p><h2 id="构造函数中可以调用虚函数吗？"><a href="#构造函数中可以调用虚函数吗？" class="headerlink" title="构造函数中可以调用虚函数吗？"></a>构造函数中可以调用虚函数吗？</h2><p> 可以，但是没有意义，起不到动态绑定的效果。父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。</p><h2 id="简述C-中虚继承的作用及底层实现原理"><a href="#简述C-中虚继承的作用及底层实现原理" class="headerlink" title="简述C++中虚继承的作用及底层实现原理?"></a>简述C++中虚继承的作用及底层实现原理?</h2><p>虚继承用于解决多继承条件下的<strong>菱形继承</strong>问题，底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。</p><h2 id="什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？"><a href="#什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？" class="headerlink" title="什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？"></a>什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？</h2><h2 id="菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？"><a href="#菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？" class="headerlink" title="菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？"></a>菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？</h2><h2 id="C-中虚继承的作用及底层实现原理"><a href="#C-中虚继承的作用及底层实现原理" class="headerlink" title="C++中虚继承的作用及底层实现原理"></a>C++中虚继承的作用及底层实现原理</h2><p><strong>虚继承和虚函数是完全无相关的两个概念。</strong></p><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。</p><p>虚继承可以解决多种继承前面提到的两个问题：</p><p>虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><p>在这里我们可以对比虚函数的实现原理：他们有相似之处，都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）。</p><p>虚基类依旧存在继承类中，只占用存储空间；虚函数不占用存储空间。</p><p>虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。</p><p>◇执行顺序<br>首先执行虚基类的构造函数，多个虚基类的构造函数按照被继承的顺序构造；<br>执行基类的构造函数，多个基类的构造函数按照被继承的顺序构造；<br>执行成员对象的构造函数，多个成员对象的构造函数按照申明的顺序构造；<br>执行派生类自己的构造函数；<br>析构以与构造相反的顺序执行； </p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>简单的来说，【浅拷贝】是增加了一个指针，指向原来已经存在的内存。而【深拷贝】是增加了一个指针，并新开辟了一块空间</p><p>让指针指向这块新开辟的空间。</p><p>【浅拷贝】在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误</p><p><a href="https://www.cnblogs.com/jianxinzhou/p/3994248.html" target="_blank" rel="noopener">https://www.cnblogs.com/jianxinzhou/p/3994248.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种常见的排序算法</title>
      <link href="/2018/11/18/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/18/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h1><p>本文来谈谈几种常见的排序算法</p><p><img src="/2018/11/18/几种常见的排序算法/1.jpg" alt="你想输入的替代文字"></p><a id="more"></a><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(1)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[min])</span><br><span class="line">&#123;</span><br><span class="line">min=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">swap(a,i,min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(1)</p><p>稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a)</span><span class="comment">//冒泡排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is_change=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;!is_change;i--)</span><br><span class="line">&#123;</span><br><span class="line">is_change=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">is_change=<span class="number">0</span>;</span><br><span class="line">swap(a,j,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(1)</p><p>稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charu_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a)</span><span class="comment">//插入排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;(a[j]&lt;a[j<span class="number">-1</span>]);j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a,j,j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(M)</p><p>稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> h)</span> <span class="comment">//归并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=h;k++)</span><br><span class="line">&#123;</span><br><span class="line">b[k]=a[k]; <span class="comment">//数组复制到辅助数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=h;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;m)</span><br><span class="line">a[k]=b[j++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j&gt;h)</span><br><span class="line">a[k]=b[i++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[i]&lt;=b[j])</span><br><span class="line">&#123;</span><br><span class="line">a[k]=b[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[k]=b[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将一个大数组分成两个小数组去求解。</span></span><br><span class="line"><span class="comment">//因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l ,<span class="keyword">int</span> h)</span><span class="comment">//自顶向下归并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h&lt;=l)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+(h-l)/<span class="number">2</span>;</span><br><span class="line">merge_sort(a,l,mid);</span><br><span class="line">merge_sort(a,mid+<span class="number">1</span>,h);</span><br><span class="line">merge(a,l,mid,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step/<span class="number">2</span>&lt;=N;step*=<span class="number">2</span>)  <span class="comment">//步长，每一次的跨度 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i+=step)</span><br><span class="line">&#123;</span><br><span class="line">sort(A+i,A+min(i+step,N));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">&#125;</span><br><span class="line">mergeSort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间复杂度O（n*log(n)）</p><p>空间复杂度O(logN)-O(logN)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=l,j=h+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> divide_num=a[l];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((a[++i]&lt;divide_num)&amp;&amp;i!=h);</span><br><span class="line"><span class="keyword">while</span>((a[--j]&gt;divide_num)&amp;&amp;j!=l);</span><br><span class="line"><span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,i,j);</span><br><span class="line">&#125; </span><br><span class="line">swap(a,l,j);</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span><span class="comment">//当前的快排只是取最左边的第一个数作为划分点。 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=h)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> j=partition(a,l,h);</span><br><span class="line">quick_sort(a,l,j<span class="number">-1</span>);</span><br><span class="line">quick_sort(a,j+<span class="number">1</span>,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>不稳定</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度O（n*log（n））</p><p>空间复杂度O(1)</p><p>不稳定</p><h1 id="桶排序的思想"><a href="#桶排序的思想" class="headerlink" title="桶排序的思想"></a>桶排序的思想</h1><p>非比较的排序：</p><h2 id="计数排序："><a href="#计数排序：" class="headerlink" title="计数排序："></a>计数排序：</h2><p>稳定</p><h2 id="基数排序："><a href="#基数排序：" class="headerlink" title="基数排序："></a>基数排序：</h2><p>稳定</p>]]></content>
      
      
      <categories>
          
          <category> 面向面试学习法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP/IP 协议</title>
      <link href="/2018/11/16/TCP-IP-%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/11/16/TCP-IP-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h1><p>本文对TCP的三次握手和四次挥手做一个简单的小结。</p><a id="more"></a><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><ul><li><p>get参数通过url传递，post放在request body中。</p></li><li><p>get请求在url中传递的参数是有长度限制的，而post没有。</p></li><li><p>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p></li><li><ul><li><p>get请求只能进行url编码，而post支持多种编码方式</p></li><li><p>get请求会浏览器主动cache，而post支持多种编码方式。</p></li><li><p>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p></li></ul></li><li><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p></li></ul><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h2 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h2><p><img src="http://dl2.iteye.com/upload/attachment/0108/8317/ef70c29e-651b-33a4-b188-d4e8e0ff9915.png" alt="img"></p><p>上图中有几个字段需要重点介绍下：</p><p>  （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>  （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=Seq+1。</p><p>  （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><p>  （A）URG：紧急指针（urgent pointer）有效。</p><p>  （B）ACK：确认序号有效。</p><p>  （C）PSH：接收方应该尽快将这个报文交给应用层。</p><p>  （D）RST：重置连接。</p><p>  （E）SYN：发起一个新连接。</p><p>  （F）FIN：释放一个连接。</p><p> 需要注意的是：</p><p>  （A）不要将确认序号ack与标志位中的ACK搞混了。</p><p>  （B）确认方Ack=发起方Req+1，两端配对。 </p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><p>  所谓<strong>三次握手</strong>（Three-Way Handshake）即建立TCP连接，<strong>是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立</strong>。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：</p><p><img src="http://dl2.iteye.com/upload/attachment/0108/8313/8352d9a8-8c91-32e5-adf8-2bdaf8d567d6.png" alt="img"></p><p>第一次握手，Client 发送一个SYN表示建立一个新的连接，生成一个seq序号。然后处于SYN_SENT状态。</p><p>第二次握手，Server收到了数据包后，发送一个新的数据包。SYN=1,ACK=1（表示）确认，ack=J+1（上一个数据包的seq序号+1），再随机生成一个seq。Server进入SYN_RCVD状态。</p><p>第三次握手，Client收到了数据包后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，<strong>如果正确则连接建立成功，Client和Server进入ESTABLISHED状态</strong>，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><p><strong><em>SYN攻击：</em></strong></p><p>  在三次握手过程中，<strong>Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态</strong>，当收到ACK后，Server转入ESTABLISHED状态。<strong>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时</strong>，这些<strong>伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃</strong>，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p><p>#netstat -nap | grep SYN_RECV</p>  <figure class="highlight plain"><figcaption><span>-nap | grep SYN_RECV</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### **四次挥手**</span><br><span class="line"></span><br><span class="line">所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：</span><br><span class="line"></span><br><span class="line">![img](http://dl2.iteye.com/upload/attachment/0108/8315/51a9937d-3155-3a95-b853-97e8e20e758b.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</span><br><span class="line"></span><br><span class="line"> （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</span><br><span class="line"></span><br><span class="line">  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</span><br><span class="line"></span><br><span class="line"> （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</span><br><span class="line"></span><br><span class="line">  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</span><br><span class="line"></span><br><span class="line">![img](http://dl2.iteye.com/upload/attachment/0108/8321/b32a11f5-7b60-364b-874d-67b096bec348.jpg)</span><br><span class="line"></span><br><span class="line">上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：</span><br><span class="line"></span><br><span class="line">![img](http://dl2.iteye.com/upload/attachment/0108/8323/f8d7bde0-fd48-334a-bf6d-6be0b1706f86.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### **四、附注**</span><br><span class="line"></span><br><span class="line">  关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的XDJM们参考：</span><br><span class="line"></span><br><span class="line">  （1）三次握手是什么或者流程？四次握手呢？答案前面分析就是。</span><br><span class="line"></span><br><span class="line">  （2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  这是因为**服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据**，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 2</title>
      <link href="/2018/11/16/Leetcode-2/"/>
      <url>/2018/11/16/Leetcode-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode 2"></a>Leetcode 2</h1><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode*p1=l1;</span><br><span class="line">        ListNode*p2=l2;</span><br><span class="line">        ListNode *l3=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *l4=l3;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>||p2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 temp+=p1-&gt;val;  </span><br><span class="line">                 p1=p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              temp+=p2-&gt;val ;</span><br><span class="line">              p2=p2-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            l3-&gt;next=<span class="keyword">new</span> ListNode(temp%<span class="number">10</span>);   </span><br><span class="line">            temp=temp/<span class="number">10</span>;</span><br><span class="line">            l3=l3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l3-&gt;next=<span class="keyword">new</span> ListNode(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l4-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 31</title>
      <link href="/2018/11/16/Leetcode-31/"/>
      <url>/2018/11/16/Leetcode-31/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-31-Next-Permutation"><a href="#Leetcode-31-Next-Permutation" class="headerlink" title="Leetcode 31 Next Permutation"></a>Leetcode 31 Next Permutation</h1><p>详情见图</p><a id="more"></a><p><a href="https://leetcode.com/media/original_images/31_Next_Permutation.gif" target="_blank" rel="noopener">https://leetcode.com/media/original_images/31_Next_Permutation.gif</a></p><p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [31] Next Permutation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/next-permutation/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (29.41%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    188.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 640.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,2,3]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implement next permutation, which rearranges numbers into the</span></span><br><span class="line"><span class="comment"> * lexicographically next greater permutation of numbers.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If such arrangement is not possible, it must rearrange it as the lowest</span></span><br><span class="line"><span class="comment"> * possible order (ie, sorted in ascending order).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The replacement must be in-place and use only constant extra memory.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Here are some examples. Inputs are in the left-hand column and its</span></span><br><span class="line"><span class="comment"> * corresponding outputs are in the right-hand column.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1,2,3 → 1,3,2</span></span><br><span class="line"><span class="comment"> * 3,2,1 → 1,2,3</span></span><br><span class="line"><span class="comment"> * 1,1,5 → 1,5,1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">            reverse(nums.begin(), nums.end()); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = nums.size() - <span class="number">1</span>; j &gt; i; j--) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">            reverse(nums.begin() + i + <span class="number">1</span>, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Delete repeated element</title>
      <link href="/2018/11/15/Delete-repeated-element/"/>
      <url>/2018/11/15/Delete-repeated-element/</url>
      
        <content type="html"><![CDATA[<h1 id="删除数组中相同的元素"><a href="#删除数组中相同的元素" class="headerlink" title="删除数组中相同的元素"></a>删除数组中相同的元素</h1><a id="more"></a><h2 id="leetcode-26"><a href="#leetcode-26" class="headerlink" title="leetcode 26"></a>leetcode 26</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [26] Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (38.30%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    454.3K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 1.2M</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,1,2]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a sorted array nums, remove the duplicates in-place such that each</span></span><br><span class="line"><span class="comment"> * element appear only once and return the new length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Do not allocate extra space for another array, you must do this by modifying</span></span><br><span class="line"><span class="comment"> * the input array in-place with O(1) extra memory.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [1,1,2],</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 2, with the first two elements of nums</span></span><br><span class="line"><span class="comment"> * being 1 and 2 respectively.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what you leave beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [0,0,1,1,1,2,2,3,3,4],</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 5, with the first five elements of nums</span></span><br><span class="line"><span class="comment"> * being modified to 0, 1, 2, 3, and 4 respectively.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what values are set beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Clarification:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Confused why the returned value is an integer but your answer is an array?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the input array is passed in by reference, which means</span></span><br><span class="line"><span class="comment"> * modification to the input array will be known to the caller as well.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Internally you can think of this:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="comment"> * int len = removeDuplicates(nums);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment"> * // using the length returned by your function, it prints the first len</span></span><br><span class="line"><span class="comment"> * elements.</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment"> * print(nums[i]);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> lens=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[lens++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lens;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-27"><a href="#Leetcode-27" class="headerlink" title="Leetcode 27"></a>Leetcode 27</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [27] Remove Element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-element/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (42.38%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    332.6K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 784.7K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[3,2,2,3]\n3'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given an array nums and a value val, remove all instances of that value</span></span><br><span class="line"><span class="comment"> * in-place and return the new length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Do not allocate extra space for another array, you must do this by modifying</span></span><br><span class="line"><span class="comment"> * the input array in-place with O(1) extra memory.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The order of elements can be changed. It doesn't matter what you leave</span></span><br><span class="line"><span class="comment"> * beyond the new length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [3,2,2,3], val = 3,</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 2, with the first two elements of nums</span></span><br><span class="line"><span class="comment"> * being 2.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what you leave beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [0,1,2,2,3,0,4,2], val = 2,</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 5, with the first five elements of nums</span></span><br><span class="line"><span class="comment"> * containing 0, 1, 3, 0, and 4.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the order of those five elements can be arbitrary.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what values are set beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Clarification:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Confused why the returned value is an integer but your answer is an array?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the input array is passed in by reference, which means</span></span><br><span class="line"><span class="comment"> * modification to the input array will be known to the caller as well.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Internally you can think of this:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="comment"> * int len = removeElement(nums, val);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment"> * // using the length returned by your function, it prints the first len</span></span><br><span class="line"><span class="comment"> * elements.</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment"> * print(nums[i]);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lens=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[lens]=nums[i];</span><br><span class="line">                lens++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lens;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP/IP 第一章</title>
      <link href="/2018/11/15/TCP-IP-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2018/11/15/TCP-IP-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP网络编程-第一章"><a href="#TCP-IP网络编程-第一章" class="headerlink" title="TCP/IP网络编程 第一章"></a>TCP/IP网络编程 第一章</h1><h2 id="创建套接字的过程"><a href="#创建套接字的过程" class="headerlink" title="创建套接字的过程"></a>创建套接字的过程</h2><a id="more"></a><h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handing</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">    <span class="keyword">char</span> message[]=<span class="string">"Hello world!"</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serv_sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"socker() error!"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);<span class="comment">//IP</span></span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>])); <span class="comment">//port</span></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handing(<span class="string">"bind()!error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">           error_handing(<span class="string">"listen()!error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    clnt_sock=accept(serv_sock,(struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            error_handing(<span class="string">"accept()!error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(clnt_sock,message,<span class="keyword">sizeof</span>(message));</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先创建socket套接字</li><li>用bind分配IP和端口号</li><li>用listen函数将socket转换成可以接收连接的状态</li><li>用accept函数接收请求连接</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">   <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">   <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>struct sockaddr 是通用的套接字地址，而struct sockaddr_in 是Internet环境下的套接字地址形式。两者的长度一样，都是16字节。两者是并列结构，指向sockaddr_in结构的指针也可以指向sockaddr。</p><p><strong>一般情况下，需要把sockaddr_in结构强制转换成sockaddr结构，再传入系统函数中</strong> </p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handing</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"socket()!error!"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"connect() error!"</span>);</span><br><span class="line">    </span><br><span class="line">    str_len=read(sock,message,<span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str_len==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"read()!error!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>,message);</span><br><span class="line">    close(sock);</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Deblur 论文总结</title>
      <link href="/2018/11/14/Deblur-%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/14/Deblur-%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h1><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>图像模糊一般被看作清晰图像卷积模糊核得到模糊图像的过程，其退化模型如下式所示：</p><p><img src="https://img-blog.csdn.net/20161010131848914" alt="img"></p><p>其中，B为模糊图像( blurry image )，I为待估计的清晰图像( latent image )，K为模糊核( blur kernel )，N为附加的噪声，ⓧ为卷积操作。</p><h3 id="图像卷积基本概念"><a href="#图像卷积基本概念" class="headerlink" title="图像卷积基本概念"></a>图像卷积基本概念</h3><h4 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h4><p>　　线性滤波是图像处理的基本方法。假设我们有图像矩阵A和滤波器矩阵（卷积核）B，如下图所示： </p><p><img src="https://img-blog.csdn.net/20161010152740621" alt="img"><img src="https://img-blog.csdn.net/20161010152826162" alt="img">   </p><p>​    对于图像的每一个像素点，计算它的邻域像素和滤波器矩阵的对应元素的乘积，然后加起来，作为该像素位置的值。这样就完成了滤波过程。 </p><p><img src="https://img-blog.csdn.net/20161010153027585" alt="img"></p><p><strong>卷积与相关</strong><br>　　对图像和滤波矩阵进行逐个元素相乘再求和的操作就相当于将一个二维的函数移动到另一个二维函数的所有位置，这个操作就叫卷积或者相关。卷积和相关的差别是，卷积需要先对滤波矩阵进行180的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。</p><p><strong>模糊核（卷积核）</strong><br>　　模糊核实际上就是一个矩阵，清晰图像与模糊核卷积后导致图像变得模糊，因此叫模糊核。模糊核是卷积核的一种。图像卷积操作的本质是矩阵卷积。某些特殊的卷积核会使图像产生特殊的效果。</p><h2 id="编码器-解码器网络-U-net"><a href="#编码器-解码器网络-U-net" class="headerlink" title="编码器-解码器网络(U-net)"></a>编码器-解码器网络(U-net)</h2><p><a href="http://www.bubuko.com/infodetail-2608619.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-2608619.html</a></p><p>卷积层负责特征提取，捕获图像内容的抽象信息，同时消除噪声/损失。相对应，反卷积层用来恢复图像细节。</p><h2 id="Scale-recurrent-Network-for-Deep-Image-Deblurring"><a href="#Scale-recurrent-Network-for-Deep-Image-Deblurring" class="headerlink" title="Scale-recurrent Network for Deep Image Deblurring"></a>Scale-recurrent Network for Deep Image Deblurring</h2><h2 id="尺度循环网络（SRN）"><a href="#尺度循环网络（SRN）" class="headerlink" title="尺度循环网络（SRN）"></a>尺度循环网络（SRN）</h2><h3 id="创新点："><a href="#创新点：" class="headerlink" title="创新点："></a>创新点：</h3><p><img src="http://static.tongtianta.site/paper_image/2520f142-6ae1-11e8-8a08-6045cb803e2f/image_1_0_0.jpg" alt="img"></p><p>用于图像处理的不同CNN。（a）U-Net [27]或编码器 - 解码器网络[24]。 （b）多尺度[25]或级联改良网络[4]。（c）扩张卷积网络[5]。（d）我们提出的规模经常性网络（SRN）。</p><ul><li><p><strong>网络结构上</strong>：在多尺度模型里，每一尺度的网络结构和任务都相似，但是各尺度的参数仍然是相互独立的。本文提出的在不同尺度之间共享网络权重可以减少网络参数、使模型的学习能力更加稳固。</p></li><li><p><strong>编解码残差网络结构：</strong>编解码器的结构在CV任务中非常有用，与残差网络相结合可以结合两者优势，还能扩大感受野，对于捕捉运动模糊很重要。本文设计的网络训练收敛快、参数少、去模糊效果好，超过了当前的最好水平。</p></li></ul><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作:"></a>相关工作:</h3><ul><li>利用图像的各种先验知识</li><li>带跳跃连接的自编码器</li><li>U-net(编解码器网络)</li><li>多尺度网络。</li></ul><h3 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a>网络结构：</h3><p><img src="https://img-blog.csdn.net/2018062313015729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI4NjM1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>在每一个尺度上，以两张图像作为输入，一张模糊图像，一张上采样后的去模糊图像。同时还在中间输入了隐藏状态的特征。循环网络用ConvLSTM.它能在利用时间相关性的同时利用空间相关性。不同尺度之间对图像和feature的上采样都使用双线性插值（bilinear interpolation），因为简单有效。</p>]]></content>
      
      
      <categories>
          
          <category> CV论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 误差建模 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode23</title>
      <link href="/2018/11/12/Leetcode23/"/>
      <url>/2018/11/12/Leetcode23/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h1><p>  √ Accepted<br>  √ 131/131 cases passed (20 ms)<br>  √ Your runtime beats 55.85 % of cpp submissions</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [23] Merge k Sorted Lists</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/merge-k-sorted-lists/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Hard (30.96%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    291.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 938.7K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[[1,4,5],[1,3,4],[2,6]]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Merge k sorted linked lists and return it as one sorted list. Analyze and</span></span><br><span class="line"><span class="comment"> * describe its complexity.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * 1-&gt;4-&gt;5,</span></span><br><span class="line"><span class="comment"> * 1-&gt;3-&gt;4,</span></span><br><span class="line"><span class="comment"> * 2-&gt;6</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> k=lists.size();</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k/<span class="number">2</span>;i++)</span><br><span class="line">                lists[i]=merge2List2(lists[i],lists[i+n]);</span><br><span class="line">            k=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode*<span class="title">merge2List2</span><span class="params">(ListNode*l1,ListNode*l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *ans1=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *ans = ans1;  </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ans-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)ans-&gt;next=l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">            ans-&gt;next=l1;</span><br><span class="line">        <span class="keyword">return</span> ans1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 10 Generate Parentheses</title>
      <link href="/2018/11/09/Leetcode10/"/>
      <url>/2018/11/09/Leetcode10/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-10-Regular-Expression-Matching"><a href="#Leetcode-10-Regular-Expression-Matching" class="headerlink" title="Leetcode 10 Regular Expression Matching"></a>Leetcode 10 Regular Expression Matching</h1><p>  √ Accepted<br>  √ 447/447 cases passed (4 ms)<br>  √ Your runtime beats 71.84 % of cpp submissions</p><a id="more"></a><figure class="highlight plain"><figcaption><span>Leetcode-22</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * [10] Regular Expression Matching</span><br><span class="line"> *</span><br><span class="line"> * https://leetcode.com/problems/regular-expression-matching/description/</span><br><span class="line"> *</span><br><span class="line"> * algorithms</span><br><span class="line"> * Hard (24.44%)</span><br><span class="line"> * Total Accepted:    240.5K</span><br><span class="line"> * Total Submissions: 984.1K</span><br><span class="line"> * Testcase Example:  &apos;&quot;aa&quot;\n&quot;a&quot;&apos;</span><br><span class="line"> *</span><br><span class="line"> * Given an input string (s) and a pattern (p), implement regular expression</span><br><span class="line"> * matching with support for &apos;.&apos; and &apos;*&apos;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * &apos;.&apos; Matches any single character.</span><br><span class="line"> * &apos;*&apos; Matches zero or more of the preceding element.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * The matching should cover the entire input string (not partial).</span><br><span class="line"> * </span><br><span class="line"> * Note:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * s could be empty and contains only lowercase letters a-z.</span><br><span class="line"> * p could be empty and contains only lowercase letters a-z, and characters</span><br><span class="line"> * like . or *.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 1:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;aa&quot;</span><br><span class="line"> * p = &quot;a&quot;</span><br><span class="line"> * Output: false</span><br><span class="line"> * Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 2:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;aa&quot;</span><br><span class="line"> * p = &quot;a*&quot;</span><br><span class="line"> * Output: true</span><br><span class="line"> * Explanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;.</span><br><span class="line"> * Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 3:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;ab&quot;</span><br><span class="line"> * p = &quot;.*&quot;</span><br><span class="line"> * Output: true</span><br><span class="line"> * Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 4:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;aab&quot;</span><br><span class="line"> * p = &quot;c*a*b&quot;</span><br><span class="line"> * Output: true</span><br><span class="line"> * Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore</span><br><span class="line"> * it matches &quot;aab&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 5:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;mississippi&quot;</span><br><span class="line"> * p = &quot;mis*is*p*.&quot;</span><br><span class="line"> * Output: false</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int lens=s.size();</span><br><span class="line">        int lenp=p.size();</span><br><span class="line">        bool **dp=new bool*[lens+2];</span><br><span class="line">        for(int i=0;i&lt;lens+2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=new bool[lenp+2];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;lens+2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;lenp+2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][0]=true;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;lenp;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[i]==&apos;*&apos;&amp;&amp;dp[0][i-1])</span><br><span class="line">                dp[0][i+1]=true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;lens;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;lenp;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(s[i]==p[j]||p[j]==&apos;.&apos;)</span><br><span class="line">                    dp[i+1][j+1]=dp[i][j];</span><br><span class="line">                else if(p[j]==&apos;*&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(p[j-1]!=s[i]&amp;&amp;p[j-1]!=&apos;.&apos;)</span><br><span class="line">                        dp[i+1][j+1]=dp[i+1][j-1];</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i+1][j+1]=(dp[i+1][j]//表示*匹配了1个字符</span><br><span class="line">                        ||dp[i][j+1]//表示*匹配了多个字符</span><br><span class="line">                        ||dp[i+1][j-1]);//表示*匹配了0个字符</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[lens][lenp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 22 Generate Parentheses</title>
      <link href="/2018/11/08/Leetcode22/"/>
      <url>/2018/11/08/Leetcode22/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-22-Generate-Parentheses"><a href="#Leetcode-22-Generate-Parentheses" class="headerlink" title="Leetcode 22 Generate Parentheses"></a>Leetcode 22 Generate Parentheses</h1><p>(  √ Accepted</p><p>√ 8/8 cases passed (0 ms)</p><p>√ Your runtime beats 31.94 % of cpp submissions )</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [22] Generate Parentheses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/generate-parentheses/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (50.99%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    261.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 513.5K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '3'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given n pairs of parentheses, write a function to generate all combinations</span></span><br><span class="line"><span class="comment"> * of well-formed parentheses.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * For example, given n = 3, a solution set is:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ "((()))",</span></span><br><span class="line"><span class="comment"> * ⁠ "(()())",</span></span><br><span class="line"><span class="comment"> * ⁠ "(())()",</span></span><br><span class="line"><span class="comment"> * ⁠ "()(())",</span></span><br><span class="line"><span class="comment"> * ⁠ "()()()"</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrade</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;ans,<span class="built_in">string</span> ans1,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(ans1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrade(ans,ans1+<span class="string">"("</span>,left<span class="number">-1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrade(ans,ans1+<span class="string">")"</span>,left,right<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        backtrade(res,<span class="string">""</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
