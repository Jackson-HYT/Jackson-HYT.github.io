<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>PAT-15</title>
      <link href="/2019/02/07/PAT-15/"/>
      <url>/2019/02/07/PAT-15/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>是解决单源最短路径问题。给定G（V,E）和起点s，求从起点s到其他顶点的最短距离。</p><p>dijstra算法基本模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">10000000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxn][maxn]; <span class="comment">//n为结点数，G定义邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[maxn]; <span class="comment">//记录开始点到各点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">//记录这个点是否访问过</span></span><br><span class="line"><span class="keyword">int</span> pre[maxn]; <span class="comment">//记录前驱结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span>    <span class="comment">//s为起始点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF); <span class="comment">//</span></span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//进行n次，分别求出s点到各个点的距离 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF; <span class="comment">//u用来记录每一次的最小值中介点 ,MIN记录最小的值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)   <span class="comment">//说明其他剩下的点和s不连通 </span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;  <span class="comment">//访问u</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)   <span class="comment">//遍历所有节点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];</span><br><span class="line">pre[v]=u; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,dis;  <span class="comment">//v是目标顶点，dis是边权值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//进行n次 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="comment">//说明已经没有点和s连通了 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+Adj[u][j].dis;</span><br><span class="line">pre[v]=u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m; <span class="comment">//边数 </span></span><br><span class="line"><span class="keyword">int</span> s; <span class="comment">//开始点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> v)</span> <span class="comment">//寻找路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==s)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">G[u][v]=w;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为做题不可能出现裸的dijkstra,依据第一标尺肯定会出现多条最短路径，所以要加入第二或者第三标尺判断。有两种办法。</p><ul><li>直接在dijkstra算法里面写</li><li>dijkstra只计算第一标尺，而且计算必须要求的包括最短路径数量和pre前结点。</li></ul><p>第一种的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,M;     <span class="comment">//点数，边数，起点，终点 </span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> w[maxn]=&#123;<span class="number">0</span>&#125;; <span class="comment">//记录s点到各点的最大点权</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn]=&#123;<span class="number">0</span>&#125;;    <span class="comment">//记录各点的点权</span></span><br><span class="line"><span class="keyword">int</span> num[maxn]=&#123;<span class="number">0</span>&#125;; <span class="comment">//记录到各点最短路径的数量 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line">w[s]=weight[s];</span><br><span class="line">num[s]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];</span><br><span class="line">w[v]=w[u]+weight[v];</span><br><span class="line">num[v]=num[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+G[u][v]==d[v])   <span class="comment">//出现多条最短路径的时候 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w[u]+weight[v]&gt;w[v])</span><br><span class="line">&#123;</span><br><span class="line">w[v]=w[u]+weight[v];</span><br><span class="line">&#125;</span><br><span class="line">num[v]+=num[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s,e;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;M&gt;&gt;s&gt;&gt;e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;weight[i]);</span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,w1;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w1);</span><br><span class="line">G[a][b]=w1;</span><br><span class="line">G[b][a]=w1;</span><br><span class="line">&#125; </span><br><span class="line">dijkstra(s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[e]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[e]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种的模板：</p><p>先是用dijkstra算法根据第一标尺得到一颗最短路径树，再在这颗最短路径树上进行第二第三标尺的计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pre[maxn];   <span class="comment">//记录前驱结点 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn];  </span><br><span class="line"><span class="keyword">int</span> n,m;   <span class="comment">//结点数 边数 </span></span><br><span class="line"><span class="keyword">int</span> st,ed;  <span class="comment">//st为起点，ed为终点 </span></span><br><span class="line"><span class="keyword">int</span> W[maxn];   <span class="comment">//记录 点权值</span></span><br><span class="line"><span class="keyword">int</span> V[maxn][maxn];   <span class="comment">//记录边 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">MIN=d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d[u]+G[u][v]&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+G[u][v];</span><br><span class="line">pre[v].clear();</span><br><span class="line">pre[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+G[u][v]==d[v])</span><br><span class="line">&#123;</span><br><span class="line">pre[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> optvalue=INF;   <span class="comment">//第二标尺的最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path,tempPath;   <span class="comment">//path为最优路径，tempPath临时路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=tempPath.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> id=tempPath[i];</span><br><span class="line">value+=W[id];    </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Edge_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tempPath.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=tempPath[i],idNext=tempPath[i<span class="number">-1</span>];</span><br><span class="line">value+=V[id][idNext];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span>    <span class="comment">//v为当前访问节点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==st)</span><br><span class="line">&#123;</span><br><span class="line">tempPath.push_back(v);</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;    <span class="comment">//存放临时路径temppath的第二标尺的值</span></span><br><span class="line"><span class="comment">//****** 计算第二标尺的值 </span></span><br><span class="line">value=Edge_val();</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****</span></span><br><span class="line"><span class="keyword">if</span>(value&lt;optvalue)</span><br><span class="line">&#123;</span><br><span class="line">optvalue=value;</span><br><span class="line">path=tempPath;</span><br><span class="line">&#125;</span><br><span class="line">tempPath.pop_back();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">tempPath.push_back(v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre[v].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(pre[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">tempPath.pop_back();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed; </span><br><span class="line">fill(G[<span class="number">0</span>],G[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[a][b]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V[a][b]);   <span class="comment">//边花费 </span></span><br><span class="line">G[b][a]=G[a][b];</span><br><span class="line">V[b][a]=V[a][b];</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(st);</span><br><span class="line">dfs(ed);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;path.size()&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d[ed]&lt;&lt;<span class="string">" "</span>&lt;&lt;optvalue&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>他可以解决存在负权边的问题。通常使用邻接表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;  <span class="comment">//邻接边的目标顶点 </span></span><br><span class="line"><span class="keyword">int</span> dis;   <span class="comment">//邻接边边权值 </span></span><br><span class="line">node(<span class="keyword">int</span> vv,<span class="keyword">int</span> diss):v(vv),dis(diss)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn]; </span><br><span class="line"><span class="keyword">int</span> n,m,st,ed,weight[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],w[maxn],num[maxn];  <span class="comment">//</span></span><br><span class="line"><span class="comment">//bool vis[maxn]=&#123;false&#125;;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">fill(w,w+maxn,<span class="number">0</span>);</span><br><span class="line">fill(num,num+maxn,<span class="number">0</span>);</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line">w[s]=weight[s];</span><br><span class="line">num[s]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解数组d </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)   <span class="comment">//进行n-1轮操作 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每一次都要遍历所有的边 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)       </span><br><span class="line">&#123;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u]+dis&lt;d[v])   <span class="comment">//以u作为中介点能够让v的路径更短 </span></span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+dis;</span><br><span class="line">w[v]=w[u]+weight[v];   <span class="comment">//更新点权</span></span><br><span class="line">num[v]=num[u];</span><br><span class="line">pre[v].clear();</span><br><span class="line">pre[v].insert(u); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis==d[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w[u]+weight[v]&gt;w[v])</span><br><span class="line">&#123;</span><br><span class="line">w[v]=w[u]+weight[v];   <span class="comment">//更新点权</span></span><br><span class="line">&#125;</span><br><span class="line">pre[v].insert(u);</span><br><span class="line">num[v]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=pre[v].begin();it!=pre[v].end();it++)</span><br><span class="line">&#123;</span><br><span class="line">num[v]+=num[*it];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;weight[i];    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v,wt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;wt;</span><br><span class="line">Adj[u].push_back(node(v,wt));</span><br><span class="line">Adj[v].push_back(node(u,wt));</span><br><span class="line">&#125;</span><br><span class="line">Bellman(st);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[ed]&lt;&lt;<span class="string">" "</span>&lt;&lt;w[ed]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><p>SPFA算法是在Bellman-Ford算法的基础上拓展的。利用了只有d[u]改变了，和u所连接的结点v才会改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;  <span class="comment">//邻接边的目标顶点 </span></span><br><span class="line"><span class="keyword">int</span> dis;   <span class="comment">//邻接边边权值 </span></span><br><span class="line">node(<span class="keyword">int</span> vv,<span class="keyword">int</span> diss):v(vv),dis(diss)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Adj[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn]=&#123;<span class="literal">false</span>&#125;;  <span class="comment">//记录点是否在队列中 </span></span><br><span class="line"><span class="keyword">int</span> n,d[maxn],num[maxn];  <span class="comment">//num记录的是点v进入队列的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fill(d,d+maxn,INF);</span><br><span class="line">fill(num,num+maxn,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;      <span class="comment">//队列的作用是如果某一点的d改变了，这个点就要加入队列 ，更新与这个点相连接的其他点 </span></span><br><span class="line">Q.push(s);</span><br><span class="line">inq[s]=<span class="literal">true</span>;</span><br><span class="line">num[s]++;</span><br><span class="line">d[s]=<span class="number">0</span>;    </span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=Q.front();   <span class="comment">//u为队首元素</span></span><br><span class="line">Q.pop();</span><br><span class="line">inq[u]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u]+dis&lt;d[v])</span><br><span class="line">&#123;</span><br><span class="line">d[v]=d[u]+dis;</span><br><span class="line"><span class="keyword">if</span>(!inq[v])  <span class="comment">//如果v不在队列中 </span></span><br><span class="line">&#123;</span><br><span class="line">Q.push(v);</span><br><span class="line">num[v]++;</span><br><span class="line">inq[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(num[v]&gt;=n)<span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//有可达负环 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis==d[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里写第二标尺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>Floyd算法是全源最短路径算法。它基于一个这样的思想：如果k作为中介点，使得</p><p>d  [ i ] [ k ]+d  [ k ] [ j ]&lt;d  [ i ] [ j ]，那么就更新d  [ i ] [ j ]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m ;<span class="comment">//点数和边数</span></span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn] ; <span class="comment">//记录的是i到j的最短距离 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)    <span class="comment">//当k作为中介点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果k到i和j都可达且 dis[i][k]+dis[k][j]&lt;dis[i][j]</span></span><br><span class="line"><span class="keyword">if</span>(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])</span><br><span class="line">&#123;</span><br><span class="line">dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-14</title>
      <link href="/2019/02/02/PAT-14/"/>
      <url>/2019/02/02/PAT-14/</url>
      
        <content type="html"><![CDATA[<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;    <span class="comment">//终点编号</span></span><br><span class="line"><span class="keyword">int</span> w;     <span class="comment">//边的权值 </span></span><br><span class="line">Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> ww):v(vv),w(ww)&#123;&#125;  <span class="comment">//构造函数 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Adj[maxn]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><ul><li>连通分量：是针对无向图来说的。</li><li>强连通分量：针对有向图而言，任意两个顶点可以各自通过一条有向路径连通，称之为这两个顶点强连通。</li></ul><h1 id="图的DFS和BFS模板"><a href="#图的DFS和BFS模板" class="headerlink" title="图的DFS和BFS模板"></a>图的DFS和BFS模板</h1><h2 id="图的DFS（邻接矩阵版本）"><a href="#图的DFS（邻接矩阵版本）" class="headerlink" title="图的DFS（邻接矩阵版本）"></a>图的DFS（邻接矩阵版本）</h2><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>有无访问和是否可达这里需要注意！</p><p>这是处理是否有环的关键。如果可以到达但是已经访问过了，说明是有环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];    <span class="comment">//n为最大顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问单个连通分支 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span>  <span class="comment">//u表示当前访问的节点，depth表示当前深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//***********以下中间写对u进行的一些操作，例如打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,u);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来对所有u能够到达的节点进行枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=INF)    <span class="comment">//如果v没有被访问，且u可以到达v </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(v,depth+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrace</span><span class="params">()</span>   <span class="comment">//遍历图 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)   <span class="comment">//访问不同的连通分支 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(u,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的DFS（邻接表版）"><a href="#图的DFS（邻接表版）" class="headerlink" title="图的DFS（邻接表版）"></a>图的DFS（邻接表版）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;    <span class="comment">//终点编号</span></span><br><span class="line"><span class="keyword">int</span> w;     <span class="comment">//边的权值 </span></span><br><span class="line">Node(<span class="keyword">int</span> vv,<span class="keyword">int</span> ww):v(vv),w(ww)&#123;&#125;  <span class="comment">//构造函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Adj[maxv];     <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span>   <span class="comment">//遍历连通分支 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//对u进行的操作写在下面 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Adj[u][i];     <span class="comment">//如果是node的话，应该写成Adj[u][i].v </span></span><br><span class="line"><span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">DFS(v,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrace</span><span class="params">()</span>   <span class="comment">//遍历图 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)   <span class="comment">//访问不同的连通分支 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(u,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的BFS（邻接矩阵）"><a href="#图的BFS（邻接矩阵）" class="headerlink" title="图的BFS（邻接矩阵）"></a>图的BFS（邻接矩阵）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,G[maxn][maxn];    <span class="comment">//n是总的节点数 </span></span><br><span class="line"><span class="keyword">bool</span> inq[maxn]=&#123;<span class="literal">false</span>&#125;;   <span class="comment">//记录是否加入队列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//遍历u所在的连通块 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">inq[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top=q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>；i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inq[i]==<span class="literal">false</span>&amp;&amp;G[top][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">inq[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">bfs(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的BFS（邻接表）"><a href="#图的BFS（邻接表）" class="headerlink" title="图的BFS（邻接表）"></a>图的BFS（邻接表）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Adj[maxn];   <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//顶点数</span></span><br><span class="line"><span class="keyword">bool</span> inq[maxn]=&#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(u);</span><br><span class="line">inq[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;Adj[top].size();v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i=Adj[top][v];</span><br><span class="line"><span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)   <span class="comment">//未曾入队 </span></span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">inq[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">bfs(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-13</title>
      <link href="/2019/02/02/PAT-13/"/>
      <url>/2019/02/02/PAT-13/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一颗完全二叉树，树中的每一个结点的值都不小于（或者说不大于）其左右孩子结点的值，以此来区分最大堆和最小堆。</p><p>以下是堆的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆是一个完全二叉树，因此使用数组来模拟堆</span></span><br><span class="line"><span class="comment">// 第1个结点在数组的第1号位，而且数组的第 i个结点的左孩子结点是在2i号位，右孩子是在2i+1 号位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;<span class="comment">// n是总节点个数 </span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span>  <span class="comment">//low是将要调整结点的数组下标，high一般为堆的最后一个元素的数组下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=low;      <span class="comment">//i是将要调整的结点 </span></span><br><span class="line"><span class="keyword">int</span> j=i*<span class="number">2</span>;    <span class="comment">//j存的是将要调整结点的左孩子的结点 </span></span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)   <span class="comment">//存在孩子结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((j+<span class="number">1</span>&lt;=high) &amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j])  <span class="comment">//存在右孩子，并且右孩子大于左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">j=j+<span class="number">1</span> ;     <span class="comment">//就让j存的是右孩子的结点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过上面那一步，j存放的一定是最大孩子结点</span></span><br><span class="line"><span class="keyword">if</span>(heap[j]&gt;heap[i])</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[i],heap[j]);</span><br><span class="line">i=j;       <span class="comment">//把i设置为将要调整的结点 </span></span><br><span class="line">j=i*<span class="number">2</span>; <span class="comment">//j继续是i的左孩子结点，继续进入循环 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;   <span class="comment">//不满足调整需求，跳出循环 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span>   <span class="comment">//从后往前遍历，从n/2处，刚好是非叶子结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">downAdjust(i,n);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span>   <span class="comment">//删除堆顶元素，要把最后一个元素覆盖在堆顶 ，再向下调整 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[<span class="number">1</span>]=heap[n--];  <span class="comment">//最后一个元素覆盖堆顶 </span></span><br><span class="line">downAdjust(<span class="number">1</span>,n);  <span class="comment">//再向下调整 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=high;<span class="comment">//i是将要调整的结点 </span></span><br><span class="line"><span class="keyword">int</span> j=i/<span class="number">2</span>;<span class="comment">//j是i的父亲节点</span></span><br><span class="line"><span class="keyword">while</span>(j&gt;=low)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(heap[j]&lt;heap[i])<span class="comment">//如果父亲节点小于将要调整的节点</span></span><br><span class="line">&#123;</span><br><span class="line">swap(heap[i],heap[j]);</span><br><span class="line">i=j;   <span class="comment">//i继续变成将要调整的节点 </span></span><br><span class="line">j=i/<span class="number">2</span>;<span class="comment">//j继续是i的父亲节点 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[++n]=x;</span><br><span class="line">upAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序的思想</span></span><br><span class="line"><span class="comment">//把堆顶元素和最后一个元素交换，然后在[1,n-1]的范围内进行downAdjust</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">create();  <span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;heap[i]);</span><br><span class="line">heapSort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==n)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,heap[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,heap[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>哈夫曼树叶子节点×叶子节点到顶点的路径长度=这个叶子节点的带权路径长度。</p><p>一般使用优先队列或者堆来实现。</p><p>每次从优先队列或者堆中取出两个元素，再把其相加的和放回队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ll,<span class="built_in">vector</span>&lt;ll&gt;,greater&lt;ll&gt; &gt;q;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll temp,x,y,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">q.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">y=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">q.push(x+y);</span><br><span class="line">ans+=(x+y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-12</title>
      <link href="/2019/02/01/PAT-12/"/>
      <url>/2019/02/01/PAT-12/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>以下是AVL树的模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;  <span class="comment">//权值</span></span><br><span class="line"><span class="keyword">int</span> height;  <span class="comment">//子树的高度</span></span><br><span class="line">node* lchild;<span class="comment">//左子树 </span></span><br><span class="line">node* rchild; <span class="comment">//右子树 </span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span>    <span class="comment">//建立新的结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node*Node =<span class="keyword">new</span> node;</span><br><span class="line">Node-&gt;v=v;</span><br><span class="line">Node-&gt;height=<span class="number">1</span>;  <span class="comment">//初始高度为1</span></span><br><span class="line">Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node*root)</span>  <span class="comment">//获取当前结点的高度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************基本操作</span></span><br><span class="line"><span class="comment">//1.查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node*root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"search failed!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;v==x)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;v&gt;x)</span><br><span class="line">search(root-&gt;lchild,x);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">search(root-&gt;rchild,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">//L左旋</span></span><br><span class="line"><span class="comment">//让root的右子树的左子树成为root的新的右子树，再让原来root的右子树的左子树指向toot，使得其成为新的root</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node*&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node *temp=root-&gt;rchild;</span><br><span class="line">root-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">temp-&gt;lchild=root;</span><br><span class="line">updateHeight(root);   <span class="comment">//更新高度必须从下往上更新 </span></span><br><span class="line">updateHeight(temp);</span><br><span class="line">root=temp;     <span class="comment">//更新root </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//R 右旋</span></span><br><span class="line"><span class="comment">//同理，先让root的左子树变成root左子树的右子树，再让root的右子树的右子树变成root</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node*temp=root-&gt;lchild;</span><br><span class="line">root-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">temp-&gt;rchild=root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(temp);</span><br><span class="line">root=temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> v)</span>    <span class="comment">//插入 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=newNode(v);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(x&lt;root-&gt;v)</span><br><span class="line">&#123;</span><br><span class="line">insert(root-&gt;lchild,v);</span><br><span class="line">updateHeight(root);<span class="comment">//更新树的高度,因为是递归的原因，所有每一层回溯都会更新树高</span></span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">2</span>)   <span class="comment">//平衡被破坏 </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">1</span>) <span class="comment">//LL型    //判断是哪一种类型的 </span></span><br><span class="line"> &#123;</span><br><span class="line"> R(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">-1</span>)  <span class="comment">//LR型</span></span><br><span class="line">&#123;</span><br><span class="line">L(root-&gt;lchild);<span class="comment">//先转root结点的左结点 ，变成LL型 </span></span><br><span class="line">R(root);<span class="comment">//再转root结点 </span></span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//x大于等于root-&gt;v </span></span><br><span class="line">&#123;</span><br><span class="line">insert(root-&gt;rchild,v);</span><br><span class="line">updateHeight(root);</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">-2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">-1</span>)  <span class="comment">//RR型</span></span><br><span class="line">&#123;</span><br><span class="line">L(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild )==<span class="number">1</span>)   <span class="comment">//RL型 </span></span><br><span class="line">&#123;</span><br><span class="line">R(root-&gt;rchild);</span><br><span class="line">L(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node*root=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">insert(root,data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集模板只有两个操作，一个是查找，一个是合并，很好理解。</p><ul><li>首先一开始都是要初始化，把每一个结点的父节点都设置为自己。</li><li>然后就是查找父节点这个操作</li><li>最后就是通过合并父节点然后合并多个集合这个操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1001</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">bool</span> is_father[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span>   <span class="comment">//初始化，刚开始，每个点的根结点都是自己 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">father[i]=i;</span><br><span class="line">is_father[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> faA=findFather(a);</span><br><span class="line"><span class="keyword">int</span> faB=findFather(b);</span><br><span class="line"><span class="keyword">if</span>(faA!=faB)</span><br><span class="line">father[faA]=faB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//复杂度为O（1）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=x;</span><br><span class="line"><span class="keyword">while</span>(x!=father[x])  <span class="comment">//找到x的根节点 </span></span><br><span class="line">x=father[x];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(a!=father[a])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> z=a;</span><br><span class="line">a=father[a];</span><br><span class="line">father[z]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">init(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">Union(a,b);   <span class="comment">//合并a,b所在的集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;   </span><br><span class="line"><span class="comment">//cout&lt;&lt;findFather[i]&lt;&lt;"   "&lt;&lt;father[i]&lt;&lt;endl;</span></span><br><span class="line">is_father[findFather(i)]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(is_father[i]==<span class="literal">true</span>)</span><br><span class="line">ans++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-11</title>
      <link href="/2019/01/31/PAT-11/"/>
      <url>/2019/01/31/PAT-11/</url>
      
        <content type="html"><![CDATA[<h1 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h1><p>一般来说，树的定义都是使用静态定义。而不是动态的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数据</span></span><br><span class="line"><span class="keyword">int</span> layer;  <span class="comment">//层数 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;   <span class="comment">//记录子节点的编号 </span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>输入的时候也是要注意，输入结点的权值和结点的子节点。</p><h2 id="树的先根序遍历"><a href="#树的先根序遍历" class="headerlink" title="树的先根序遍历"></a>树的先根序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> root)</span><span class="comment">//树的先根序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,Node[root].data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">preOrder(Node[root].child[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(root);</span><br><span class="line">Node[root].layer=<span class="number">0</span>;   <span class="comment">//根结点的层号记录为0 </span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[top].data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[top].child.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">q.push(Node[top].child[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A1053"><a href="#A1053" class="headerlink" title="A1053"></a>A1053</h1><p>使用了dfs进行树的深搜。而bfs一般对于树的广搜.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1001</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> layer;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;chird;</span><br><span class="line">&#125;;</span><br><span class="line">node Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Node[a].data&gt;Node[b].data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,S;<span class="comment">// N 结点数，S总和，M 输入的行数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;S;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Node[i].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> No,num;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;No&gt;&gt;num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">Node[No].chird.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">sort(Node[No].chird.begin(),Node[No].chird.end(),cmp);   <span class="comment">//排序 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp,<span class="keyword">int</span> sum)</span>   <span class="comment">//root当前处理的结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sum&gt;S)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum==S)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Node[root].chird.size()!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[temp[i]].data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[temp[i]].data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;S)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].chird.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(Node[root].chird[i]);  </span><br><span class="line"> </span><br><span class="line">dfs(Node[root].chird[i],temp,sum+Node[Node[root].chird[i]].data);   </span><br><span class="line"></span><br><span class="line">temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">input();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t1;</span><br><span class="line">t1.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout&lt;&lt;"-----------"&lt;&lt;endl;</span></span><br><span class="line">dfs(<span class="number">0</span>,t1,Node[<span class="number">0</span>].data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>BST的特点:</p><p>（1）要么二叉搜索树是一颗空树</p><p>（2）要么二叉搜索树由根结点，左子树和右子树组成。左子树和右子树也是二叉搜索树。左子树上的所有结点的数据都小于等于根节点的数据，右子树上的所有结点数都大于根节点的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-10</title>
      <link href="/2019/01/30/PAT-10/"/>
      <url>/2019/01/30/PAT-10/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>树的基本定义：</p><ul><li>如果一棵树没有节点，称为空树。</li><li>树的层次从根节点开始算起，即根节点为第一层。</li><li>把结点的子树棵树称为结点的度，而树中结点的最大度称为树的度。</li><li><strong>对于一个结点树为n的树，其边数一定为n-1（保证了没有环）。并且，如果满足连通，边数等于顶点数-1的结构一定是一棵树。</strong></li><li>叶子节点的度数为0，如果一棵树中只有一个根节点也算是叶子节点。</li><li>结点的深度是指从根节点（深度为1）开始自顶而下逐层累加至该结点时的深度值。结点的高度是指从最底层叶子结点（高度为1）开始自底向上逐层累加至该结点的最高值（最长路径）。对于树而言，深度和高度是相等的。</li><li>森林是多颗树的集合</li></ul><h2 id="几种二叉树的定义"><a href="#几种二叉树的定义" class="headerlink" title="几种二叉树的定义"></a>几种二叉树的定义</h2><h4 id="满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。"><a href="#满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。" class="headerlink" title="满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。"></a>满二叉树：每一层的结点个数都达到了当层结点能够达到的最大结点数。</h4><h4 id="完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。"><a href="#完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。" class="headerlink" title="完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。"></a>完全二叉树：除了最下面一层，其余各层的结点个数都达到了当层能够达到的最大结点数，且最下面一层只从左至右连续存在若干个结点。</h4><p>完全二叉树的存储结构：</p><p>对于完全二叉树中任意一个节点编号为x，其左节点的编号为2x，右节点的编号为2x+1.  也就是说完全二叉树可以使用一个2的k次方大的数组去存储所有节点的信息，其中K为完全二叉树的最大高度，且1号位必须存储根节点（不使用0号位存储根节点）。这个数组存放顺序刚好为这个完全二叉树的层次遍历顺序。</p><p>重要结论：</p><p>如何判断一个结点有没有叶子节点？</p><p>只需要判断这个结点的左节点2x是否大于总个数n。如果大于总个数n说明没有子结点，那么他就是叶子结点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP-网络编程-1</title>
      <link href="/2019/01/30/TCP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/"/>
      <url>/2019/01/30/TCP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP网络编程的第一天"><a href="#TCP网络编程的第一天" class="headerlink" title="TCP网络编程的第一天"></a>TCP网络编程的第一天</h1><p>总结几个常用的函数</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><h3 id="Linux-下"><a href="#Linux-下" class="headerlink" title="Linux 下"></a>Linux 下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="comment">// domain</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr *myaddr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 成返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//成功返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="comment">//path文件的字符串地址</span></span><br><span class="line"><span class="comment">//flag 打开模式</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1；</span></span><br><span class="line"><span class="comment">//fd是要打开的文件描述符</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">//成功返回写入的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">//fd 显示数据传输对象的文件描述符</span></span><br><span class="line"><span class="comment">//buf 写入的数据首地址</span></span><br><span class="line"><span class="comment">// 要写入的数据字节数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// fd  显示数据接收对象的文件描述符</span></span><br><span class="line"><span class="comment">// buf  要保存接受数据的首地址</span></span><br><span class="line"><span class="comment">// nbytes 要接收数据的最大字节数</span></span><br></pre></td></tr></table></figure><h3 id="WINDOWS下"><a href="#WINDOWS下" class="headerlink" title="WINDOWS下"></a>WINDOWS下</h3><p>以下两个函数只是初始化Winsock库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested,LPWSADATA lpWSAData)</span></span>;</span><br><span class="line"><span class="comment">//WORD类型实际是是unsigned short类型（int只取正数）</span></span><br><span class="line"><span class="comment">//wVersionRequested，套接字版本信息，如果是1.2，1代表主版本号，2表示副版本号，应该写成0x0201。经常使用MAKEWORD（1，2）返回值构造。</span></span><br><span class="line"><span class="comment">//LPWSADATA是WSADATA的指针类型，需要传递的是WSADATA结构体的变量地址。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，失败返回SOCKET_ERROR。通常只在程序结束的时候调用</span></span><br></pre></td></tr></table></figure><p>接下来介绍和Linux对应的的套接字函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//成功返回句柄，失败返回-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET s,<span class="keyword">const</span> struct sockaddr* name,<span class="keyword">int</span> namelen)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-9</title>
      <link href="/2019/01/29/PAT-9/"/>
      <url>/2019/01/29/PAT-9/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS入门"><a href="#BFS入门" class="headerlink" title="BFS入门"></a>BFS入门</h1><p>bfs模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">   取出栈顶元素top</span><br><span class="line">        访问栈顶元素</span><br><span class="line">        将栈顶元素弹出栈</span><br><span class="line">        把取出的栈顶元素top下一层节点中未曾入队列入队，并设置入队状态。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> matrix[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=n||x&lt;<span class="number">0</span>||y&gt;=m||y&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(matrix[x][y]==<span class="number">0</span>||inq[x][y]==<span class="literal">true</span>)    <span class="comment">//不可以访问的地方，或者是已经访问过了的地方 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node Node;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;Q;</span><br><span class="line">Node.x=x;</span><br><span class="line">Node.y=y;</span><br><span class="line">Q.push(Node);</span><br><span class="line">inq[x][y]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line">node temp=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> newX=temp.x+X[i];</span><br><span class="line"><span class="keyword">int</span> newY=temp.y+Y[i];</span><br><span class="line"><span class="keyword">if</span>(judge(newX,newY))</span><br><span class="line">&#123;</span><br><span class="line">Node.x=newX;</span><br><span class="line">Node.y=newY;</span><br><span class="line">Q.push(Node);</span><br><span class="line">inq[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;matrix[i][j]);</span><br><span class="line">inq[i][j]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>&amp;&amp;inq[i][j]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">bfs(i,j);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**6 7</span></span><br><span class="line"><span class="comment">0 1 1 1 0 0 1</span></span><br><span class="line"><span class="comment">0 0 1 0 0 0 0</span></span><br><span class="line"><span class="comment">0 0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">0 0 0 1 1 1 0</span></span><br><span class="line"><span class="comment">1 1 1 0 1 0 1</span></span><br><span class="line"><span class="comment">1 1 1 1 0 0 0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//ans=5</span></span><br></pre></td></tr></table></figure><h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p>这里需要注意的是结构体的定义，需要加入一个step记录步数。也可以加入其他元素去记录上一个节点，方便打印出路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> matrix[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">//记录迷宫 </span></span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">105</span>][<span class="number">105</span>]=&#123;<span class="literal">false</span>&#125;;   <span class="comment">//记录是否走过 </span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y; </span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line">node Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=n||x&lt;<span class="number">0</span>||y&gt;=m||y&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(matrix[x][y]==<span class="string">'*'</span>||inq[x][y]==<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">Node.x=x;</span><br><span class="line">Node.y=y;</span><br><span class="line">Node.step=<span class="number">0</span>;</span><br><span class="line">q.push(Node);</span><br><span class="line">inq[x][y]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">node top=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(matrix[top.x][top.y]==<span class="string">'T'</span>)</span><br><span class="line"><span class="keyword">return</span> top.step;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> newX=top.x+X[i];</span><br><span class="line"><span class="keyword">int</span> newY=top.y+Y[i];</span><br><span class="line"><span class="comment">/*if(newX==endx&amp;&amp;newY=endy)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ans++;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">if</span>(judge(newX,newY))</span><br><span class="line">&#123;</span><br><span class="line">Node.x=newX;</span><br><span class="line">Node.y=newY;</span><br><span class="line">Node.step=top.step+<span class="number">1</span>;</span><br><span class="line">q.push(Node);</span><br><span class="line">inq[newX][newY]=<span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> sx,sy;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scanf("%c",&amp;c);</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">matrix[i][j]=c;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'S'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;sx&lt;&lt;" "&lt;&lt;sy&lt;&lt;endl;</span></span><br><span class="line">ans=bfs(sx,sy);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-8</title>
      <link href="/2019/01/28/PAT-8/"/>
      <url>/2019/01/28/PAT-8/</url>
      
        <content type="html"><![CDATA[<h1 id="A1002"><a href="#A1002" class="headerlink" title="A1002"></a>A1002</h1><p>这题实际上是非常简单的一道题，</p><p>主要是从中学会了两个知识点。</p><h2 id="对于map根据value的排序方法，巩固了一下之前学过的内容。"><a href="#对于map根据value的排序方法，巩固了一下之前学过的内容。" class="headerlink" title="对于map根据value的排序方法，巩固了一下之前学过的内容。"></a>对于map根据value的排序方法，巩固了一下之前学过的内容。</h2><p>首先需要创建一个pair的vector，只有将map中的pair放到了vector中才能够用搜sort进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt; test(mp.begin(),mp.end());</span><br></pre></td></tr></table></figure><p>然后写一个cmp函数,注意这里cmp函数的参数是pair。</p><p>pair.first是key，pair.second是value。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.first&gt;b.first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再用sort进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(test.begin(),test.end(),cmp);</span><br></pre></td></tr></table></figure><h2 id="在使用容器的erase删除容器元素的时候需要注意一点。"><a href="#在使用容器的erase删除容器元素的时候需要注意一点。" class="headerlink" title="在使用容器的erase删除容器元素的时候需要注意一点。"></a>在使用容器的erase删除容器元素的时候需要注意一点。</h2><p><strong>注意！erase()的返回值是指向下一个元素的迭代器。如果你在循环中使用erase删除的时候需要特别注意！</strong></p><p>应该写成如下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt;::iterator it=test.begin();it!=test.end();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(it-&gt;second==<span class="number">0</span>)</span><br><span class="line">it=test.erase(it);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上形式是标准形式。</p><p>本题全部代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K1,K2;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; mp;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool cmp(double a, double b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return a&lt;b;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.first&gt;b.first; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;K1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>,&amp;a,&amp;N);</span><br><span class="line">mp[a]+=N; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;K2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K2;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>,&amp;a,&amp;N);</span><br><span class="line">mp[a]+=N; </span><br><span class="line"><span class="comment">/*if(mp[a]==0)可以在这里就直接删除了 </span></span><br><span class="line"><span class="comment">mp.erase(a);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt; test(mp.begin(),mp.end());</span><br><span class="line">sort(test.begin(),test.end(),cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; &gt;::iterator it=test.begin();it!=test.end();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(it-&gt;second==<span class="number">0</span>)</span><br><span class="line">it=test.erase(it);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">it++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d %0.1lf"</span>,test[i].first,test[i].second);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>由于自己的懒惰，所以今天没怎么学习。现在补上。</p><p>看着思路做了一道模板题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">101</span>]; </span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> W,<span class="keyword">int</span> V)</span>   <span class="comment">//index是指当前处理的物品，W是指背包剩余容量 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(W&lt;<span class="number">0</span>)<span class="comment">//剪枝操作 </span></span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">if</span>(index==N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(maxn&lt;V&amp;&amp;W&gt;=<span class="number">0</span>)</span><br><span class="line">maxn=V;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(W&lt;w[index])</span></span><br><span class="line">dfs(index+<span class="number">1</span>,W,V);   <span class="comment">//处理当前物品 </span></span><br><span class="line"></span><br><span class="line">dfs(index+<span class="number">1</span>,W-w[index],V+c[index]);   <span class="comment">//不处理当前物品。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N&gt;&gt;V;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">dfs(<span class="number">0</span>,V,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归入门—-全排列"><a href="#递归入门—-全排列" class="headerlink" title="递归入门—-全排列"></a>递归入门—-全排列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> is_use[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t1.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=t1.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(is_use[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">is_use[i]=<span class="number">1</span>;</span><br><span class="line">t1.push_back(i);</span><br><span class="line">dfs(index+<span class="number">1</span>,t1);</span><br><span class="line">t1.pop_back();</span><br><span class="line">is_use[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">dfs(<span class="number">0</span>,temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归入门—组合的输出"><a href="#递归入门—组合的输出" class="headerlink" title="递归入门—组合的输出"></a>递归入门—组合的输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">25</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t1)</span>   <span class="comment">//n1存储当前已经用了的数字个数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//if(t1.size()&gt;=2&amp;&amp;t1[t1.size()-1]&lt;t1[t1.size()-2])   //后一位一定比前一位大 ，以这个为条件可以判断 </span></span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line"><span class="keyword">if</span>(n1==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t1.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=t1.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(t1.size()!=<span class="number">0</span>)</span><br><span class="line">start=t1[t1.size()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]==<span class="number">0</span>)  <span class="comment">//没有用过这个数字 </span></span><br><span class="line">&#123;</span><br><span class="line">num[i]=<span class="number">1</span>;</span><br><span class="line">t1.push_back(i);</span><br><span class="line">dfs(n1+<span class="number">1</span>,t1);</span><br><span class="line">t1.pop_back();</span><br><span class="line">num[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r;</span><br><span class="line"><span class="comment">//count=</span></span><br><span class="line">dfs(<span class="number">0</span>,temp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合-判断素数"><a href="#组合-判断素数" class="headerlink" title="组合+判断素数"></a>组合+判断素数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; temp;</span><br><span class="line">ll num[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll count1=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;ll&gt;t1)</span> <span class="comment">//dfs的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==k)</span><br><span class="line">&#123;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;t1.size();i++)</span><br><span class="line">sum+=num[t1[i]];</span><br><span class="line"><span class="keyword">if</span>(is_prime(sum))</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(t1.size()!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">start=t1[t1.size()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=start;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=<span class="number">1</span>;</span><br><span class="line">t1.push_back(i);</span><br><span class="line">dfs(index+<span class="number">1</span>,t1);</span><br><span class="line">t1.pop_back();</span><br><span class="line">p[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">dfs(<span class="number">0</span>,temp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> count1;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp)</span>   <span class="comment">//index 表示处理到第index行，temp保存 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;index&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,temp[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,temp[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//为行选列 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="number">0</span>)  <span class="comment">//没有用过 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.size();j++)<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;abs(j+1-index)&lt;&lt;" "&lt;&lt;abs(temp[j]-i)&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(j+<span class="number">1</span>-index)==<span class="built_in">abs</span>(temp[j]-i))  <span class="comment">//对角线 </span></span><br><span class="line">&#123;</span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=<span class="number">1</span>;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">dfs(index+<span class="number">1</span>,temp);</span><br><span class="line">temp.pop_back();</span><br><span class="line">p[i]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="comment">//for(int i=0;i&lt;)</span></span><br><span class="line">dfs(<span class="number">1</span>,ans);</span><br><span class="line"><span class="keyword">if</span>(count1==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"no solute!"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                                </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-7</title>
      <link href="/2019/01/27/PAT-7/"/>
      <url>/2019/01/27/PAT-7/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列的使用"><a href="#栈和队列的使用" class="headerlink" title="栈和队列的使用"></a>栈和队列的使用</h1><h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><p>这题没有括号的约束。</p><p><strong>主要思路：</strong></p><ul><li>最重要的一点！将中缀表达式变化成后缀表达式</li><li>对于符号的优先级处理，如果当前字符串的符号优先级<strong>大于</strong>符号栈顶的符号优先级，就把当前符号压入符号栈。1</li><li>如果当前字符的符号优先级<strong>小于等于</strong>符号栈顶的符号优先级，一直将符号栈里的符号弹出到后缀表达式中直到栈顶符号优先级大于当前符号优先级。<strong>最后将当前字符符号压入符号栈。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> num;<span class="comment">//操作数</span></span><br><span class="line"><span class="keyword">char</span> op ;<span class="comment">// 操作符</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">//true表示操作数</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">stack</span>&lt;node&gt; sta1;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que1;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i++]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.length()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.num=temp.num*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">que1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//如果当前操作符的优先级小于栈顶操作符优先级 就不断的把栈顶的弹出来， </span></span><br><span class="line"><span class="keyword">while</span>(!sta1.empty()&amp;&amp;mp[sta1.top().op]&gt;=mp[str[i]])</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node cur,temp;</span><br><span class="line"><span class="keyword">while</span>(!que1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=que1.front();</span><br><span class="line">que1.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.flag==<span class="literal">true</span>)</span><br><span class="line">sta1.push(cur);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp2=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line">temp1=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line"></span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cur.op==<span class="string">'+'</span>)temp.num=temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'-'</span>)temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'*'</span>)temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp.num=temp1/temp2;</span><br><span class="line">sta1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sta1.top().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp[<span class="string">'+'</span>]=mp[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">mp[<span class="string">'*'</span>]=mp[<span class="string">'/'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str),str!=<span class="string">"0"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>)</span><br><span class="line">str.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">deal();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,cal());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂计算器"><a href="#复杂计算器" class="headerlink" title="复杂计算器"></a>复杂计算器</h2><p>这题有了括号的约束，但是总体思路不变，在简单计算器的基础上只加入了一段代码即可。</p><p>主要思路：</p><ul><li>当碰到表达式中的左括号’(‘时候，需要将其压入栈中</li><li>碰到右括号的时候，一直将符号栈中的栈顶符号弹出到后缀表达式，直到碰到左括号。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(sta1.top().op!=<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">sta1.pop();</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------</span></span><br></pre></td></tr></table></figure><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> num;<span class="comment">//操作数</span></span><br><span class="line"><span class="keyword">char</span> op ;<span class="comment">// 操作符</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">//true表示操作数</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">stack</span>&lt;node&gt; sta1;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que1;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i++]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.length()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.num=temp.num*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">que1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(sta1.top().op!=<span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">sta1.pop();</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">//如果当前操作符的优先级小于栈顶操作符优先级 就不断的把栈顶的弹出来， </span></span><br><span class="line"><span class="keyword">while</span>(!sta1.empty()&amp;&amp;mp[sta1.top().op]&gt;=mp[str[i]])</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">temp.op=str[i];</span><br><span class="line">sta1.push(temp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">que1.push(sta1.top());</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node cur,temp;</span><br><span class="line"><span class="keyword">while</span>(!que1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=que1.front();</span><br><span class="line">que1.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.flag==<span class="literal">true</span>)</span><br><span class="line">sta1.push(cur);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp2=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line">temp1=sta1.top().num;</span><br><span class="line">sta1.pop();</span><br><span class="line"></span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cur.op==<span class="string">'+'</span>)temp.num=temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'-'</span>)temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cur.op==<span class="string">'*'</span>)temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp.num=temp1/temp2;</span><br><span class="line">sta1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sta1.top().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp[<span class="string">'+'</span>]=mp[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">mp[<span class="string">'*'</span>]=mp[<span class="string">'/'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str),str!=<span class="string">"0"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>)</span><br><span class="line">str.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!sta1.empty())</span><br><span class="line">&#123;</span><br><span class="line">sta1.pop();</span><br><span class="line">&#125;</span><br><span class="line">deal();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,cal());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 第7章 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-6</title>
      <link href="/2019/01/26/PAT-6/"/>
      <url>/2019/01/26/PAT-6/</url>
      
        <content type="html"><![CDATA[<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>队列中的元素访问只能通过front()访问队首元素，back()访问队尾元素。队列是一种先进先出的容器。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>(1)push(x)把x加入队列</p><p>(2)front(),back()访问队首元素和队尾元素</p><p>(3)pop()让队首元素出队</p><p>(4)empty()判断queue是否为空，为空返回true，不为空返回false</p><p>(5)size()返回队列里面元素个数</p><h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><p>（1）BFS的时候会用到</p><p>（2）注意在front（）和pop（）使用之前，必须用empty（）判断队列是否为空。</p><h1 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h1><p>优先队列底层是用堆实现的。在优先队列中，队首元素一定是当前队列中优先级最高的元素（注意！并不是说整个队列是有序的！）</p><h2 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h2><p>优先队列和队列的不同在于优先队列没有front()和back(),只能通过top()函数来访问队首元素（也叫做堆顶元素），即优先级最高的元素。</p><h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><p>(1)push(x)将x入队，时间复杂度为O(logN)</p><p>(2)top()获取堆顶元素</p><p>(3)pop()堆顶元素出队，时间复杂度为O(logN)</p><p>(4)empty()判断队列是否为空。</p><p>(5)size()返回队内元素总数。时间复杂度为O(1)。</p><h2 id="结构体优先级的设置"><a href="#结构体优先级的设置" class="headerlink" title="结构体优先级的设置"></a>结构体优先级的设置</h2><h3 id="最大堆和最小堆的设置"><a href="#最大堆和最小堆的设置" class="headerlink" title="最大堆和最小堆的设置"></a>最大堆和最小堆的设置</h3><p>less<int>表示数字大的优先级大，greater<int>表示数字小的优先级大</int></int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;maxn_q;<span class="comment">//最大堆,等价于priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;minn_q1;<span class="comment">//最小堆</span></span><br></pre></td></tr></table></figure><h3 id="优先级的设置需要重载运算符"><a href="#优先级的设置需要重载运算符" class="headerlink" title="优先级的设置需要重载运算符"></a>优先级的设置需要重载运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price&lt;f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="另一种写法"><a href="#另一种写法" class="headerlink" title="另一种写法"></a>另一种写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price&lt;f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue&lt;fruit,<span class="built_in">vector</span>&lt;fruit&gt;,cmp &gt;q;</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>一种后进先出的容器，只能通过top（）访问。</p><h2 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h2><p>(1)push(x)将x入栈，时间复杂度为O(1)</p><p>(2)top()获取栈顶元素，时间复杂度为O(1)</p><p>(3)pop()栈顶元素出队，时间复杂度为O(1)</p><p>(4)empty()判断队列是否为空，时间复杂度为O(1)</p><p>(5)size()返回队内元素总数。时间复杂度为O(1)。</p><h2 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a>常见用途</h2><p>模拟递归</p><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>可以将两个元素绑定在一起作为合成元素。可以看成是内部有两个元素的结构体。</p><p>使用pair的时候，应该先添加头文件#include<utility> ,写#include<map>可以包括它。</map></utility></p><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p(<span class="string">"hhhh"</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p=make_pair(<span class="string">"aaaa"</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较方式"><a href="#比较方式" class="headerlink" title="比较方式"></a>比较方式</h2><p>可以直接用==，！=，&lt;,&gt;等符号比较大小。比较规则是先以first的大小作为标准，只有first相等了才去比较second。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>（1）代替二元struct</p><p>（2）作为map的键值对插入</p><h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="reverse-it1-it2"><a href="#reverse-it1-it2" class="headerlink" title="reverse(it1,it2)"></a>reverse(it1,it2)</h2><p>将数组指针或者容器迭代器在[it1,it2)范围内的元素进行反转</p><h2 id="next-permutation-a-a-len"><a href="#next-permutation-a-a-len" class="headerlink" title="next_permutation(a,a+len)"></a>next_permutation(a,a+len)</h2><p>给出一个序列在全排列中的下一个序列</p><h2 id="fill-a-a-len-value"><a href="#fill-a-a-len-value" class="headerlink" title="fill(a,a+len,value)"></a>fill(a,a+len,value)</h2><p>填充数据。</p><h2 id="sort-首元素地址，尾元素地址的下一个地址，比较函数（非必填）"><a href="#sort-首元素地址，尾元素地址的下一个地址，比较函数（非必填）" class="headerlink" title="sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填）)"></a>sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填）)</h2><h2 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h2><p>lower_bound(first,last,val)用来查找在数组或者容器[first,last)范围内<strong>第一个值小于等于</strong>val的元素的位置，返回的是这个位置的<strong>指针</strong>。如果是容器，则返回这个位置的<strong>迭代器</strong>。</p><p>upper_bound(first,last,val)用来查找在数组或者容器[first,last)范围内<strong>第一个值大于</strong>val的元素的位置，返回的是这个位置的<strong>指针</strong>，如果是容器，则返回这个位置的<strong>迭代器</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-5</title>
      <link href="/2019/01/25/PAT-5/"/>
      <url>/2019/01/25/PAT-5/</url>
      
        <content type="html"><![CDATA[<h1 id="STL（一）"><a href="#STL（一）" class="headerlink" title="STL（一）"></a>STL（一）</h1><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ul><li><p>（1）用于存储数据</p></li><li><p>（2）用邻接表存储图</p></li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="push-back-x"><a href="#push-back-x" class="headerlink" title="push_back(x)"></a>push_back(x)</h3><p>在vector后面添加一个元素</p><h3 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back()"></a>pop_back()</h3><p>在vector后面删除一个元素</p><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>计算vector的长度</p><h3 id="clear（）"><a href="#clear（）" class="headerlink" title="clear（）"></a>clear（）</h3><p>清除vector</p><h3 id="insert（it，x）"><a href="#insert（it，x）" class="headerlink" title="insert（it，x）"></a>insert（it，x）</h3><p>it是迭代器，在it位置插入一个元素x</p><h3 id="erase有两种用法"><a href="#erase有两种用法" class="headerlink" title="erase有两种用法"></a>erase有两种用法</h3><ul><li>erase(it) 删除迭代器it处的元素</li><li>erase(first,last) 删除[first,last)之间的元素，注意左闭右开</li></ul><h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><ul><li><p>set是一个内部自动有序且不含重复元素的容器。</p></li><li><p>set只能够通过迭代器访问内部元素。但不能通过*（it+i）的方式访问。</p><h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><p>insert(x)</p></li><li><p>find(value)：返回的是迭代器</p></li><li><p>erase():</p><p>两种用法:(1)删除单个元素：set.erase(it) —-删除迭代器位置的元素    set.erase(value)—–删除值为value的元素 (2)删除区间元素：set.erase(first,last),first和last都是迭代器。注意还是左闭右开原则[first,last)</p></li><li><p>size()获取set的长度</p></li><li><p>clear清空set</p></li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li>insert(pos,string) ，在pos处插入string</li><li>insert(it,it2,it3)，it是被插入字符串1的迭代器位置，it2和it3是即将插入字符串2的迭代器位置。把字符串2的[it2,it3)插入字符串1it处</li><li>erase(it)，删除单个元素</li><li>erase(pos,length),pos为需要删除的起始位置，length为删除的字符个数</li><li>substr(pos,len)，用于截取字符串,从pos位置开始，截取长度为len的字符串</li><li>find() str.find(str2)，当str2是str的字串的时候，返回其在str中第一次出现的位置。时间复杂度为O（nm)</li><li><p>replace(pos,len,str2) </p><p>把str1中的字符串从pos开始，到pos+len变成str2.即使len&lt;str2.length(),也可以成功添加，相当于是把pos到pos+len的字符串清空，str2从pos开始填充。</p></li><li><p>replace(it1,it2,str2) 类似。相当于把str1在it1和it2之间清空，变成str2.</p></li></ul><h3 id="A1060"><a href="#A1060" class="headerlink" title="A1060"></a>A1060</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">// s的下标 </span></span><br><span class="line"><span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'0'</span>)<span class="comment">//去掉前导零 </span></span><br><span class="line">s.erase(s.begin());       </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'.'</span>)     <span class="comment">//说明s是小于1的小数 </span></span><br><span class="line">&#123;</span><br><span class="line">s.erase(s.begin());</span><br><span class="line"><span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.erase(s.begin());</span><br><span class="line">e--;<span class="comment">//e为指数 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(k&lt;s.length()&amp;&amp;s[k]!=<span class="string">'.'</span>)</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">e++;   <span class="comment">//只要不碰到小数点就让指数e++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k&lt;s.length())</span><br><span class="line">&#123;</span><br><span class="line">s.erase(s.begin()+k);<span class="comment">//删除小数点 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(s.length()==<span class="number">0</span>)   <span class="comment">//去除前导0之后长度变为0，说明这个数是0 </span></span><br><span class="line">&#123;</span><br><span class="line">e=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="keyword">while</span>(num&lt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;s.length())res+=s[k++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res+=<span class="string">'0'</span>;    <span class="comment">//补0</span></span><br><span class="line">num++;<span class="comment">// 精度+1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">int</span> e1=<span class="number">0</span>,e2=<span class="number">0</span>;</span><br><span class="line">s3=deal(s1,e1);</span><br><span class="line">s4=deal(s2,e2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s3==s4&amp;&amp;e1==e2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES 0."</span>&lt;&lt;s3&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"0."</span>&lt;&lt;s3&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e1&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"0."</span>&lt;&lt;s4&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器），map中的键是唯一的！map中是使用红黑树实现的，key会像set那样从小到大排序。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>map&lt;key,value&gt;</p><h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><p>(1)通过类似于下标的方式访问，例如定义了map&lt;char,int&gt;,可以使用mp[‘c’]的方式访问。</p><p>(2)通过迭代器的方式访问。</p><p>定义map&lt;typename1,typename2&gt;::iterator it;</p><p><strong>使用it-&gt;first来访问key，it-&gt;second访问value. </strong></p><h2 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h2><p>（1）find（key）返回键为key的迭代器，时间复杂度为O(logN)</p><p>（2） 删除单个元素erase(it)或者erase(key)</p><p>​      删除多个元素 erase(first,last) ,[first,last) first和last都是<strong>迭代器</strong></p><p>（3）size（）返回映射的对数</p><p>（4） clear（）清除map</p><h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><ul><li>需要建立字符或者字符串到整数之间的映射题目</li><li>判断大整数或者其他类型数据是否存在，可以把map当成bool数组用</li><li>字符串和字符串之间的映射</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-4</title>
      <link href="/2019/01/24/PAT-4/"/>
      <url>/2019/01/24/PAT-4/</url>
      
        <content type="html"><![CDATA[<h1 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h1><p>求N的质因数。根据下列公式：</p><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\zhishu.png" alt=""></p><p>也是必须用素数打表，然后计算。p表示质因数，a表示指数。</p><p>例如：</p><p>​            180=2^2 <em> 3^2 </em> 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;; <span class="comment">//  false表示是质数</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> pnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">factor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;      <span class="comment">//质因子</span></span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">//  质因子个数</span></span><br><span class="line">&#125;;</span><br><span class="line">factor fac[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[pnum++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    find_prime();</span><br><span class="line">    <span class="comment">/*for(int i=0;i&lt;100;i++)</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;p[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;*/</span></span><br><span class="line">    <span class="keyword">int</span> n,num=<span class="number">0</span>;  <span class="comment">//num为n的不同的质因子的个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1=1"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d="</span>,n);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n*<span class="number">1.0</span>);  <span class="comment">//根号n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pnum&amp;&amp;prime[i]&lt;=sqr;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fac[num].x=prime[i];</span><br><span class="line">                fac[num].cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fac[num].cnt++;</span><br><span class="line">                    n/=prime[i];               </span><br><span class="line">                &#125;              </span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)    <span class="comment">//说明无法被根号n以内的质因子除尽</span></span><br><span class="line">    &#123;</span><br><span class="line">        fac[num].x=n;</span><br><span class="line">        fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照格式输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,fac[i].x);</span><br><span class="line">        <span class="keyword">if</span>(fac[i].cnt&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"^%d"</span>,fac[i].cnt);  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>约数是在素数的基础上解决的问题。</p><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\zhishu.png" alt=""></p><p>N为输入的数，d(N)表示N的约数的个数。</p><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\yuanshu-gongshi.png" alt=""></p><p>一般先通过线性筛把素数表打出来，再根据得到的质因数指数再使用一次线性筛计算出约数的个数。</p><p><a href="https://blog.csdn.net/ControlBear/article/details/77527115" target="_blank" rel="noopener">https://blog.csdn.net/ControlBear/article/details/77527115</a></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>这里我没有用约数个数筛，只是用了素数筛。嘻嘻，因为我不会。</p><p>原来cout真的比printf慢好多。。。用cout超时，用printf过了。</p><p><a href="http://codeup.cn/problem.php?cid=100000592&amp;pid=3" target="_blank" rel="noopener">http://codeup.cn/problem.php?cid=100000592&amp;pid=3</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;; <span class="comment">//  false表示是质数</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> pnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">factor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;      <span class="comment">//质因子</span></span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">//  质因子个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[pnum++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">find_prime();</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> temp=<span class="number">0</span>;temp&lt;N;temp++)  <span class="comment">//输入 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[temp]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n=A[i];</span><br><span class="line">factor fac[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pnum&amp;&amp;prime[i]&lt;=sqr;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fac[num].x=prime[i];</span><br><span class="line">fac[num].cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fac[num].cnt++;</span><br><span class="line">n/=prime[i];</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fac[num].x=n;</span><br><span class="line">fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;num;t++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sum*=(fac[t].cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);<span class="comment">//sum&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h1><p><img src="/2019/01/24/PAT-4/J:/hexo\source\_posts\PAT-4\yuanshu-sum.png" alt=""></p><h1 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h1><p>一般来说，要这样定义大整数结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bign</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">bign()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">len=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>高精度加法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span>  <span class="comment">//高精度加法 ,只能处理两个正数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bign c;</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;  <span class="comment">//控制进位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">carry=temp/<span class="number">10</span>; <span class="comment">//是否进位 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(carry!=<span class="number">0</span>)<span class="comment">//最后是否进位 </span></span><br><span class="line">&#123;</span><br><span class="line">c.d[c.len++]=carry;</span><br><span class="line">&#125;</span><br><span class="line">reverse(c.d,c.d+c.len);<span class="comment">//逆序 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h1><p>高精度减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span>  <span class="comment">//高精度减法！！注意！计算之前要用，compare函数比较大小. </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bign c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a.d[i]&lt;b.d[i])</span><br><span class="line">&#123;</span><br><span class="line">a.d[i+<span class="number">1</span>]--;</span><br><span class="line">a.d[i]+=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">c.d[c.len++]=a.d[i]-b.d[i];  <span class="comment">//减法结果为当前位结果 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)  <span class="comment">//去掉高位0 </span></span><br><span class="line">c.len--;</span><br><span class="line"></span><br><span class="line">reverse(c.d,c.d+c.len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h1><p>高精度和低精度混合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span>   <span class="comment">//低精度与高精度乘法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bign c;</span><br><span class="line"><span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a.d[i]*b+carry;  </span><br><span class="line">c.d[c.len++]=temp%<span class="number">10</span>;     <span class="comment">//取temp的个位作为当前位</span></span><br><span class="line">carry=temp/<span class="number">10</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(carry!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c.d[c.len++]=carry%<span class="number">10</span>;<span class="comment">//取最右边一位</span></span><br><span class="line">carry/=<span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse(c.d,c.d+c.len);<span class="comment">//需要把C的d数组逆转</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>高精度和低精度混合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)</span>  <span class="comment">// r为余数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">bign c;</span><br><span class="line">c.len=a.len;   <span class="comment">//商的位数和被除数位数一一对应</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line"><span class="keyword">if</span>(r&lt;b)<span class="comment">//不够除的情况 </span></span><br><span class="line">c.d[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">c.d[i]=r/b;</span><br><span class="line">r=r%b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;c.len<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">c.len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合数的计算"><a href="#组合数的计算" class="headerlink" title="组合数的计算"></a>组合数的计算</h1><p><strong>核心</strong>：</p><ul><li><p><strong>C（i,j）=C(i-1,j)+C(i-1,j-1)</strong></p></li><li><p><strong>采用变形式</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 n!的质因子p的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">ans+=n/p;</span><br><span class="line">n/=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">ll res[<span class="number">67</span>][<span class="number">67</span>];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> <span class="comment">//用递推公式计算的 ，递归算法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>||m==n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>)<span class="keyword">return</span> res[n][m]; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res[n][m]=C(n<span class="number">-1</span>,m)+C(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整张表一起计算出来</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n1=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calC</span><span class="params">()</span>   <span class="comment">//非递归 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n1;i++)</span><br><span class="line">&#123;</span><br><span class="line">res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;  <span class="comment">//初始化边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">res[i][j]=res[i<span class="number">-1</span>][j]+res[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">res[i][i-j]=res[i][j];<span class="comment">//对称 ,C(i,j)=C(i,i-j)</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*---变形式--*/</span></span><br><span class="line"><span class="function">ll <span class="title">C1</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ans=ans*(n-m+i)/i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">calC();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;C1(n,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-3</title>
      <link href="/2019/01/23/PAT-3/"/>
      <url>/2019/01/23/PAT-3/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp)right--;</span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=Partition(A,left,right);</span><br><span class="line">quickSort(A,left,pos);<span class="comment">//对左边区间递归 </span></span><br><span class="line">quickSort(A,pos+<span class="number">1</span>,right);<span class="comment">//对右边区间递归 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=(round(<span class="number">1.0</span>*rand()/RAND_MAX*(right-left))+left);  <span class="comment">//算出一个随机的位置index  P</span></span><br><span class="line">swap(A[p],A[left]);   <span class="comment">//把p的位置和left交换</span></span><br><span class="line"><span class="comment">//  以下和 Partition一样 </span></span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&lt;temp)right--;   <span class="comment">//注意，是按照从大到小排序还是从小到大排序 </span></span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&gt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选取第K大的数"><a href="#选取第K大的数" class="headerlink" title="选取第K大的数"></a>选取第K大的数</h1><p>这里利用了快排划分的思想。注意是按照从大到小排序还是从小到大排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp)right--;</span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=(round(<span class="number">1.0</span>*rand()/RAND_MAX*(right-left))+left);  <span class="comment">//算出一个随机的位置index  P</span></span><br><span class="line">swap(A[p],A[left]);   <span class="comment">//把p的位置和left交换</span></span><br><span class="line"><span class="comment">//  以下和 Partition一样 </span></span><br><span class="line"><span class="keyword">int</span> temp=A[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&lt;temp)right--;   <span class="comment">//注意，是按照从大到小排序还是从小到大排序 </span></span><br><span class="line">A[left]=A[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&gt;=temp)left++;</span><br><span class="line">A[right]=A[left];</span><br><span class="line">&#125;</span><br><span class="line">A[left]=temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=Partition(A,left,right);</span><br><span class="line">quickSort(A,left,pos<span class="number">-1</span>);<span class="comment">//对左边区间递归 </span></span><br><span class="line">quickSort(A,pos+<span class="number">1</span>,right);<span class="comment">//对右边区间递归 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> K)</span>  <span class="comment">//返回第K大的数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)</span><br><span class="line"><span class="keyword">return</span> A[left];  <span class="comment">//边界？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P=randPartition(A,left,right);</span><br><span class="line"><span class="keyword">int</span> M=P-left+<span class="number">1</span>;  <span class="comment">//返回的P是第M大的元素</span></span><br><span class="line"><span class="keyword">if</span>(K==M)</span><br><span class="line"><span class="keyword">return</span> A[P];</span><br><span class="line"><span class="keyword">if</span>(K&lt;M)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> randSelect(A,left,P<span class="number">-1</span>,K);   <span class="comment">//往左边收缩，找到第K大的元素</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> randSelect(A,P+<span class="number">1</span>,right,K-M);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum1=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;randSelect(A,<span class="number">0</span>,m<span class="number">-1</span>,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/gcd(a,b) *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;gcd(<span class="number">33</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>素数的题目一般采用打表的方式去做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> Prime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;;  <span class="comment">//是素数就是false,默认为false </span></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">()</span>  <span class="comment">//埃式筛法(时间复杂度是O(nloglogn) 空间复杂度是O(n)) </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"ii";</span></span><br><span class="line">Prime[num++]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)</span><br><span class="line">&#123;</span><br><span class="line">p[j]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Find_Prime();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Prime[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-2</title>
      <link href="/2019/01/22/PAT-2/"/>
      <url>/2019/01/22/PAT-2/</url>
      
        <content type="html"><![CDATA[<h1 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>对于贪心的理解，大概就是每一步都选取最优的解，对问题进行排序是很重要的部分！</p><h3 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h3><p>  给出N个开区间(x,y)，选择尽可能多的区间，使得这些开区间两两之间没有交集。输出这些区间的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qujian</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Qujian a,Qujian b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x!=b.x)</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;   <span class="comment">//如果左端点不同，按照区间的左端点从大到小排序 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;<span class="comment">//  左端点相同，按照区间的右端点从小到大排序 </span></span><br><span class="line">&#125;</span><br><span class="line">Qujian A[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;A[i].x,&amp;A[i].y);</span><br><span class="line">&#125;</span><br><span class="line">sort(A,A+N,cmp);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>; <span class="keyword">int</span> lastX=A[<span class="number">0</span>].x;    <span class="comment">//选取排序后第一个区间，并且记录下该区间的左端点</span></span><br><span class="line"><span class="comment">//lastX是记录上一个选取区间的左端点 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i].y&lt;=lastX)        <span class="comment">//如果某一区间的右端点小于等于上一个选取区间的左端点，说明其不相交 </span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">lastX=A[i].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;oo</span><br></pre></td></tr></table></figure><h3 id="题目2："><a href="#题目2：" class="headerlink" title="题目2："></a>题目2：</h3><p>给出N个闭区间[x,y],求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点。思路和上一题一样，先是需要对区间根据从左端点的大小进行排序，然后选择满足条件的左端点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qujian</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Qujian a,Qujian b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x!=b.x)</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;   <span class="comment">//如果左端点不同，按照区间的左端点从大到小排序 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;<span class="comment">//  左端点相同，按照区间的右端点从小到大排序 </span></span><br><span class="line">&#125;</span><br><span class="line">Qujian A[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;A[i].x,&amp;A[i].y);</span><br><span class="line">&#125;</span><br><span class="line">sort(A,A+N,cmp);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>; <span class="keyword">int</span> lastX=A[<span class="number">0</span>].x;    <span class="comment">//选取排序后第一个区间，并且记录下该区间的左端点</span></span><br><span class="line"><span class="comment">//lastX是记录上一个选取区间的左端点 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i].y&lt;lastX)        <span class="comment">//如果某一区间的右端点小于上一个选取区间的左端点，选取这个区间的左端点 </span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">lastX=A[i].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p>模板见另一篇博文。</p><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>快速幂本质上还是二分的思想。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>计算a的b次方%m。</p><p>if b=0，a的b次方=1</p><p>else if b为奇数，a的b次方=a的b-1次方 *a</p><p>else if b为偶数，a的b次方=a的b/2次方 * a的b/2次方 </p><h3 id="递归的写法"><a href="#递归的写法" class="headerlink" title="递归的写法"></a>递归的写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法 </span></span><br><span class="line"><span class="function">ll <span class="title">binaryPow</span><span class="params">(ll a,ll b,ll m)</span><span class="comment">//计算a的b次方%m </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> a*binaryPow(a,b<span class="number">-1</span>,m)%m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll mul=binaryPow(a,b/<span class="number">2</span>,m);</span><br><span class="line"><span class="keyword">return</span> mul*mul%m; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><p>b可以拆分成多个2的倍数的偶数和一个奇数相加。</p><p>例如b=13</p><p>13=8+4+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">binaryPow1</span><span class="params">(ll a,ll b,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//如果b的二进制最后一位是1</span></span><br><span class="line">&#123;</span><br><span class="line">ans=ans*a%m;</span><br><span class="line">    &#125; </span><br><span class="line">    a=a*a%m;<span class="comment">//令a平方，从而计算出 a的2,4,8次方 </span></span><br><span class="line">    b&gt;&gt;=<span class="number">1</span>;   <span class="comment">//b右移一位，相当于b=b/2 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Two-pointer"><a href="#Two-pointer" class="headerlink" title="Two pointer"></a>Two pointer</h1><p>可以解决序列合并问题。</p><h2 id="2-路归并排序"><a href="#2-路归并排序" class="headerlink" title="2-路归并排序"></a>2-路归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=L1;</span><br><span class="line"><span class="keyword">int</span> j=L2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=R1&amp;&amp;j&lt;=R2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;=A[j])</span><br><span class="line">temp[index++]=A[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[index++]=A[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=R1)temp[index++]=A[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=R2)temp[index++]=A[j++];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">&#123;</span><br><span class="line">A[L1+i]=temp[i];  <span class="comment">//写回去A</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  <span class="comment">//递归实现 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">mergesort(A,left,mid);</span><br><span class="line">mergesort(A,mid+<span class="number">1</span>,right);</span><br><span class="line">merge(A,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort1</span><span class="params">(<span class="keyword">int</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step/<span class="number">2</span>&lt;=n;step+=<span class="number">2</span>)   <span class="comment">//子区间的元素总数为step </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//step个元素作为一组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=step)     <span class="comment">//对于每一组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=i+step/<span class="number">2</span><span class="number">-1</span>  ;<span class="comment">//左子区间的元素个数为step/2 </span></span><br><span class="line"><span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//左子区间[i,mid] ,右子区间 [mid+1,min(i+step-1,n)]</span></span><br><span class="line">merge(A,i,mid,mid+<span class="number">1</span>,min(i+step<span class="number">-1</span>,n));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT-1</title>
      <link href="/2019/01/21/PAT-1/"/>
      <url>/2019/01/21/PAT-1/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体的排序方法（sort的使用）"><a href="#结构体的排序方法（sort的使用）" class="headerlink" title="结构体的排序方法（sort的使用）"></a>结构体的排序方法（sort的使用）</h1><h2 id="A1025"><a href="#A1025" class="headerlink" title="A1025"></a>A1025</h2><h3 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h3><p>结构体的排序方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> student &amp;a,<span class="keyword">const</span> student &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score==b.score)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id)&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> id[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="keyword">int</span> location_number;</span><br><span class="line"><span class="keyword">int</span> local_rank;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> student &amp;a,<span class="keyword">const</span> student &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score==b.score)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id)&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line">student stu[<span class="number">30010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);<span class="comment">//n为考场数目</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);<span class="comment">//每个考场人数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,stu[num].id,&amp;stu[num].score);</span><br><span class="line">stu[num].location_number=i;</span><br><span class="line">num++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sort(stu+num-k,stu+num,cmp);</span><br><span class="line">stu[num-k].local_rank=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//int temp=1;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=num-k+<span class="number">1</span>;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(stu[j].score==stu[j<span class="number">-1</span>].score)</span><br><span class="line">stu[j].local_rank=stu[j<span class="number">-1</span>].local_rank;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">stu[j].local_rank=j-(num-k)+<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line"></span><br><span class="line">sort(stu,stu+num,cmp);</span><br><span class="line"><span class="keyword">int</span> temp1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;stu[i].score!=stu[i<span class="number">-1</span>].score)</span><br><span class="line">temp1=i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %d %d %d\n"</span>,stu[i].id,temp1,stu[i].location_number+<span class="number">1</span>,stu[i].local_rank);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash的使用"><a href="#hash的使用" class="headerlink" title="hash的使用"></a>hash的使用</h1><h2 id="将字符串转换成整数"><a href="#将字符串转换成整数" class="headerlink" title="将字符串转换成整数"></a>将字符串转换成整数</h2><p>主要用到的函数：</p><h4 id="注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1-X表示字符串所出现的最大字符种类个数。"><a href="#注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1-X表示字符串所出现的最大字符种类个数。" class="headerlink" title="注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1.X表示字符串所出现的最大字符种类个数。"></a>注意设置hashTable的长度时候，字符串映射成整数的最大为X的length次方-1.X表示字符串所出现的最大字符种类个数。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span>    <span class="comment">//可以将只包含了a-z,A-Z的字符串映射到一个整数表示 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span>&amp;&amp;S[i]&lt;=<span class="string">'Z'</span>) </span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc1</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">id=id*<span class="number">26</span>+(s[i]-<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目-给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。"><a href="#题目-给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。" class="headerlink" title="题目:给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。"></a>题目:给定N个字符串，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn][<span class="number">5</span>],temp[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span>    <span class="comment">//可以将只包含了a-z,A-Z的字符串映射到一个整数表示 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span>&amp;&amp;S[i]&lt;=<span class="string">'Z'</span>) </span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span>&amp;&amp;S[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">id=id*<span class="number">52</span>+(S[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc1</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">id=id*<span class="number">26</span>+(s[i]-<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S[i]);</span><br><span class="line"><span class="keyword">int</span> id=hashFunc1(S[i],<span class="number">3</span>);  <span class="comment">//string to int</span></span><br><span class="line">hashTable[id]++;       <span class="comment">//count++</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line"><span class="keyword">int</span> id=hashFunc1(temp,<span class="number">3</span>);    <span class="comment">//将测试字符串转换成int  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hashTable[id]);<span class="comment">//输出该字符串的出现次数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>全排列主要还是利用了递归的思路，之前在leetcode做了挺多，重新看算法笔记，发现自己又忘记了。。。</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>输入一个n，输出1-n的数字全排列。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)   <span class="comment">//递归的边界,表示已经处理了1-n位 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,P[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)<span class="comment">//循环测试 i放入P[index] 是否合适 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)     <span class="comment">//看X是否已经使用了 </span></span><br><span class="line">&#123;</span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;<span class="comment">//设置x已经使用了的状态 </span></span><br><span class="line"></span><br><span class="line">generateP(index+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">hashTable[x]=<span class="literal">false</span>; <span class="comment">//还原状态 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">generateP(<span class="number">1</span>);  <span class="comment">//从第一位开始填充！ </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得思考的是，如果要求输出的是字符a-z的全排列，也是需要hashTable的思想，从第一位开始填充，使用hashTable判断某一个字符是否使用过。</p><h4 id="关键"><a href="#关键" class="headerlink" title="关键:"></a>关键:</h4><p>1.就是要记得递归的时候的递归边界</p><p>2.设置状态之后，记得还原状态。</p><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p>本质上也是一个全排列问题。详情见下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">11</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> P[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span>  <span class="comment">//暴力法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(P[i]-P[j]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)count1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generateP(index+<span class="number">1</span>);</span><br><span class="line">hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP1</span><span class="params">(<span class="keyword">int</span> index)</span>   <span class="comment">//表示的是第index列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(P[pre]-x))</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generateP1(index+<span class="number">1</span>);</span><br><span class="line">hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">generateP1(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中generateP（）表示的是暴力法，没有剪枝操作。</p><p>其中generateP1（）表示的是回溯法，有剪枝操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PAT甲级 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>little dp</title>
      <link href="/2018/12/18/little-dp/"/>
      <url>/2018/12/18/little-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划入门"><a href="#动态规划入门" class="headerlink" title="动态规划入门"></a>动态规划入门</h1><p>一直感觉动态规划好难，最近看了一下leetcode的两道题，慢慢有了一点感觉。</p><a id="more"></a><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="[53] Maximum Subarray"></a>[53] Maximum Subarray</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=53 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [53] Maximum Subarray</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/maximum-subarray/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (41.99%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    417.5K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 994.1K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[-2,1,-3,4,-1,2,1,-5,4]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given an integer array nums, find the contiguous subarray (containing at</span></span><br><span class="line"><span class="comment"> * least one number) which has the largest sum and return its sum.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [-2,1,-3,4,-1,2,1,-5,4],</span></span><br><span class="line"><span class="comment"> * Output: 6</span></span><br><span class="line"><span class="comment"> * Explanation: [4,-1,2,1] has the largest sum = 6.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Follow up:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If you have figured out the O(n) solution, try coding another solution using</span></span><br><span class="line"><span class="comment"> * the divide and conquer approach, which is more subtle.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                    dp[i]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(ans&lt;dp[i])</span><br><span class="line">                ans=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="[70] Climbing Stairs"></a>[70] Climbing Stairs</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=70 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [70] Climbing Stairs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/climbing-stairs/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (42.57%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    322.2K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 757K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '2'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You are climbing a stair case. It takes n steps to reach to the top.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Each time you can either climb 1 or 2 steps. In how many distinct ways can</span></span><br><span class="line"><span class="comment"> * you climb to the top?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note: Given n will be a positive integer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: 2</span></span><br><span class="line"><span class="comment"> * Output: 2</span></span><br><span class="line"><span class="comment"> * Explanation: There are two ways to climb to the top.</span></span><br><span class="line"><span class="comment"> * 1. 1 step + 1 step</span></span><br><span class="line"><span class="comment"> * 2. 2 steps</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: 3</span></span><br><span class="line"><span class="comment"> * Output: 3</span></span><br><span class="line"><span class="comment"> * Explanation: There are three ways to climb to the top.</span></span><br><span class="line"><span class="comment"> * 1. 1 step + 1 step + 1 step</span></span><br><span class="line"><span class="comment"> * 2. 1 step + 2 steps</span></span><br><span class="line"><span class="comment"> * 3. 2 steps + 1 step</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">     </span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>旋转矩阵</title>
      <link href="/2018/12/14/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2018/12/14/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><h2 id="Leetcode-48"><a href="#Leetcode-48" class="headerlink" title="Leetcode-48"></a>Leetcode-48</h2><p>下面给出两种解法：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=48 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [48] Rotate Image</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/rotate-image/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (45.23%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    204.8K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 452.8K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You are given an n x n 2D matrix representing an image.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Rotate the image by 90 degrees (clockwise).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You have to rotate the image in-place, which means you have to modify the</span></span><br><span class="line"><span class="comment"> * input 2D matrix directly. DO NOT allocate another 2D matrix and do the</span></span><br><span class="line"><span class="comment"> * rotation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given input matrix = </span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1,2,3],</span></span><br><span class="line"><span class="comment"> * ⁠ [4,5,6],</span></span><br><span class="line"><span class="comment"> * ⁠ [7,8,9]</span></span><br><span class="line"><span class="comment"> * ],</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rotate the input matrix in-place such that it becomes:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [7,4,1],</span></span><br><span class="line"><span class="comment"> * ⁠ [8,5,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [9,6,3]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given input matrix =</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [ 5, 1, 9,11],</span></span><br><span class="line"><span class="comment"> * ⁠ [ 2, 4, 8,10],</span></span><br><span class="line"><span class="comment"> * ⁠ [13, 3, 6, 7],</span></span><br><span class="line"><span class="comment"> * ⁠ [15,14,12,16]</span></span><br><span class="line"><span class="comment"> * ], </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rotate the input matrix in-place such that it becomes:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [15,13, 2, 5],</span></span><br><span class="line"><span class="comment"> * ⁠ [14, 3, 4, 1],</span></span><br><span class="line"><span class="comment"> * ⁠ [12, 6, 8, 9],</span></span><br><span class="line"><span class="comment"> * ⁠ [16, 7,10,11]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">       <span class="comment">/* for(int i=0;i&lt;n/2;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j=i;j&lt;n-1-i;j++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                int temp=matrix[j][n-i-1];</span></span><br><span class="line"><span class="comment">                matrix[j][n-i-1]=matrix[i][j];</span></span><br><span class="line"><span class="comment">                matrix[i][j]=matrix[n-j-1][i];</span></span><br><span class="line"><span class="comment">                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];</span></span><br><span class="line"><span class="comment">                matrix[n-i-1][n-j-1] = temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//对角线对折</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//对中线对折</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(matrix[i][j],matrix[i][n<span class="number">-1</span>-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全排列</title>
      <link href="/2018/12/08/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/12/08/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>  全排列类型的题目一般使用回溯算法去解决，需要注意的是如何去递归，每次递归改变的条件。</p><a id="more"></a><h2 id="Leetcode-46"><a href="#Leetcode-46" class="headerlink" title="Leetcode 46"></a>Leetcode 46</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">√ Accepted</span><br><span class="line">√ <span class="number">25</span>/<span class="number">25</span> <span class="function">cases <span class="title">passed</span> <span class="params">(<span class="number">8</span> ms)</span></span></span><br><span class="line">√ Your runtime beats 40.39 % of cpp submissions</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=46 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [46] Permutations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/permutations/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (51.59%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    306.6K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 594.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,2,3]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a collection of distinct integers, return all possible permutations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,2,3]</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1,2,3],</span></span><br><span class="line"><span class="comment"> * ⁠ [1,3,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,1,3],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,3,1],</span></span><br><span class="line"><span class="comment"> * ⁠ [3,1,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [3,2,1]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n=nums[i];</span><br><span class="line">                now.push_back(nums[i]);</span><br><span class="line">                nums.erase(nums.begin()+i);<span class="comment">//删除这个元素</span></span><br><span class="line">                backtrace(nums,now,ans);</span><br><span class="line">                nums.insert(nums.begin()+i, n);<span class="comment">//把删除的元素加回来，不改变相对位置。</span></span><br><span class="line">                now.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now;</span><br><span class="line">        backtrace(nums,now,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-47"><a href="#Leetcode-47" class="headerlink" title="Leetcode 47"></a>Leetcode 47</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode id=47 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [47] Permutations II</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/permutations-ii/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (37.93%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    203.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 537.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,1,2]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a collection of numbers that might contain duplicates, return all</span></span><br><span class="line"><span class="comment"> * possible unique permutations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,1,2]</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1,1,2],</span></span><br><span class="line"><span class="comment"> * ⁠ [1,2,1],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,1,1]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)   <span class="comment">//表示每一次都选数组中的一个一个数当作第一个数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 和leetcode46 比起来 相对于重复的元素进行了处理！ */</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="comment">// 精华！！！ 和46题的对比！！！</span></span><br><span class="line">                    <span class="keyword">continue</span>;               <span class="comment">//精华！！！</span></span><br><span class="line">                <span class="keyword">int</span> n=nums[i];</span><br><span class="line">                now.push_back(nums[i]);</span><br><span class="line">                nums.erase(nums.begin()+i);<span class="comment">//删除这个元素</span></span><br><span class="line">                backtrace(nums,now,ans);</span><br><span class="line">                nums.insert(nums.begin()+i, n);<span class="comment">//把删除的元素加回来，不改变相对位置。</span></span><br><span class="line">                now.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">        backtrace(nums,now,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回溯算法</title>
      <link href="/2018/12/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-39"><a href="#Leetcode-39" class="headerlink" title="Leetcode 39"></a>Leetcode 39</h1><a id="more"></a><p>参考链接</p><p><a href="https://blog.csdn.net/zr1076311296/article/details/51374923" target="_blank" rel="noopener">https://blog.csdn.net/zr1076311296/article/details/51374923</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [39] Combination Sum</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/combination-sum/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (44.92%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    275.2K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 612.7K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[2,3,6,7]\n7'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a set of candidate numbers (candidates) (without duplicates) and a</span></span><br><span class="line"><span class="comment"> * target number (target), find all unique combinations in candidates where the</span></span><br><span class="line"><span class="comment"> * candidate numbers sums to target.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The same repeated number may be chosen from candidates unlimited number of</span></span><br><span class="line"><span class="comment"> * times.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * All numbers (including target) will be positive integers.</span></span><br><span class="line"><span class="comment"> * The solution set must not contain duplicate combinations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [2,3,6,7], target = 7,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [7],</span></span><br><span class="line"><span class="comment"> * ⁠ [2,2,3]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [2,3,5], target = 8,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * [2,2,2,2],</span></span><br><span class="line"><span class="comment"> * [2,3,3],</span></span><br><span class="line"><span class="comment"> * [3,5]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;tmp,<span class="keyword">int</span> target,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i]&gt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                backTrace(candidates,res,tmp,target-candidates[i],i);</span><br><span class="line">                tmp.pop_back();<span class="comment">//把元素弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ret;</span><br><span class="line">       ret.clear();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">       tmp.clear();</span><br><span class="line">       sort(candidates.begin(),candidates.end());</span><br><span class="line">       backTrace(candidates,ret,tmp,target,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-40"><a href="#Leetcode-40" class="headerlink" title="Leetcode 40"></a>Leetcode 40</h1><p>与39题类似，但是要注意去重复，还有从i+1进入下次递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [40] Combination Sum II</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/combination-sum-ii/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (38.78%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    184.7K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 476.1K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[10,1,2,7,6,1,5]\n8'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a collection of candidate numbers (candidates) and a target number</span></span><br><span class="line"><span class="comment"> * (target), find all unique combinations in candidates where the candidate</span></span><br><span class="line"><span class="comment"> * numbers sums to target.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Each number in candidates may only be used once in the combination.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * All numbers (including target) will be positive integers.</span></span><br><span class="line"><span class="comment"> * The solution set must not contain duplicate combinations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [10,1,2,7,6,1,5], target = 8,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ [1, 7],</span></span><br><span class="line"><span class="comment"> * ⁠ [1, 2, 5],</span></span><br><span class="line"><span class="comment"> * ⁠ [2, 6],</span></span><br><span class="line"><span class="comment"> * ⁠ [1, 1, 6]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: candidates = [2,5,2,1,2], target = 5,</span></span><br><span class="line"><span class="comment"> * A solution set is:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * [1,2,2],</span></span><br><span class="line"><span class="comment"> * [5]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i]&lt;=target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class="number">-1</span>])<span class="comment">//精华！</span></span><br><span class="line">                        <span class="keyword">continue</span>;                   </span><br><span class="line">                    now.push_back(candidates[i]);</span><br><span class="line">                    backtracing(now,candidates,target-candidates[i],ans,i+<span class="number">1</span>);<span class="comment">//精华！</span></span><br><span class="line">                    now.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ret;</span><br><span class="line">       ret.clear();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">       tmp.clear();</span><br><span class="line">       sort(candidates.begin(),candidates.end());</span><br><span class="line">       backtracing(tmp,candidates,target,ret,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分搜索的写法</title>
      <link href="/2018/11/28/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%86%99%E6%B3%95/"/>
      <url>/2018/11/28/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索的写法总结"><a href="#二分搜索的写法总结" class="headerlink" title="二分搜索的写法总结"></a>二分搜索的写法总结</h1><p>参考了</p><p><a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">https://www.zhihu.com/question/36132386</a></p><a id="more"></a><p>参考题目链接</p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找任意一个等于target的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]==target)<span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left==target)</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求下界 ，返回的是第一个等于target的数字 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_binary</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=mid; <span class="comment">//nums[mid]&lt;=target right一直往左边靠 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[left]==target)</span><br><span class="line"><span class="keyword">return</span> left; <span class="comment">//返回的是第一个等于target的数字 </span></span><br><span class="line"><span class="comment">//return left-1  //返回的是第一个小于target的数字 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求上界 ,返回的是第一个大于target的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">up_binary</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((right<span class="number">-1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[right<span class="number">-1</span>]==target)</span><br><span class="line"><span class="keyword">return</span> right;<span class="comment">//返回的是第一个大于target的位置</span></span><br><span class="line"><span class="comment">//return right-1; //返回的是最后一个等于target的位置</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;binary(a,<span class="number">1</span>,<span class="number">22</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-33"><a href="#Leetcode-33" class="headerlink" title="Leetcode-33"></a>Leetcode-33</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [33] Search in Rotated Sorted Array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/search-in-rotated-sorted-array/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (32.28%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    330.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 1M</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[4,5,6,7,0,1,2]\n0'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Suppose an array sorted in ascending order is rotated at some pivot unknown</span></span><br><span class="line"><span class="comment"> * to you beforehand.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You are given a target value to search. If found in the array return its</span></span><br><span class="line"><span class="comment"> * index, otherwise return -1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You may assume no duplicate exists in the array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your algorithm's runtime complexity must be in the order of O(log n).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [4,5,6,7,0,1,2], target = 0</span></span><br><span class="line"><span class="comment"> * Output: 4</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [4,5,6,7,0,1,2], target = 3</span></span><br><span class="line"><span class="comment"> * Output: -1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[right])<span class="comment">//搜索右边</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[right])<span class="comment">//搜索左边</span></span><br><span class="line">            &#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    right=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target||nums[right]==target)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-35"><a href="#Leetcode-35" class="headerlink" title="Leetcode-35"></a>Leetcode-35</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [35] Search Insert Position</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/search-insert-position/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (40.02%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    325.8K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 814K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,3,5,6]\n5'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a sorted array and a target value, return the index if the target is</span></span><br><span class="line"><span class="comment"> * found. If not, return the index where it would be if it were inserted in</span></span><br><span class="line"><span class="comment"> * order.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * You may assume no duplicates in the array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 5</span></span><br><span class="line"><span class="comment"> * Output: 2</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 2</span></span><br><span class="line"><span class="comment"> * Output: 1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 3:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 7</span></span><br><span class="line"><span class="comment"> * Output: 4</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 4:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,5,6], 0</span></span><br><span class="line"><span class="comment"> * Output: 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left==length<span class="number">-1</span>&amp;&amp;nums[length<span class="number">-1</span>]&lt;target)</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-34"><a href="#Leetcode-34" class="headerlink" title="Leetcode-34"></a>Leetcode-34</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [34] Find First and Last Position of Element in Sorted Array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (32.34%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    240.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 743.1K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[5,7,7,8,8,10]\n8'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given an array of integers nums sorted in ascending order, find the starting</span></span><br><span class="line"><span class="comment"> * and ending position of a given target value.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your algorithm's runtime complexity must be in the order of O(log n).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the target is not found in the array, return [-1, -1].</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="comment"> * Output: [3,4]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: nums = [5,7,7,8,8,10], target = 6</span></span><br><span class="line"><span class="comment"> * Output: [-1,-1]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.size()<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)<span class="comment">//求第一个等于target的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">           mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t1=left;</span><br><span class="line">        </span><br><span class="line">        right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((left<span class="number">-1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[left<span class="number">-1</span>]==target&amp;&amp;nums[left]!=target)</span><br><span class="line">            t2=left<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((left<span class="number">-1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[left]==target)</span><br><span class="line">            t2=left;</span><br><span class="line">        <span class="keyword">return</span> &#123;t1,t2&#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ResNet</title>
      <link href="/2018/11/27/ResNet/"/>
      <url>/2018/11/27/ResNet/</url>
      
        <content type="html"><![CDATA[<h1 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h1><p><strong>网络的深度为什么重要？</strong></p><p>  因为CNN能够提取low/mid/high-level的特征，网络的层数越多，意味着能够提取到不同level的特征越丰富。并且，越深的网络提取的特征越抽象，越具有语义信息。</p><p><strong>为什么不能简单地增加网络层数？</strong></p><p>对于原来的网络，如果简单地增加深度，会导致梯度弥散或梯度爆炸。</p><p><strong>对于该问题的解决方法是正则化初始化和中间的正则化层（Batch Normalization），这样的话可以训练几十层的网络。</strong></p><p>虽然通过上述方法能够训练了，但是又会出现另一个问题，就是<strong>退化问题</strong>，网络层数增加，但是在训练集上的准确率却饱和甚至下降了。这个不能解释为overfitting，因为overfit应该表现为在训练集上表现更好才对。</p><p><strong>怎么解决退化问题？</strong></p><p>深度残差网络。如果深层网络的后面那些层是恒等映射，那么模型就退化为一个浅层网络。那现在要解决的就是学习恒等映射函数了。 但是直接让一些层去拟合一个潜在的恒等映射函数H(x) = x，比较困难，这可能就是深层网络难以训练的原因。但是，如果把网络设计为H(x) = F(x) + x,如下图。我们可以转换为学习一个残差函数F(x) = H(x) - x. 只要F(x)=0，就构成了一个恒等映射H(x) = x. 而且，拟合残差肯定更加容易。</p><h2 id="为什么非常深度的网络在增加更多层时会表现得更差？"><a href="#为什么非常深度的网络在增加更多层时会表现得更差？" class="headerlink" title="为什么非常深度的网络在增加更多层时会表现得更差？"></a>为什么非常深度的网络在增加更多层时会表现得更差？</h2><p>   直觉上推测，更深度的网络不会比更浅度的同类型网络表现更差吧，至少在训练时间上是这样（当不存在过拟合的风险时）。让我们进行一个思想实验，假设我们已经构建了一个   n   层网络，并且实现了一定准确度。那么一个   n+1   层网络至少也应该能够实现同样的准确度——只要简单复制前面   n   层，再在最后一层增加一层恒等映射就可以了。类似地，n+2、n+3   和   n+4   层的网络都可以继续增加恒等映射，然后实现同样的准确度。但是在实际情况下，这些更深度的网络基本上都会表现得更差。</p><p>ResNet   的作者将这些问题归结成了一个单一的假设：直接映射是难以学习的。而且他们提出了一种修正方法：不再学习从   x   到   H ( x )   的基本映射关系，而是学习这两者之间的差异，也就是「残差（residual）」。然后，为了计算   H ( x ) ，我们只需要将这个残差加到输入上即可。</p><p>假设残差为   F ( x ) =H ( x ) -x，那么现在我们的网络不会直接学习   H ( x )   了，而是学习   F ( x ) +x。</p><p>ResNet   的每一个「模块（block）」都由一系列层和一个「捷径（shortcut）」连接组成，这个「捷径」将该模块的输入和输出连接到了一起。然后在元素层面上执行「加法（add）」运算，如果输入和输出的大小不同，那就可以使用零填充或投射（通过   1 × 1   卷积）来得到匹配的大小。</p><p>回到我们的思想实验，这能大大简化我们对恒等层的构建。直觉上就能知道，比起从头开始学习一个恒等变换，学会使   F ( x )   为   0   并使输出仍为   x   要容易得多。一般来说，ResNet   会给层一个「参考」点   x，以   x   为基础开始学习。</p><p>在此之前，深度神经网络常常会有梯度消失问题的困扰，即来自误差函数的梯度信号会在反向传播回更早的层时指数级地下降。本质上讲，在误差信号反向回到更早的层时，它们会变得非常小以至于网络无法学习。但是，因为   ResNet   的梯度信号可以直接通过捷径连接回到更早的层，所以我们一下子就可以构建   50   层、101   层、152   层甚至   1000   层以上的网络了，而且它们的表现依然良好。</p><p>对于shortcut的方式，作者提出了三个选项：<br>A. 使用恒等映射，如果residual block的输入输出维度不一致，对增加的维度用0来填充；<br>B. 在block输入输出维度一致时使用恒等映射，不一致时使用线性投影以保证维度一致； </p><p>C. 对于所有的block均使用线性投影。 </p><p>对这三个选项都进行了实验，发现虽然C的效果好于B的效果好于A的效果，但是差距很小，因此线性投影并不是必需的，而使用0填充时，可以保证模型的复杂度最低，这对于更深的网络是更加有利的。<br>模型结构图中，我们可以清楚的<strong>”实线“</strong>和<strong>”虚线“</strong>两种连接方式，<br>1）实线的的Connection部分都是3x3x64的特征图，他们的channel个数一致，所以采用计算方式：<br><strong>y=F(x)+x</strong><br>2）虚线的的Connection部分分别是3x3x64和3x3x128的特征图，他们的channel个数不同(64和128)，所以采用计算方式： <strong>y=F(x)+Wx</strong> 。其中W是卷积操作，用来调整x的channel维度的。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO模型epoll</title>
      <link href="/2018/11/22/IO%E6%A8%A1%E5%9E%8Bepoll/"/>
      <url>/2018/11/22/IO%E6%A8%A1%E5%9E%8Bepoll/</url>
      
        <content type="html"><![CDATA[<h1 id="IO模型epoll"><a href="#IO模型epoll" class="headerlink" title="IO模型epoll"></a>IO模型epoll</h1><p>epoll的设计和实现与select完全不同。epoll使用红黑树实现的。把原先的select/poll调用分成了3个部分：<br>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)<br>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字 </p><p>3）调用epoll_wait收集发生的事件的连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO模型</title>
      <link href="/2018/11/22/IO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/22/IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="同步、异步与阻塞、非阻塞的区别"><a href="#同步、异步与阻塞、非阻塞的区别" class="headerlink" title="同步、异步与阻塞、非阻塞的区别"></a>同步、异步与阻塞、非阻塞的区别</h2><p><strong>同步和异步关注的是消息通信机制。</strong></p><p>同步就是发出一个调用之后，在没有得到结果之前，这个调用就不返回。调用返回就得到了结果。调用者主动等待得到这个结果。</p><p>异步就是发出一个调用之后，就直接返回了，没有返回结果。有结果之后被调用者通过其他方式通知调用者消息。</p><p><strong>阻塞和非阻塞关注的是程序等待调用结果（消息，返回值）时的状态</strong></p><p>阻塞调用是指调用结果返回之前，当前线程被挂起来。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用是指不能立即得到结果之前，这个调用不会阻塞当前线程。</p><h2 id="IO模型可以分为"><a href="#IO模型可以分为" class="headerlink" title="IO模型可以分为"></a>IO模型可以分为</h2><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>同步阻塞迭代模型是最简单的一种IO模型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind(srvfd);</span><br><span class="line">listen(srvfd);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    clifd = accept(srvfd,...); <span class="comment">//开始接受客户端来的连接</span></span><br><span class="line">    read(clifd,buf,...); <span class="comment">//从客户端读取数据</span></span><br><span class="line">    dosomthingonbuf(buf);</span><br><span class="line">    write(clifd,buf)<span class="comment">//发送数据到客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序存在如下一些弊端：</p><p>1）如果没有客户端的连接请求，进程会阻塞在accept系统调用处，程序不能执行其他任何操作。(系统调用使得程序从用户态陷入内核态，具体请参考：程序员的自我修养<br>2）在与客户端建立好一条链路后，通过read系统调用从客户端接受数据，而客户端合适发送数据过来是不可控的。如果客户端迟迟不发生数据过来，则程序同样会阻塞在read调用，此时，如果另外的客户端来尝试连接时，都会失败。 </p><p>3）同样的道理，<strong>write系统</strong>调用也会使得程序出现阻塞(例如：客户端接受数据异常缓慢，导致写缓冲区满，数据迟迟发送不出)。</p><p><strong>2.多进程并发模型</strong><br>同步阻塞迭代模型有诸多缺点。多进程并发模型在同步阻塞迭代模型的基础上进行了一些改进，以避免是程序阻塞在read系统调用上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bind(srvfd);</span><br><span class="line">listen(srvfd);</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">clifd = accept(srvfd,...); <span class="comment">//开始接受客户端来的连接</span></span><br><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">switch</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span> :</span><br><span class="line">        do_err_handler();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 子进程</span></span><br><span class="line">        client_handler(clifd);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 父进程</span></span><br><span class="line">        close(clifd);</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handler</span><span class="params">(clifd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(clifd,buf,...); <span class="comment">//从客户端读取数据</span></span><br><span class="line">    dosomthingonbuf(buf);</span><br><span class="line">    write(clifd,buf)<span class="comment">//发送数据到客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序在accept系统调用时，如果没有客户端来建立连接，择<strong>会阻塞在accept处</strong>。一旦某个客户端连接建立起来，则立即开启一个新的进程来处理与这个客户的数据交互。避免程序阻塞在read调用，而影响其他客户端的连接。 </p><p><strong>多线程并发模型</strong><br>在多进程并发模型中，每一个客户端连接开启fork一个进程，虽然linux中引入了写实拷贝机制，大大降低了fork一个子进程的消耗，但若客户端连接较大，则系统依然将不堪负重。<strong>通过多线程(或线程池)并发模型，可以在一定程度上改善这一问题。</strong></p><p>在服务端的线程模型实现方式一般有三种：<br>（1）按需生成(来一个连接生成一个线程)<br>（2）线程池(预先生成很多线程)**<br>（3）Leader follower（LF）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_callback</span><span class="params">( <span class="keyword">void</span> *args )</span> <span class="comment">//线程回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clifd = *(<span class="keyword">int</span> *)args ;</span><br><span class="line">    client_handler(clifd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handler</span><span class="params">(clifd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(clifd,buf,...); <span class="comment">//从客户端读取数据</span></span><br><span class="line">    dosomthingonbuf(buf);</span><br><span class="line">    write(clifd,buf)<span class="comment">//发送数据到客户端</span></span><br><span class="line">&#125;</span><br><span class="line">bind(srvfd);</span><br><span class="line">listen(srvfd);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    clifd = accept();</span><br><span class="line">    pthread_create(...,thread_callback,&amp;clifd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端分为主线程和工作线程，主线程负责accept()连接，而工作线程负责处理业务逻辑和流的读取等。<br>因此，即使在工作线程阻塞的情况下，也只是阻塞在线程范围内，对继续接受新的客户端连接不会有影响。<br>第二种实现方式，通过线程池的引入可以避免频繁的创建、销毁线程，能在很大程序上提升性能。<br>但不管如何实现，<strong>多线程模型先天具有如下缺点：</strong><br><strong>1）稳定性相对较差。一个线程的崩溃会导致整个程序崩溃。</strong> </p><p><strong>2）临界资源的访问控制，在加大程序复杂性的同时，锁机制的引入会是严重降低程序的性能。性能上可能会出现“辛辛苦苦好几年，一夜回到解放前”的情况。</strong></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>采用轮询的方式 （大量浪费CPU的资源）</p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>发送一个SIGIO信号通知，一般只适用与单线程。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用模型之select/poll<br>多进程模型和多线程(线程池)模型每个进程/线程只能处理一路IO，在服务器并发数较高的情况下，过多的进程/线程会使得服务器性能下降。而通过多路IO复用，能使得一个进程同时处理多路IO，提升服务器吞吐量。 </p><h2 id="在Linux支持epoll模型之前，都使用select-poll模型来实现IO多路复用。"><a href="#在Linux支持epoll模型之前，都使用select-poll模型来实现IO多路复用。" class="headerlink" title="在Linux支持epoll模型之前，都使用select/poll模型来实现IO多路复用。 "></a>在Linux支持epoll模型之前，都使用select/poll模型来实现IO多路复用。 </h2><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bind(listenfd);</span><br><span class="line">listen(listenfd);</span><br><span class="line">FD_ZERO(&amp;allset);</span><br><span class="line">FD_SET(listenfd, &amp;allset);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    select(...);</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) </span><br><span class="line">    &#123;<span class="comment">/*有新的客户端连接到来*/</span></span><br><span class="line">        clifd = accept();</span><br><span class="line">        cliarray[] = clifd; <span class="comment">/*保存新的连接套接字*/</span></span><br><span class="line">        FD_SET(clifd, &amp;allset);<span class="comment">/*将新的描述符加入监听数组中*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;<span class="comment">/*这个for循环用来检查所有已经连接的客户端是否有数据可读写*/</span></span><br><span class="line"></span><br><span class="line">        fd = cliarray[i];</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fd , &amp;rset))</span><br><span class="line">            dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select IO多路复用同样存在一些缺点，罗列如下：</p><p>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select<strong>采用轮询的方式扫描文件描述符</strong>，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024)<br>2、内核 / 用户空间内存拷贝问题    ，select需要复制大量的句柄数据结构，产生巨大的开销； </p><p>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；<br><strong>select的触发方式是水平触发，</strong>应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。<br>3、相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。 </p><h2 id="拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在-FD-SETSIZE-为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核-用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。"><a href="#拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在-FD-SETSIZE-为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核-用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。" class="headerlink" title="拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。"></a>拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。</h2><p>socket函数格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>先说明两个结构体：<br>第一 .struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄，这可以是我们所说的普通意义的文件，当然 Unix下任何设备、管道、FIFO等都是文件形式，全部包括在内，所以毫无疑问一个socket就是一个文件，socket句柄就是一个文件描述符。<br>fd_set集合可以通过一些宏由人为来操作，比如：<br><strong>FD_ZERO(fd_set <em>);清空集合<br>FD_SET(int, fd_set </em>);将一个给定的文件描述符加入集合之中<br>FD_CLR(int, fd_set*); 将一个给定的文件描述符从集合中删除</strong><br><strong>检查集合中指定的文件描述符是否可以读写FD_ISSET(int ,fd_set* )</strong>。一会儿举例说明。</p><p>第二 .struct timeval 是一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个是微秒。 具体解释select的参数：<br>int maxfdp：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。</p><p>fd_set<em> readfds：是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中 读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断 是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。<br>fd_set</em> writefds：是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件 中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判 断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。<br>fd_set * errorfds：同上面两个参数的意图，用来监视文件错误异常。</p><p>struct timeval* timeout：是select的超时时间，这个参数至关重要，它可以使select处于三种状态：<br>第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；<br>第二，若将时间值设为0秒0微秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值； </p><p>第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。</p><p><strong>select 返回值：</strong><br>负值：select错误<br>正值：某些文件可读写或出错<br>0：等待超时，没有可读写或错误的文件<br>在有了select后可以写出像样的网络程序来！<br>举个简单的例子，就是从网络上接受数据写入一个文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> sock;  </span><br><span class="line">    FILE *fp;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> <span class="title">fds</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>=&#123;</span><span class="number">3</span>,<span class="number">0</span>&#125;; <span class="comment">//select等待3秒，3秒轮询，要非阻塞就置0  </span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//256字节的接收缓冲区  </span></span><br><span class="line">    <span class="comment">/* 假定已经建立UDP连接，具体过程不写，简单，当然TCP也同理，主机ip和port都已经给定，要写的文件已经打开 </span></span><br><span class="line"><span class="comment">    sock=socket(...); </span></span><br><span class="line"><span class="comment">    bind(...); </span></span><br><span class="line"><span class="comment">    fp=fopen(...); */</span>  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">   &#123;  </span><br><span class="line">        FD_ZERO(&amp;fds); <span class="comment">//每次循环都要清空集合，否则不能检测描述符变化  </span></span><br><span class="line">        FD_SET(sock,&amp;fds); <span class="comment">//添加描述符  </span></span><br><span class="line">        FD_SET(fp,&amp;fds); <span class="comment">//同上  </span></span><br><span class="line">        maxfdp=sock&gt;fp?sock+<span class="number">1</span>:fp+<span class="number">1</span>;    <span class="comment">//描述符最大值加1  </span></span><br><span class="line">        <span class="keyword">switch</span>(select(maxfdp,&amp;fds,&amp;fds,<span class="literal">NULL</span>,&amp;timeout))   <span class="comment">//select使用  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>: <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="keyword">break</span>; <span class="comment">//select错误，退出程序  </span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>; <span class="comment">//再次轮询  </span></span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                  <span class="keyword">if</span>(FD_ISSET(sock,&amp;fds)) <span class="comment">//测试sock是否可读，即是否网络上有数据  </span></span><br><span class="line">                  &#123;  </span><br><span class="line">                        recvfrom(sock,buffer,<span class="number">256</span>,.....);<span class="comment">//接受网络数据  </span></span><br><span class="line">                        <span class="keyword">if</span>(FD_ISSET(fp,&amp;fds)) <span class="comment">//测试文件是否可写  </span></span><br><span class="line">                            fwrite(fp,buffer...);<span class="comment">//写入文件  </span></span><br><span class="line">                         buffer清空;  </span><br><span class="line">                   &#125;<span class="comment">// end if break;  </span></span><br><span class="line">          &#125;<span class="comment">// end switch  </span></span><br><span class="line">     &#125;<span class="comment">//end while  </span></span><br><span class="line">&#125;<span class="comment">//end main</span></span><br></pre></td></tr></table></figure><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gdb调试</title>
      <link href="/2018/11/20/gdb%E8%B0%83%E8%AF%95/"/>
      <url>/2018/11/20/gdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Cmake：</p><p><a href="https://blog.csdn.net/gg_18826075157/article/details/72780431" target="_blank" rel="noopener">https://blog.csdn.net/gg_18826075157/article/details/72780431</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-cmake/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-cmake/</a></p><table><thead><tr><th>命令</th><th>命令缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>显示多行源代码</td></tr><tr><td>break</td><td>b</td><td>设置断点,程序运行到断点的位置会停下来</td></tr><tr><td>info</td><td>i</td><td>描述程序的状态</td></tr><tr><td>run</td><td>r</td><td>开始运行程序</td></tr><tr><td>display</td><td>disp</td><td>跟踪查看某个变量,每次停下来都显示它的值</td></tr><tr><td>step</td><td>s</td><td>执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</td></tr><tr><td>next</td><td>n</td><td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</td></tr><tr><td>print</td><td>p</td><td>打印内部变量值</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行,直到遇到下一个断点</td></tr><tr><td>set var name=v</td><td></td><td>设置变量的值</td></tr><tr><td>start</td><td>st</td><td>开始执行程序,在main函数的第一条语句前面停下来</td></tr><tr><td>file</td><td></td><td>装入需要调试的程序</td></tr><tr><td>kill</td><td>k</td><td>终止正在调试的程序</td></tr><tr><td>watch</td><td></td><td>监视变量值的变化</td></tr><tr><td>backtrace</td><td>bt</td><td>产看函数调用信息(堆栈)</td></tr><tr><td>frame</td><td>f</td><td>查看栈帧</td></tr><tr><td>quit</td><td>q</td><td>退出GDB环境</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>进程通信</title>
      <link href="/2018/11/20/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/11/20/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：<br>​    进程同步：控制多个进程按一定顺序执行；<br>​    进程通信：进程间传输信息。<br>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><p>进程原语和线程原语的比较：</p><p>进程原语    线程原语            描述<br>fork      pthread_create        创建新的控制流<br>exit            pthread_exit                   从现有的控制流退出<br>waitpid    pthread_join            从控制流中得到退出状态<br>atexit    pthread_cancle_push    注册在退出控制流时调用的函数<br>getpid    pthread_self            获取控制流的ID</p><p>abort    pthread_cancle    请求控制流的非正常退出</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p><a href="https://blog.csdn.net/kowzb/article/details/77160249" target="_blank" rel="noopener">https://blog.csdn.net/kowzb/article/details/77160249</a></p><p>一、进程间的通信方式</p><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>有名管道 (FIFO) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>信号 (sinal ) (异步的过程)： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>二、线程间的通信方式</p><p>锁机制：<strong>包括互斥锁、条件变量、读写锁</strong><br>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量<br>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>STL原理实现</title>
      <link href="/2018/11/20/STL%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/20/STL%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="STL原理实现"><a href="#STL原理实现" class="headerlink" title="STL原理实现"></a>STL原理实现</h1><h2 id="智能指针原理"><a href="#智能指针原理" class="headerlink" title="智能指针原理"></a>智能指针原理</h2><p>智能指针是一种资源管理类，通过对原始指针进行封装，在资源管理对象进行析构时对指针指向的内存进行释放；通常使用引用计数方式进行管理</p><h2 id="STL中vector的实现原理"><a href="#STL中vector的实现原理" class="headerlink" title="STL中vector的实现原理"></a>STL中vector的实现原理</h2><p><strong>vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，  对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了  。</strong></p><h2 id="STL中map的实现原理"><a href="#STL中map的实现原理" class="headerlink" title="STL中map的实现原理"></a>STL中map的实现原理</h2><p>Map是关联容器，以键值对的形式进行存储，方便进行查找，关键词起到索引的作用，值则表示与索引相关联的数据，以红黑树的结构实现，插入删除等操作都可以在O(log n)时间内完成</p><h2 id="STL中set的实现原理"><a href="#STL中set的实现原理" class="headerlink" title="STL中set的实现原理"></a>STL中set的实现原理</h2><p>Set是关联容器，set中每个元素都只包含一个关键字，set支持高效的关键字查询操作—检查每一个给定的关键字是否在set中，set是以红黑树的平衡二叉检索树结构实现的，支持高效插入删除，插如元素的时候会自动调整二叉树的结构，使得每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值，另外还得保证左子树和右子树的高度相等</p><p>​     平衡二叉检索树使用中序遍历算法，检索效率高于vector，deque，list等容器，另外使用中序遍历可将键值按照从小到大遍历出来</p><p>  构造set集合的主要目的是为了快速检索，不可直接去修改键值</p><h2 id="verctor"><a href="#verctor" class="headerlink" title="verctor"></a>verctor</h2><p>vector类似于C语言中的数组，它维护一段连续的内存空间，具有固定的起始地址，因而能非常方便地进行随机存取，即 [] 操作符，但因为它的内存区域是连续的，所以在它中间插入或删除某个元素，需要复制并移动现有的元素。此外，当被插入的内存空间不够时，需要重新申请一块足够大的内存并进行内存拷贝。值得注意的是，vector每次扩容为原来的两倍，对小对象来说执行效率高，但如果遇到大对象，执行效率就低了。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h2><p>list类似于C语言中的双向链表，它通过指针来进行数据的访问，因此维护的内存空间可以不连续，这也非常有利于数据的随机存取，因而它没有提供 [] 操作符重载。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a><strong>deque</strong></h2><p>deque类似于C语言中的双向队列，即两端都可以插入或者删除的队列。queue支持 [] 操作符，也就是支持随机存取，而且跟vector的效率相差无几。它支持两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上与list的效率<br>也差不多。或者我们可以这么认为，deque是vector跟list的折中。</p><p><strong>map</strong></p><p>map类似于数据库中的１:１关系，它是一种关联容器，提供一对一(<a href="http://www.cpplive.com/html/tag/cpp" target="_blank" rel="noopener">C++</a> primer中文版中将第一个译为键，每个键只能在map中出现一次，第二个被译为该键对应的值)的数据处理能力，这种特性了使得map类似于数据结构里的红黑二叉树。</p><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a><strong>multimap</strong></h2><p>multimap类似于数据库中的１:Ｎ关系，它是一种关联容器,提供一对多的数据处理能力。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h2><p>set类似于数学里面的集合，不过set的集合中不包含重复的元素，这是和vector的第一个区别，第二个区别是set内部用平衡二叉树实现，便于元素查找，而vector是使用连续内存存储，便于随机存取。</p><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a><strong>multiset</strong></h2><p>multiset类似于数学里面的集合，集合中可以包含重复的元素。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>１、如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p><p>2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p><p>3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p><p>4、如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p><p>5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据库</title>
      <link href="/2018/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>索引的概述(什么是索引,索引的优缺点)</li><li>索引的基本使用（创建索引）</li><li>索引的基本原理（面试重点）</li><li>索引的数据结构（B树，hash）</li><li>创建索引的原则（重中之重，面试必问！敬请收藏！）</li><li>百万级别或以上的数据如何删除</li></ul><p><a href="https://www.cnblogs.com/shijingxiang/articles/4743324.html" target="_blank" rel="noopener">https://www.cnblogs.com/shijingxiang/articles/4743324.html</a></p><p><strong>一、索引的概述</strong></p><p><strong>1）什么是索引？</strong></p><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，索引就相当于目录。当你在用新华字典时，帮你把目录撕掉了，你查询某个字开头的成语只能从第一页翻到第一千页。累！把目录还给你，则能快速定位！</p><p><strong>2）索引的优缺点：</strong></p><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。，且通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。但是，索引也是有缺点的：索引需要额外的维护成本；因为索引文件是单独存在的文件,对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。</p><p><strong>二、索引的基本使用（真技术文）</strong></p><p><strong>1）创建索引：（三种方式）</strong></p><p>第一种方式：创建表的时候创建</p><p><img src="https://files.jb51.net/file_images/article/201711/2017111691555019.jpg?201710169164" alt="img"></p><p><strong>第二种方式：使用ALTER TABLE命令去增加索引：</strong></p><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p><img src="https://files.jb51.net/file_images/article/201711/2017111691657597.jpg?201710169175" alt="img"></p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p><strong>第三种方式：使用CREATE INDEX命令创建</strong></p><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p><img src="https://files.jb51.net/file_images/article/201711/2017111691857883.jpg?201710169196" alt="img"></p><p><strong>三、索引的基本原理（不想像别的文章那样一大堆篇幅废话）</strong></p><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><p>​      1、把创建了索引的列的内容进行排序</p><p>​      2、对排序结果生成倒排表</p><p>​      3、在倒排表内容上拼上数据地址链</p><p>​      4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>常用的数据结构</title>
      <link href="/2018/11/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/11/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">数据结构</a>。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933" target="_blank" rel="noopener">散列表</a>。</p><ul><li>若关键字为<strong>k</strong>，则其值存放在<strong>f(k)</strong>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<strong>f</strong>为散列函数，按这个思想建立的表为散列表。</li><li>对不同的关键字可能得到同一散列地址，即<strong>k1≠k2</strong>，而<strong>f(k1)=f(k2)</strong>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数<strong>f(k)</strong>和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</li><li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li></ul><p><strong>常用的构造散列函数的方法</strong></p><p>　　散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位：</p><p>　　<strong>1. 直接寻址法：</strong>取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，其中a和b为常数（这种散列函数叫做自身函数）</p><p>　　<strong>2. 数字分析法：</strong>分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><p>　　<strong>3. 平方取中法：</strong>取关键字平方后的中间几位作为散列地址。</p><p>　　<strong>4. 折叠法：</strong>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。</p><p>　　<strong>5. 随机数法：</strong>选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</p><p>　　<strong>6. 除留余数法：</strong>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。<br><strong>查找的性能分析</strong></p><p>实际工作中需视不同的情况采用不同的<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">哈希函数</a>，通常考虑的因素有：</p><p>· 计算<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">哈希函数</a>所需时间</p><p>· 关键字的长度</p><p>· 哈希表的大小</p><p>· 关键字的分布情况</p><p>· 记录的查找频率</p><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>（1）开散列的方法：把冲突记录存在表外。</p><p>把散列表的每个槽定义为一个链表的表头，散列到一个槽的所有记录都要放在这个槽的链表里面。</p><p>（2）闭散列的方法：</p><p>桶式散列</p><p>线性探测</p><p>伪随机探测</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis 概要</title>
      <link href="/2018/11/20/redis-%E6%A6%82%E8%A6%81/"/>
      <url>/2018/11/20/redis-%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。<br>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。<br>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><p>Key-Value存储:(基于Redis)</p><p>传统的关系型数据库，处理一对多的问题，需要把外键放在多的一端，因为RDBMS理论中没有集合这个概念。而使用Redis，我们可以在一端来管理一对多的关系，使用Set。</p><p>如果使用MySQL，当数据规模非常大时，上面两个查询操作都需要借助表关联技术，而大表间的join在大型系统中是需要极力避免的操作。相反Redis的每个操作都会局限在一个较小的数据集范围内，而且key-value的存储形式，定位key只是一个复杂度为O(1)的操作。在very huge的数据量下，Redis性能效果非常优异，这就是NoSQL的优势所在！</p><h2 id="Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted-set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。"><a href="#Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted-set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。" class="headerlink" title="Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。"></a>Redis是由C语言编写的。Redis支持5种数据类型，以K-V形式进行存储，K是String类型的，V支持5种不同的数据类型，分别是：string，list，hash，set，sorted set，每一种数据结构都有其特定的应用场景。从内部实现的角度来看是如何更好的实现这些数据类型。</h2><h2 id="Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。"><a href="#Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。" class="headerlink" title="Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。"></a>Redis底层数据结构有以下数据类型：简单动态字符串（SDS），链表，字典，跳跃表，整数集合，压缩列表，对象。</h2><p><strong>Redis 选择了高效且实现简单的哈希表作为字典的底层实现。</strong></p><p>Redis通常将数据存储于内存中，或被配置为使用虚拟内存。Redis有一个很重要的特点就是它可以实现持久化数据，通过两种方式可以实现数据持久化：使用RDB快照的方式，将内存中的数据不断写入磁盘；或使用类似MySQL的AOF日志方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>C++设计模式</title>
      <link href="/2018/11/20/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/20/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的设计模式"><a href="#C-的设计模式" class="headerlink" title="C++的设计模式"></a>C++的设计模式</h1><p><strong>c++设计模式：</strong></p><p>简单工厂模式</p><p>工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。</p><p>使用情景：<br>  在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。<br>案例：<br>如果实现计算器的功能时，对于同样的输入数据，可能执行加、减、乘、除，甚至其他的功能。因此可以抽象出一个操作的抽象类或是接口，提供一个统一的处理方法(此处为process)，然后每种操作创建出一个子类出来。而判断具体使用哪个具体的实现类是在工厂类中进行判断的(将存放操作的变量传递给工厂的生产方法)。工厂类始终返回的是这个抽象类，这样如果对原有功能进行更改或是新添加新的功能，也不会对原来的其他类做修改，只编译修改的那个类或是新的类就可以了。<br>这样就做到了把耦合降到最低，同时也便于维护。 </p><p>简单工厂：针对同样的数据，不同的操作用同一个接口</p><p>工厂方法：针对同样的数据，不同的操作用不同的接口</p><p>抽象工厂：针对不同的数据，不同的操作用不同的接口</p><p>策略模式：依赖c++的多态，抽象类的指针可以访问所有子类对象，（纯虚函数），可以用一个指针访问所有策略的实现类</p><p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式(不能让一个程序打开两次  如：不能同时打开2个迅雷  迅雷用的单例模式)</p><p>访问者模式:适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数)</p><p>观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。(QT的信号机制，Windows的消息机制都应用了观察者模式，还有订阅邮件，邮件到了就会给你发邮件)</p><p>建造者模式：使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器)</p><p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式)</p><p>命令模式：把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构))</p><p>模板模式：不同的子类可以以不同的方式实现这些抽象方法，</p><p>从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，</p><p>而将逻辑的细节留给具体的子类去实现。(适用于本地化，做一个软件，在日本是日文，美国是英语…)</p><p>桥接模式：将抽象化与实现化脱离，使得二者可以独立的变化，</p><p>也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起)</p><p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。</p><p>外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用)</p><p>享元模式：享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。</p><p>原型模式：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p><p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了)</p><p>中介者模式：中介者模式包装了一系列对象相互作用的方式，</p><p>使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p><p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术）</p><p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p><p>状态模式：意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床…这就是状态)</p><p>合成模式：将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓展</title>
      <link href="/2018/11/19/%E6%8B%93%E5%B1%95/"/>
      <url>/2018/11/19/%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="手游如何克服网络延迟问题？"><a href="#手游如何克服网络延迟问题？" class="headerlink" title="手游如何克服网络延迟问题？"></a>手游如何克服网络延迟问题？</h1><p>网络游戏同步，常用的两种方案是<strong>帧同步和状态同步</strong></p><p>帧同步：是同步玩家的指令，服务器负责转发客户端的操作，每个客户端以固定的逻辑帧执行所有客户端的操作指令，通过在严格一致的时间轴上执行同样的命令序列获得同样的结果。</p><p>状态同步跟帧同步的最大区别是服务器不在进行切逻辑帧，而是同步玩家状态信息，比如位置、属性、跟玩法相关的数据。通常主逻辑在服务器运行，客户端只是作为一个显示。采用状态同步的游戏有CFM、LOL等。</p><p>帧同步的网络流量较小，但防外挂、断线重连的难度比较大。状态同步中服务器有所有玩家的状态，安全性较高，游戏运营更可控。是否选择状态同步，需要看同步的实体数量。在大场景中，同步的单位比较多时，往往会放弃状态同步。比如星际争霸中玩家可操作的实体多达上百个，如采用状态同步的话网络流量将非常大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下的常用操作</title>
      <link href="/2018/11/19/Linux%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/19/Linux%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-下的常用操作"><a href="#Linux-下的常用操作" class="headerlink" title="Linux 下的常用操作"></a>Linux 下的常用操作</h1><p><img src="/2018/11/19/Linux下的常用操作/H:/hexo\source\_posts\Linux下的常用操作\1.png" alt=""></p><h2 id="shell怎么写"><a href="#shell怎么写" class="headerlink" title="shell怎么写"></a>shell怎么写</h2><p><a href="https://www.cnblogs.com/wuyuegb2312/p/3399566.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyuegb2312/p/3399566.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串处理</title>
      <link href="/2018/11/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2018/11/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>计算机网络的基础知识</title>
      <link href="/2018/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的基础知识"><a href="#计算机网络的基础知识" class="headerlink" title="计算机网络的基础知识"></a>计算机网络的基础知识</h1><a id="more"></a><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><h2 id="ARP是地址解析协议，简单语言解释一下工作原理。"><a href="#ARP是地址解析协议，简单语言解释一下工作原理。" class="headerlink" title="ARP是地址解析协议，简单语言解释一下工作原理。"></a>ARP是地址解析协议，简单语言解释一下工作原理。</h2><p>答:1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。<br>广播发送ARP请求，单播发送ARP响应。</p><h2 id="各种协议的介绍"><a href="#各种协议的介绍" class="headerlink" title="各种协议的介绍"></a>各种协议的介绍</h2><p>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p><p>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p><p>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p><p>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p><p>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h1 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h1><p><strong>TCP与UDP区别总结：</strong><br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br>TCP对应的协议和UDP对应的协议<br>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>答:当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p><h2 id="tcp粘包问题，怎么处理？"><a href="#tcp粘包问题，怎么处理？" class="headerlink" title="tcp粘包问题，怎么处理？"></a>tcp粘包问题，怎么处理？</h2><p><a href="https://www.cnblogs.com/kex1n/p/6502002.html" target="_blank" rel="noopener">https://www.cnblogs.com/kex1n/p/6502002.html</a></p><h2 id="udp会粘包吗？为什么？"><a href="#udp会粘包吗？为什么？" class="headerlink" title="udp会粘包吗？为什么？"></a>udp会粘包吗？为什么？</h2><h2 id="https的原理，和http的区别"><a href="#https的原理，和http的区别" class="headerlink" title="https的原理，和http的区别"></a>https的原理，和http的区别</h2><h2 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h2><pre><code>客户端：SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT。 服务端：LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。</code></pre><h2 id="TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br>（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux的基础知识</title>
      <link href="/2018/11/18/Linux%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/18/Linux%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h1><a id="more"></a><h2 id="Linux的用户态和内核态"><a href="#Linux的用户态和内核态" class="headerlink" title="Linux的用户态和内核态"></a>Linux的用户态和内核态</h2><p><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5520860.html</a></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>（1）拥有资源：进程是资源分配的基本单元，但是线程不拥有资源，线程可以访问其所隶属进程的资源。</p><p>（2）调度：线程是独立调度的基本单位。在同一个进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>（3）系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>（4）线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="linux怎么查看内存占用、CPU占用、IO占用"><a href="#linux怎么查看内存占用、CPU占用、IO占用" class="headerlink" title="linux怎么查看内存占用、CPU占用、IO占用"></a>linux怎么查看内存占用、CPU占用、IO占用</h2><p>进程：ps aux</p><p>内存占用:free</p><p>CPU占用:top,</p><p>IO占用:iostat</p><p>虚拟内存统计:vmstat</p><p>sar</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>管道、共享内存、消息队列、套接字、信号、信号量</p><h2 id="fork的返回值，什么时候是子进程，什么时候是父进程"><a href="#fork的返回值，什么时候是子进程，什么时候是父进程" class="headerlink" title="fork的返回值，什么时候是子进程，什么时候是父进程"></a>fork的返回值，什么时候是子进程，什么时候是父进程</h2><p>子：0  父：子进程的pid</p><h2 id="进程和线程的区别以及孤儿、僵尸、守护进程"><a href="#进程和线程的区别以及孤儿、僵尸、守护进程" class="headerlink" title="进程和线程的区别以及孤儿、僵尸、守护进程"></a>进程和线程的区别以及孤儿、僵尸、守护进程</h2><h3 id="父进程、子进程："><a href="#父进程、子进程：" class="headerlink" title="父进程、子进程："></a><strong>父进程、子进程</strong>：</h3><p>父进程和子进程的关系是：子进程是父进程的一个副本，一个父进程能创建多个子进程，创建子进程能并发执行。一般来说，子进程先结束执行，然后父进程负责子进程的一些善后工作（回收资源）。</p><h3 id="孤儿进程："><a href="#孤儿进程：" class="headerlink" title="孤儿进程："></a><strong>孤儿进程</strong>：</h3><p>父进程运行结束，但子进程还在运行(未运行结束)的子进程就称为孤儿进程。孤儿进程最终会被init进程(进程号为1)所收养，因此init进程此时变成孤儿进程的父进程，并由init进程对它们完成状态收集工作。（linux下，init是内核启动的第一个用户级进程，init有许多很重要的任务，比如像启动getty（用于用户登录）、实现运行级别、以及处理孤立进程。）</p><h3 id="僵尸进程："><a href="#僵尸进程：" class="headerlink" title="僵尸进程："></a><strong>僵尸进程</strong>：</h3><p>一个进程使用fork创建子进程，如果子进程退出执行后，父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</p><p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。所以僵尸进程是有危害的。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程:"></a><strong>守护进程</strong>:</h3><p>守护进程也就是通常说的Daemon进程（精灵进程），是Linux中的后台服务进程，是个特殊的孤儿进程。它是一个生存期较长的进程，通常独立于控制终端（不会因为控制终端被关闭而中断）并且周期性地执行某种任务或等待处理某些发生的事件。举例：nignx、mysql、cron都是守护进程。</p><h2 id="讲讲守护进程"><a href="#讲讲守护进程" class="headerlink" title="讲讲守护进程"></a>讲讲守护进程</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试复习法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的基础知识</title>
      <link href="/2018/11/18/C++%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/18/C++%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的基础知识"><a href="#C-的基础知识" class="headerlink" title="C++的基础知识"></a>C++的基础知识</h1><a id="more"></a><h2 id="C-的默认构造函数"><a href="#C-的默认构造函数" class="headerlink" title="C++的默认构造函数"></a>C++的默认构造函数</h2><p><strong>默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：</strong></p><ol><li><strong>没有带明显形参的构造函数。</strong></li><li><strong>提供了默认实参的构造函数。</strong>  </li></ol><p><strong>类设计者可以自己写一个默认构造函数。编译器帮我们写的默认构造函数，称为“合成的默认构造函数”。强调“没有带明显形参”的原因是，编译器总是会为我们的构造函数形参表插入一个隐含的this指针，所以”本质上”是没有不带形参的构造函数的，只有不带明显形参的构造函数，它就是默认构造函数。</strong></p><h2 id="C-类的构造顺序"><a href="#C-类的构造顺序" class="headerlink" title="C++类的构造顺序"></a>C++类的构造顺序</h2><ol><li>分配内存，在调用构造函数时候，隐式/显式的初始化各项在初始化列表的成员。</li><li>进入构造函数后在构造函数中执行一般的赋值与计算。</li></ol><h2 id="C-的初始化列表"><a href="#C-的初始化列表" class="headerlink" title="C++的初始化列表"></a>C++的初始化列表</h2><p><strong>对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表</strong>。但有的时候必须用带有初始化列表的构造函数：<br><strong>1.成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若程序员没有为类写默认构造函数，则编译器尝试使用默认构造函数将会失败。</strong><br><strong>2.const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值。</strong></p><h2 id="初始化数据成员与对数据成员赋值的含义是什么？有什么区别？"><a href="#初始化数据成员与对数据成员赋值的含义是什么？有什么区别？" class="headerlink" title="初始化数据成员与对数据成员赋值的含义是什么？有什么区别？"></a>初始化数据成员与对数据成员赋值的含义是什么？有什么区别？</h2><p><strong>在构造函数中再进行成员对象的赋值，这会导致成员对象被构造多次。 更重要的是，因为常量类型、引用类型的成员不接受赋值，它们只能在初始化列表中进行初始化。</strong></p><p>首先把数据成员按类型分类并分情况说明:<br>1.<strong>内置数据类型，复合类型（指针，引用）</strong><br>​    在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的<br>2.<strong>用户定义类型（类类型）</strong><br>​    结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行<strong>调用拷贝构造函数</strong>来构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）</p><h2 id="C-引用和指针的区别"><a href="#C-引用和指针的区别" class="headerlink" title="C++ 引用和指针的区别"></a>C++ 引用和指针的区别</h2><p>(1)当引用被创建时，它必须被初始化。而指针则可以在任何时候被初始化。</p><p>(2)一旦一个引用被初始化为指向一个对象，它就不能被改变为对另一个对象的引用。而指针则可以在任何时候指向另一个对象。</p><p>(3)不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</p><p>引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率</p><h2 id="C-中const和static的区别"><a href="#C-中const和static的区别" class="headerlink" title="C++中const和static的区别"></a>C++中const和static的区别</h2><p>const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。</p><p>​      static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。</p><p>​      在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static</p><p>​      在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。</p><p>​      const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。</p><p>const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。</p><h2 id="在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？"><a href="#在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？" class="headerlink" title="在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？"></a>在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？</h2><p>父构造函数–&gt;子构造函数–&gt;子析构函数–&gt;父析构函数</p><h2 id="在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为-virtual-吗？如果不申明为-virtual-会怎样？"><a href="#在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为-virtual-吗？如果不申明为-virtual-会怎样？" class="headerlink" title="在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？"></a>在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？</h2><p>构造函数不能够声明为virtual。因为创建对象之后虚函数表才开始创建。</p><h2 id="什么是-C-多态？C-多态的实现原理是什么？"><a href="#什么是-C-多态？C-多态的实现原理是什么？" class="headerlink" title="什么是 C++ 多态？C++ 多态的实现原理是什么？"></a>什么是 C++ 多态？C++ 多态的实现原理是什么？</h2><p>C++的多态分为静态多态和动态多态：</p><p>1.静态多态就是重载，因为在编译期决议确定，所以成为静态多态。</p><p>2.动态多态就是通过继承重写基类的虚函数实现的多态，因为是在运行时决议确定的所以称为动态多态。</p><p>C++的动态多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p><p>  1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  </p><p>  2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  </p><p>  3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  </p><p>  4：多态用虚函数来实现，结合动态绑定.  </p><p>  5:纯虚函数是虚函数再加上 = 0；  </p><p>  6：抽象类是指包括至少一个纯虚函数的类。</p><p>纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</p><h2 id="什么是虚函数？虚函数的实现原理是什么？"><a href="#什么是虚函数？虚函数的实现原理是什么？" class="headerlink" title="什么是虚函数？虚函数的实现原理是什么？"></a>什么是虚函数？虚函数的实现原理是什么？</h2><p>类中的<strong>成员函数</strong>分为<strong>静态成员函数</strong>和<strong>非静态成员函数</strong>，而<strong>非静态成员函数</strong>又分为<strong>普通函数</strong>和<strong>虚函数</strong>。</p><p>虚函数是用来实现动态绑定的。</p><p>虚函数使用虚函数表和虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的函数的地址（子类中可以不是<strong>虚</strong>函数，但是必须同名）；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应不同基类的虚函数表。</p><p><strong>虚函数表</strong>是每个（有虚函数的）<strong>类</strong>对应一个。<strong>虚函数表指针</strong>是每个<strong>对象</strong>对应一个。</p><p>虚函数表里只能存放虚函数，不能存放普通函数。</p><p>如果一个函数不是虚函数，那么对它的调用（即该函数的地址）在<strong>编译</strong>阶段就会确定。调用虚函数的话（它的地址）要<strong>运行</strong>时才能确定。</p><p>虚函数的函数入口是动态绑定的。在运行时，程序根据基类指针指向的<strong>实际对象</strong>，来调用<strong>该对象</strong>对应版本的函数。（用<strong>该对象</strong>的<strong>虚函数表指针</strong>找到其虚函数表，进而调用不同的函数。）（只有是<strong>虚函数</strong>的情况下才会这么做（用虚函数表指针去查虚函数表）。非虚函数直接就调用自己的。）</p><h2 id="为什么需要虚析构函数？（什么情况下要用虚析构函数？）"><a href="#为什么需要虚析构函数？（什么情况下要用虚析构函数？）" class="headerlink" title="为什么需要虚析构函数？（什么情况下要用虚析构函数？）"></a>为什么需要<strong>虚析构函数</strong>？（什么情况下要用虚析构函数？）</h2><p>在存在类继承并且析构函数中需要析构某些资源时，析构函数需要是虚函数。否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，造成内存泄露。</p><h2 id="一个对象访问普通成员函数和虚函数哪个更快？"><a href="#一个对象访问普通成员函数和虚函数哪个更快？" class="headerlink" title="一个对象访问普通成员函数和虚函数哪个更快？"></a><strong>一个对象访问普通成员函数和虚函数哪个更快？</strong></h2><p>访问普通成员函数更快，因为普通成员函数的<strong>地址</strong>在<strong>编译</strong>阶段就已确定，因此在访问时直接调用对应地址的函数；</p><p>而虚函数在调用时，需要首先在虚函数表中<strong>寻找</strong>虚函数所在<strong>地址</strong>，因此相比普通成员函数速度要慢一些。</p><h2 id="内联函数、构造函数、静态成员函数可以是虚函数吗？"><a href="#内联函数、构造函数、静态成员函数可以是虚函数吗？" class="headerlink" title="内联函数、构造函数、静态成员函数可以是虚函数吗？"></a>内联函数、构造函数、静态成员函数可以是虚函数吗？</h2><p>都不可以。</p><p><strong>内联函数</strong>（inline）需要在<strong>编译</strong>阶段展开（在编译时就已经确定了），而虚函数是<strong>运行时</strong>动态绑定的，编译时无法展开，因此是矛盾的；</p><p><strong>构造函数</strong>在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念（先有父类才能有子类，构造父类的时候子类还不存在，子类都还没有怎么可能在父类里动态调用子类）；</p><p><strong>静态成员函数</strong>（static）是以<strong>类</strong>为单位的函数，<strong>与具体对象无关</strong>，虚函数是与对象动态绑定的，因此是两个矛盾的概念；</p><h2 id="构造函数中可以调用虚函数吗？"><a href="#构造函数中可以调用虚函数吗？" class="headerlink" title="构造函数中可以调用虚函数吗？"></a>构造函数中可以调用虚函数吗？</h2><p> 可以，但是没有意义，起不到动态绑定的效果。父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。</p><h2 id="简述C-中虚继承的作用及底层实现原理"><a href="#简述C-中虚继承的作用及底层实现原理" class="headerlink" title="简述C++中虚继承的作用及底层实现原理?"></a>简述C++中虚继承的作用及底层实现原理?</h2><p>虚继承用于解决多继承条件下的<strong>菱形继承</strong>问题，底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。</p><h2 id="什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？"><a href="#什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？" class="headerlink" title="什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？"></a>什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？</h2><h2 id="菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？"><a href="#菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？" class="headerlink" title="菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？"></a>菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？</h2><h2 id="C-中虚继承的作用及底层实现原理"><a href="#C-中虚继承的作用及底层实现原理" class="headerlink" title="C++中虚继承的作用及底层实现原理"></a>C++中虚继承的作用及底层实现原理</h2><p><strong>虚继承和虚函数是完全无相关的两个概念。</strong></p><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。</p><p>虚继承可以解决多种继承前面提到的两个问题：</p><p>虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><p>在这里我们可以对比虚函数的实现原理：他们有相似之处，都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）。</p><p>虚基类依旧存在继承类中，只占用存储空间；虚函数不占用存储空间。</p><p>虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。</p><p>◇执行顺序<br>首先执行虚基类的构造函数，多个虚基类的构造函数按照被继承的顺序构造；<br>执行基类的构造函数，多个基类的构造函数按照被继承的顺序构造；<br>执行成员对象的构造函数，多个成员对象的构造函数按照申明的顺序构造；<br>执行派生类自己的构造函数；<br>析构以与构造相反的顺序执行； </p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>简单的来说，【浅拷贝】是增加了一个指针，指向原来已经存在的内存。而【深拷贝】是增加了一个指针，并新开辟了一块空间</p><p>让指针指向这块新开辟的空间。</p><p>【浅拷贝】在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误</p><p><a href="https://www.cnblogs.com/jianxinzhou/p/3994248.html" target="_blank" rel="noopener">https://www.cnblogs.com/jianxinzhou/p/3994248.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种常见的排序算法</title>
      <link href="/2018/11/18/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/18/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h1><p>本文来谈谈几种常见的排序算法</p><p><img src="/2018/11/18/几种常见的排序算法/1.jpg" alt="你想输入的替代文字"></p><a id="more"></a><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(1)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[min])</span><br><span class="line">&#123;</span><br><span class="line">min=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">swap(a,i,min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(1)</p><p>稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a)</span><span class="comment">//冒泡排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is_change=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;!is_change;i--)</span><br><span class="line">&#123;</span><br><span class="line">is_change=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">is_change=<span class="number">0</span>;</span><br><span class="line">swap(a,j,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(1)</p><p>稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charu_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a)</span><span class="comment">//插入排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;(a[j]&lt;a[j<span class="number">-1</span>]);j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a,j,j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>时间复杂度O（n*n）</p><p>空间复杂度O(M)</p><p>稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> h)</span> <span class="comment">//归并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=h;k++)</span><br><span class="line">&#123;</span><br><span class="line">b[k]=a[k]; <span class="comment">//数组复制到辅助数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=h;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;m)</span><br><span class="line">a[k]=b[j++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j&gt;h)</span><br><span class="line">a[k]=b[i++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[i]&lt;=b[j])</span><br><span class="line">&#123;</span><br><span class="line">a[k]=b[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[k]=b[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将一个大数组分成两个小数组去求解。</span></span><br><span class="line"><span class="comment">//因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l ,<span class="keyword">int</span> h)</span><span class="comment">//自顶向下归并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h&lt;=l)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+(h-l)/<span class="number">2</span>;</span><br><span class="line">merge_sort(a,l,mid);</span><br><span class="line">merge_sort(a,mid+<span class="number">1</span>,h);</span><br><span class="line">merge(a,l,mid,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间复杂度O（n*log(n)）</p><p>空间复杂度O(logN)-O(logN)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=l,j=h+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> divide_num=a[l];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((a[++i]&lt;divide_num)&amp;&amp;i!=h);</span><br><span class="line"><span class="keyword">while</span>((a[--j]&gt;divide_num)&amp;&amp;j!=l);</span><br><span class="line"><span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,i,j);</span><br><span class="line">&#125; </span><br><span class="line">swap(a,l,j);</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span><span class="comment">//当前的快排只是取最左边的第一个数作为划分点。 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=h)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> j=partition(a,l,h);</span><br><span class="line">quick_sort(a,l,j<span class="number">-1</span>);</span><br><span class="line">quick_sort(a,j+<span class="number">1</span>,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>不稳定</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度O（n*log（n））</p><p>空间复杂度O(1)</p><p>不稳定</p><h1 id="桶排序的思想"><a href="#桶排序的思想" class="headerlink" title="桶排序的思想"></a>桶排序的思想</h1><p>非比较的排序：</p><h2 id="计数排序："><a href="#计数排序：" class="headerlink" title="计数排序："></a>计数排序：</h2><p>稳定</p><h2 id="基数排序："><a href="#基数排序：" class="headerlink" title="基数排序："></a>基数排序：</h2><p>稳定</p>]]></content>
      
      
      <categories>
          
          <category> 面向面试学习法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP/IP 协议</title>
      <link href="/2018/11/16/TCP-IP-%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/11/16/TCP-IP-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h1><p>本文对TCP的三次握手和四次挥手做一个简单的小结。</p><a id="more"></a><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><ul><li><p>get参数通过url传递，post放在request body中。</p></li><li><p>get请求在url中传递的参数是有长度限制的，而post没有。</p></li><li><p>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p></li><li><ul><li><p>get请求只能进行url编码，而post支持多种编码方式</p></li><li><p>get请求会浏览器主动cache，而post支持多种编码方式。</p></li><li><p>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p></li></ul></li><li><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p></li></ul><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h2 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h2><p><img src="http://dl2.iteye.com/upload/attachment/0108/8317/ef70c29e-651b-33a4-b188-d4e8e0ff9915.png" alt="img"></p><p>上图中有几个字段需要重点介绍下：</p><p>  （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>  （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=Seq+1。</p><p>  （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><p>  （A）URG：紧急指针（urgent pointer）有效。</p><p>  （B）ACK：确认序号有效。</p><p>  （C）PSH：接收方应该尽快将这个报文交给应用层。</p><p>  （D）RST：重置连接。</p><p>  （E）SYN：发起一个新连接。</p><p>  （F）FIN：释放一个连接。</p><p> 需要注意的是：</p><p>  （A）不要将确认序号ack与标志位中的ACK搞混了。</p><p>  （B）确认方Ack=发起方Req+1，两端配对。 </p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><p>  所谓<strong>三次握手</strong>（Three-Way Handshake）即建立TCP连接，<strong>是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立</strong>。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：</p><p><img src="http://dl2.iteye.com/upload/attachment/0108/8313/8352d9a8-8c91-32e5-adf8-2bdaf8d567d6.png" alt="img"></p><p>第一次握手，Client 发送一个SYN表示建立一个新的连接，生成一个seq序号。然后处于SYN_SENT状态。</p><p>第二次握手，Server收到了数据包后，发送一个新的数据包。SYN=1,ACK=1（表示）确认，ack=J+1（上一个数据包的seq序号+1），再随机生成一个seq。Server进入SYN_RCVD状态。</p><p>第三次握手，Client收到了数据包后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，<strong>如果正确则连接建立成功，Client和Server进入ESTABLISHED状态</strong>，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><p><strong><em>SYN攻击：</em></strong></p><p>  在三次握手过程中，<strong>Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态</strong>，当收到ACK后，Server转入ESTABLISHED状态。<strong>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时</strong>，这些<strong>伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃</strong>，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p><p>#netstat -nap | grep SYN_RECV</p>  <figure class="highlight plain"><figcaption><span>-nap | grep SYN_RECV</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### **四次挥手**</span><br><span class="line"></span><br><span class="line">所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：</span><br><span class="line"></span><br><span class="line">![img](http://dl2.iteye.com/upload/attachment/0108/8315/51a9937d-3155-3a95-b853-97e8e20e758b.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</span><br><span class="line"></span><br><span class="line"> （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</span><br><span class="line"></span><br><span class="line">  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</span><br><span class="line"></span><br><span class="line"> （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</span><br><span class="line"></span><br><span class="line">  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</span><br><span class="line"></span><br><span class="line">![img](http://dl2.iteye.com/upload/attachment/0108/8321/b32a11f5-7b60-364b-874d-67b096bec348.jpg)</span><br><span class="line"></span><br><span class="line">上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：</span><br><span class="line"></span><br><span class="line">![img](http://dl2.iteye.com/upload/attachment/0108/8323/f8d7bde0-fd48-334a-bf6d-6be0b1706f86.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### **四、附注**</span><br><span class="line"></span><br><span class="line">  关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的XDJM们参考：</span><br><span class="line"></span><br><span class="line">  （1）三次握手是什么或者流程？四次握手呢？答案前面分析就是。</span><br><span class="line"></span><br><span class="line">  （2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  这是因为**服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据**，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 2</title>
      <link href="/2018/11/16/Leetcode-2/"/>
      <url>/2018/11/16/Leetcode-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode 2"></a>Leetcode 2</h1><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode*p1=l1;</span><br><span class="line">        ListNode*p2=l2;</span><br><span class="line">        ListNode *l3=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *l4=l3;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>||p2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 temp+=p1-&gt;val;  </span><br><span class="line">                 p1=p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              temp+=p2-&gt;val ;</span><br><span class="line">              p2=p2-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            l3-&gt;next=<span class="keyword">new</span> ListNode(temp%<span class="number">10</span>);   </span><br><span class="line">            temp=temp/<span class="number">10</span>;</span><br><span class="line">            l3=l3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l3-&gt;next=<span class="keyword">new</span> ListNode(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l4-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 31</title>
      <link href="/2018/11/16/Leetcode-31/"/>
      <url>/2018/11/16/Leetcode-31/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-31-Next-Permutation"><a href="#Leetcode-31-Next-Permutation" class="headerlink" title="Leetcode 31 Next Permutation"></a>Leetcode 31 Next Permutation</h1><p>详情见图</p><a id="more"></a><p><a href="https://leetcode.com/media/original_images/31_Next_Permutation.gif" target="_blank" rel="noopener">https://leetcode.com/media/original_images/31_Next_Permutation.gif</a></p><p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [31] Next Permutation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/next-permutation/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (29.41%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    188.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 640.4K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,2,3]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implement next permutation, which rearranges numbers into the</span></span><br><span class="line"><span class="comment"> * lexicographically next greater permutation of numbers.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If such arrangement is not possible, it must rearrange it as the lowest</span></span><br><span class="line"><span class="comment"> * possible order (ie, sorted in ascending order).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The replacement must be in-place and use only constant extra memory.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Here are some examples. Inputs are in the left-hand column and its</span></span><br><span class="line"><span class="comment"> * corresponding outputs are in the right-hand column.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1,2,3 → 1,3,2</span></span><br><span class="line"><span class="comment"> * 3,2,1 → 1,2,3</span></span><br><span class="line"><span class="comment"> * 1,1,5 → 1,5,1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">            reverse(nums.begin(), nums.end()); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = nums.size() - <span class="number">1</span>; j &gt; i; j--) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">            reverse(nums.begin() + i + <span class="number">1</span>, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Delete repeated element</title>
      <link href="/2018/11/15/Delete-repeated-element/"/>
      <url>/2018/11/15/Delete-repeated-element/</url>
      
        <content type="html"><![CDATA[<h1 id="删除数组中相同的元素"><a href="#删除数组中相同的元素" class="headerlink" title="删除数组中相同的元素"></a>删除数组中相同的元素</h1><a id="more"></a><h2 id="leetcode-26"><a href="#leetcode-26" class="headerlink" title="leetcode 26"></a>leetcode 26</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [26] Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (38.30%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    454.3K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 1.2M</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,1,2]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a sorted array nums, remove the duplicates in-place such that each</span></span><br><span class="line"><span class="comment"> * element appear only once and return the new length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Do not allocate extra space for another array, you must do this by modifying</span></span><br><span class="line"><span class="comment"> * the input array in-place with O(1) extra memory.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [1,1,2],</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 2, with the first two elements of nums</span></span><br><span class="line"><span class="comment"> * being 1 and 2 respectively.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what you leave beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [0,0,1,1,1,2,2,3,3,4],</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 5, with the first five elements of nums</span></span><br><span class="line"><span class="comment"> * being modified to 0, 1, 2, 3, and 4 respectively.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what values are set beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Clarification:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Confused why the returned value is an integer but your answer is an array?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the input array is passed in by reference, which means</span></span><br><span class="line"><span class="comment"> * modification to the input array will be known to the caller as well.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Internally you can think of this:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="comment"> * int len = removeDuplicates(nums);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment"> * // using the length returned by your function, it prints the first len</span></span><br><span class="line"><span class="comment"> * elements.</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment"> * print(nums[i]);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> lens=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[lens++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lens;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-27"><a href="#Leetcode-27" class="headerlink" title="Leetcode 27"></a>Leetcode 27</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [27] Remove Element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-element/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (42.38%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    332.6K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 784.7K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[3,2,2,3]\n3'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given an array nums and a value val, remove all instances of that value</span></span><br><span class="line"><span class="comment"> * in-place and return the new length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Do not allocate extra space for another array, you must do this by modifying</span></span><br><span class="line"><span class="comment"> * the input array in-place with O(1) extra memory.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The order of elements can be changed. It doesn't matter what you leave</span></span><br><span class="line"><span class="comment"> * beyond the new length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [3,2,2,3], val = 3,</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 2, with the first two elements of nums</span></span><br><span class="line"><span class="comment"> * being 2.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what you leave beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given nums = [0,1,2,2,3,0,4,2], val = 2,</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Your function should return length = 5, with the first five elements of nums</span></span><br><span class="line"><span class="comment"> * containing 0, 1, 3, 0, and 4.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the order of those five elements can be arbitrary.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * It doesn't matter what values are set beyond the returned length.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Clarification:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Confused why the returned value is an integer but your answer is an array?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the input array is passed in by reference, which means</span></span><br><span class="line"><span class="comment"> * modification to the input array will be known to the caller as well.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Internally you can think of this:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="comment"> * int len = removeElement(nums, val);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * // any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment"> * // using the length returned by your function, it prints the first len</span></span><br><span class="line"><span class="comment"> * elements.</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment"> * print(nums[i]);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lens=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[lens]=nums[i];</span><br><span class="line">                lens++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lens;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP/IP 第一章</title>
      <link href="/2018/11/15/TCP-IP-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2018/11/15/TCP-IP-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP网络编程-第一章"><a href="#TCP-IP网络编程-第一章" class="headerlink" title="TCP/IP网络编程 第一章"></a>TCP/IP网络编程 第一章</h1><h2 id="创建套接字的过程"><a href="#创建套接字的过程" class="headerlink" title="创建套接字的过程"></a>创建套接字的过程</h2><a id="more"></a><h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handing</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">    <span class="keyword">char</span> message[]=<span class="string">"Hello world!"</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serv_sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"socker() error!"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);<span class="comment">//IP</span></span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>])); <span class="comment">//port</span></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handing(<span class="string">"bind()!error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">           error_handing(<span class="string">"listen()!error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    clnt_sock=accept(serv_sock,(struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            error_handing(<span class="string">"accept()!error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(clnt_sock,message,<span class="keyword">sizeof</span>(message));</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先创建socket套接字</li><li>用bind分配IP和端口号</li><li>用listen函数将socket转换成可以接收连接的状态</li><li>用accept函数接收请求连接</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">   <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">   <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>struct sockaddr 是通用的套接字地址，而struct sockaddr_in 是Internet环境下的套接字地址形式。两者的长度一样，都是16字节。两者是并列结构，指向sockaddr_in结构的指针也可以指向sockaddr。</p><p><strong>一般情况下，需要把sockaddr_in结构强制转换成sockaddr结构，再传入系统函数中</strong> </p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handing</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"socket()!error!"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"connect() error!"</span>);</span><br><span class="line">    </span><br><span class="line">    str_len=read(sock,message,<span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str_len==<span class="number">-1</span>)</span><br><span class="line">        error_handing(<span class="string">"read()!error!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>,message);</span><br><span class="line">    close(sock);</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Deblur 论文总结</title>
      <link href="/2018/11/14/Deblur-%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/14/Deblur-%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h1><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>图像模糊一般被看作清晰图像卷积模糊核得到模糊图像的过程，其退化模型如下式所示：</p><p><img src="https://img-blog.csdn.net/20161010131848914" alt="img"></p><p>其中，B为模糊图像( blurry image )，I为待估计的清晰图像( latent image )，K为模糊核( blur kernel )，N为附加的噪声，ⓧ为卷积操作。</p><h3 id="图像卷积基本概念"><a href="#图像卷积基本概念" class="headerlink" title="图像卷积基本概念"></a>图像卷积基本概念</h3><h4 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h4><p>　　线性滤波是图像处理的基本方法。假设我们有图像矩阵A和滤波器矩阵（卷积核）B，如下图所示： </p><p><img src="https://img-blog.csdn.net/20161010152740621" alt="img"><img src="https://img-blog.csdn.net/20161010152826162" alt="img">   </p><p>​    对于图像的每一个像素点，计算它的邻域像素和滤波器矩阵的对应元素的乘积，然后加起来，作为该像素位置的值。这样就完成了滤波过程。 </p><p><img src="https://img-blog.csdn.net/20161010153027585" alt="img"></p><p><strong>卷积与相关</strong><br>　　对图像和滤波矩阵进行逐个元素相乘再求和的操作就相当于将一个二维的函数移动到另一个二维函数的所有位置，这个操作就叫卷积或者相关。卷积和相关的差别是，卷积需要先对滤波矩阵进行180的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。</p><p><strong>模糊核（卷积核）</strong><br>　　模糊核实际上就是一个矩阵，清晰图像与模糊核卷积后导致图像变得模糊，因此叫模糊核。模糊核是卷积核的一种。图像卷积操作的本质是矩阵卷积。某些特殊的卷积核会使图像产生特殊的效果。</p><h2 id="编码器-解码器网络-U-net"><a href="#编码器-解码器网络-U-net" class="headerlink" title="编码器-解码器网络(U-net)"></a>编码器-解码器网络(U-net)</h2><p><a href="http://www.bubuko.com/infodetail-2608619.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-2608619.html</a></p><p>卷积层负责特征提取，捕获图像内容的抽象信息，同时消除噪声/损失。相对应，反卷积层用来恢复图像细节。</p><h2 id="Scale-recurrent-Network-for-Deep-Image-Deblurring"><a href="#Scale-recurrent-Network-for-Deep-Image-Deblurring" class="headerlink" title="Scale-recurrent Network for Deep Image Deblurring"></a>Scale-recurrent Network for Deep Image Deblurring</h2><h2 id="尺度循环网络（SRN）"><a href="#尺度循环网络（SRN）" class="headerlink" title="尺度循环网络（SRN）"></a>尺度循环网络（SRN）</h2><h3 id="创新点："><a href="#创新点：" class="headerlink" title="创新点："></a>创新点：</h3><p><img src="http://static.tongtianta.site/paper_image/2520f142-6ae1-11e8-8a08-6045cb803e2f/image_1_0_0.jpg" alt="img"></p><p>用于图像处理的不同CNN。（a）U-Net [27]或编码器 - 解码器网络[24]。 （b）多尺度[25]或级联改良网络[4]。（c）扩张卷积网络[5]。（d）我们提出的规模经常性网络（SRN）。</p><ul><li><p><strong>网络结构上</strong>：在多尺度模型里，每一尺度的网络结构和任务都相似，但是各尺度的参数仍然是相互独立的。本文提出的在不同尺度之间共享网络权重可以减少网络参数、使模型的学习能力更加稳固。</p></li><li><p><strong>编解码残差网络结构：</strong>编解码器的结构在CV任务中非常有用，与残差网络相结合可以结合两者优势，还能扩大感受野，对于捕捉运动模糊很重要。本文设计的网络训练收敛快、参数少、去模糊效果好，超过了当前的最好水平。</p></li></ul><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作:"></a>相关工作:</h3><ul><li>利用图像的各种先验知识</li><li>带跳跃连接的自编码器</li><li>U-net(编解码器网络)</li><li>多尺度网络。</li></ul><h3 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a>网络结构：</h3><p><img src="https://img-blog.csdn.net/2018062313015729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI4NjM1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>在每一个尺度上，以两张图像作为输入，一张模糊图像，一张上采样后的去模糊图像。同时还在中间输入了隐藏状态的特征。循环网络用ConvLSTM.它能在利用时间相关性的同时利用空间相关性。不同尺度之间对图像和feature的上采样都使用双线性插值（bilinear interpolation），因为简单有效。</p>]]></content>
      
      
      <categories>
          
          <category> CV论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 误差建模 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode23</title>
      <link href="/2018/11/12/Leetcode23/"/>
      <url>/2018/11/12/Leetcode23/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h1><p>  √ Accepted<br>  √ 131/131 cases passed (20 ms)<br>  √ Your runtime beats 55.85 % of cpp submissions</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [23] Merge k Sorted Lists</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/merge-k-sorted-lists/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Hard (30.96%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    291.4K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 938.7K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[[1,4,5],[1,3,4],[2,6]]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Merge k sorted linked lists and return it as one sorted list. Analyze and</span></span><br><span class="line"><span class="comment"> * describe its complexity.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * 1-&gt;4-&gt;5,</span></span><br><span class="line"><span class="comment"> * 1-&gt;3-&gt;4,</span></span><br><span class="line"><span class="comment"> * 2-&gt;6</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> k=lists.size();</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k/<span class="number">2</span>;i++)</span><br><span class="line">                lists[i]=merge2List2(lists[i],lists[i+n]);</span><br><span class="line">            k=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode*<span class="title">merge2List2</span><span class="params">(ListNode*l1,ListNode*l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *ans1=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *ans = ans1;  </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ans-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)ans-&gt;next=l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">            ans-&gt;next=l1;</span><br><span class="line">        <span class="keyword">return</span> ans1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 10 Generate Parentheses</title>
      <link href="/2018/11/09/Leetcode10/"/>
      <url>/2018/11/09/Leetcode10/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-10-Regular-Expression-Matching"><a href="#Leetcode-10-Regular-Expression-Matching" class="headerlink" title="Leetcode 10 Regular Expression Matching"></a>Leetcode 10 Regular Expression Matching</h1><p>  √ Accepted<br>  √ 447/447 cases passed (4 ms)<br>  √ Your runtime beats 71.84 % of cpp submissions</p><a id="more"></a><figure class="highlight plain"><figcaption><span>Leetcode-22</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * [10] Regular Expression Matching</span><br><span class="line"> *</span><br><span class="line"> * https://leetcode.com/problems/regular-expression-matching/description/</span><br><span class="line"> *</span><br><span class="line"> * algorithms</span><br><span class="line"> * Hard (24.44%)</span><br><span class="line"> * Total Accepted:    240.5K</span><br><span class="line"> * Total Submissions: 984.1K</span><br><span class="line"> * Testcase Example:  &apos;&quot;aa&quot;\n&quot;a&quot;&apos;</span><br><span class="line"> *</span><br><span class="line"> * Given an input string (s) and a pattern (p), implement regular expression</span><br><span class="line"> * matching with support for &apos;.&apos; and &apos;*&apos;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * &apos;.&apos; Matches any single character.</span><br><span class="line"> * &apos;*&apos; Matches zero or more of the preceding element.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * The matching should cover the entire input string (not partial).</span><br><span class="line"> * </span><br><span class="line"> * Note:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * s could be empty and contains only lowercase letters a-z.</span><br><span class="line"> * p could be empty and contains only lowercase letters a-z, and characters</span><br><span class="line"> * like . or *.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 1:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;aa&quot;</span><br><span class="line"> * p = &quot;a&quot;</span><br><span class="line"> * Output: false</span><br><span class="line"> * Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 2:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;aa&quot;</span><br><span class="line"> * p = &quot;a*&quot;</span><br><span class="line"> * Output: true</span><br><span class="line"> * Explanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;.</span><br><span class="line"> * Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 3:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;ab&quot;</span><br><span class="line"> * p = &quot;.*&quot;</span><br><span class="line"> * Output: true</span><br><span class="line"> * Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 4:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;aab&quot;</span><br><span class="line"> * p = &quot;c*a*b&quot;</span><br><span class="line"> * Output: true</span><br><span class="line"> * Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore</span><br><span class="line"> * it matches &quot;aab&quot;.</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Example 5:</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Input:</span><br><span class="line"> * s = &quot;mississippi&quot;</span><br><span class="line"> * p = &quot;mis*is*p*.&quot;</span><br><span class="line"> * Output: false</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int lens=s.size();</span><br><span class="line">        int lenp=p.size();</span><br><span class="line">        bool **dp=new bool*[lens+2];</span><br><span class="line">        for(int i=0;i&lt;lens+2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=new bool[lenp+2];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;lens+2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;lenp+2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][0]=true;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;lenp;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[i]==&apos;*&apos;&amp;&amp;dp[0][i-1])</span><br><span class="line">                dp[0][i+1]=true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;lens;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;lenp;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(s[i]==p[j]||p[j]==&apos;.&apos;)</span><br><span class="line">                    dp[i+1][j+1]=dp[i][j];</span><br><span class="line">                else if(p[j]==&apos;*&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(p[j-1]!=s[i]&amp;&amp;p[j-1]!=&apos;.&apos;)</span><br><span class="line">                        dp[i+1][j+1]=dp[i+1][j-1];</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i+1][j+1]=(dp[i+1][j]//表示*匹配了1个字符</span><br><span class="line">                        ||dp[i][j+1]//表示*匹配了多个字符</span><br><span class="line">                        ||dp[i+1][j-1]);//表示*匹配了0个字符</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[lens][lenp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 22 Generate Parentheses</title>
      <link href="/2018/11/08/Leetcode22/"/>
      <url>/2018/11/08/Leetcode22/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-22-Generate-Parentheses"><a href="#Leetcode-22-Generate-Parentheses" class="headerlink" title="Leetcode 22 Generate Parentheses"></a>Leetcode 22 Generate Parentheses</h1><p>(  √ Accepted</p><p>√ 8/8 cases passed (0 ms)</p><p>√ Your runtime beats 31.94 % of cpp submissions )</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [22] Generate Parentheses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/generate-parentheses/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Medium (50.99%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    261.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 513.5K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '3'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Given n pairs of parentheses, write a function to generate all combinations</span></span><br><span class="line"><span class="comment"> * of well-formed parentheses.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * For example, given n = 3, a solution set is:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ⁠ "((()))",</span></span><br><span class="line"><span class="comment"> * ⁠ "(()())",</span></span><br><span class="line"><span class="comment"> * ⁠ "(())()",</span></span><br><span class="line"><span class="comment"> * ⁠ "()(())",</span></span><br><span class="line"><span class="comment"> * ⁠ "()()()"</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrade</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;ans,<span class="built_in">string</span> ans1,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(ans1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrade(ans,ans1+<span class="string">"("</span>,left<span class="number">-1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrade(ans,ans1+<span class="string">")"</span>,left,right<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        backtrade(res,<span class="string">""</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
